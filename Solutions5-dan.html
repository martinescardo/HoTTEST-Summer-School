<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p>Note: for this week we have two solution files for the exercises. Dan
Licata’s solutions are below. Tom de Jong’s solutions in are in
Solutions5-tom.lagda.md. We are providing both to illustrate slightly
different ways of using Agda. Tom’s are a little more verbose and easier
for a person to read non-interactively. Dan’s are a little more inlined
and meant to show you roughly the minimum text you need to get Agda to
check the proofs, but are harder to read unless you do so interactively
(by putting holes around sub-expressions and getting Agda to tell you
what the types are supposed to be). It’s sometimes nice to code in the
terse style when you are coding for yourself, and then to clean it up
more like the more verbose solution when writing it up for other
people.</p>
<p>Note: Agda will get confused if you make a single file that imports
both our solutions and your solutions in Exercises5. The reason is that
rewrite rules are installed globally, and both files declare rewrites
for the reduction rules for suspension types (if you get that far), and
Agda won’t let you install a rewrite for something that already reduces.
(For a similar reason, Solutions5-tom has the rewrites commented out to
make our build scripts for github work, so you will need to uncomment
those in your copy to load the file.)</p>
<pre class="Agda"><a id="1330" class="Symbol">{-#</a> <a id="1334" class="Keyword">OPTIONS</a> <a id="1342" class="Pragma">--rewriting</a> <a id="1354" class="Pragma">--without-K</a> <a id="1366" class="Symbol">#-}</a>

<a id="1371" class="Keyword">open</a> <a id="1376" class="Keyword">import</a> <a id="1383" href="new-prelude.html" class="Module">new-prelude</a>
<a id="1395" class="Keyword">open</a> <a id="1400" class="Keyword">import</a> <a id="1407" href="Lecture5-notes.html" class="Module">Lecture5-notes</a>
<a id="1422" class="Keyword">open</a> <a id="1427" class="Keyword">import</a> <a id="1434" href="Solutions4.html" class="Module">Solutions4</a> <a id="1445" class="Keyword">using</a> <a id="1451" class="Symbol">(</a><a id="1452" href="Solutions4.html#2239" data-type="(p : x ≡ y) → ap f (! p) ≡ ! (ap f p)" class="Function">ap-!</a><a id="1456" class="Symbol">;</a> <a id="1458" href="Solutions4.html#2862" data-type="from (to base) ≡ base" class="Function">to-from-base</a><a id="1470" class="Symbol">;</a> <a id="1472" href="Solutions4.html#2922" data-type="ap from (ap to loop) ≡ loop" class="Function">to-from-loop</a><a id="1484" class="Symbol">;</a> <a id="1486" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a><a id="1489" class="Symbol">;</a> <a id="1491" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a><a id="1494" class="Symbol">;</a> <a id="1496" href="Solutions4.html#5241" data-type="(X → Y) → Susp X → Susp Y" class="Function">susp-func</a><a id="1505" class="Symbol">)</a>

<a id="1508" class="Keyword">module</a> <a id="1515" href="Solutions5-dan.html" class="Module">Solutions5-dan</a> <a id="1530" class="Keyword">where</a>
</pre>
<h1 id="point-and-2-point-circles-are-equivalent">1 point and 2 point
circles are equivalent (⋆)</h1>
<p>In lecture, we defined maps between the one point circle (S1) and the
two point circle (Circle2) and checked that the round-trip on Circle2 is
the identity.</p>
<p>Prove that the round-trip on S1 is the identity (use to-from-base and
to-from-loop from the Lecture 4 exercises), and package all of these
items up as an equivalence S1 ≃ Circle2.</p>
<pre class="Agda"><a id="to-from"></a><a id="1940" href="Solutions5-dan.html#1940" data-type="(x : S1) → from (to x) ≡ x" class="Function">to-from</a> <a id="1948" class="Symbol">:</a> <a id="1950" class="Symbol">(</a><a id="1951" href="Solutions5-dan.html#1951" class="Bound">x</a> <a id="1953" class="Symbol">:</a> <a id="1955" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a><a id="1957" class="Symbol">)</a> <a id="1959" class="Symbol">→</a> <a id="1961" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="1966" class="Symbol">(</a><a id="1967" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="1970" href="Solutions5-dan.html#1951" class="Bound">x</a><a id="1971" class="Symbol">)</a> <a id="1973" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="1975" href="Solutions5-dan.html#1951" class="Bound">x</a>
<a id="1977" href="Solutions5-dan.html#1940" data-type="(x : S1) → from (to x) ≡ x" class="Function">to-from</a> <a id="1985" class="Symbol">=</a> <a id="1987" href="Lecture5-notes.html#8628" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="1995" class="Symbol">_</a>
                  <a id="2015" href="Solutions4.html#2862" data-type="from (to base) ≡ base" class="Function">to-from-base</a>
                  <a id="2046" class="Symbol">(</a><a id="2047" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
! q ∙ (ap g (ap f p) ∙ r) ≡ p → PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="2067" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="2072" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="2075" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="2080" class="Symbol">(</a><a id="2081" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="2089" class="Symbol">_</a> <a id="2091" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2093" href="Solutions4.html#2922" data-type="ap from (ap to loop) ≡ loop" class="Function">to-from-loop</a><a id="2105" class="Symbol">))</a>

<a id="circles-equivalent"></a><a id="2109" href="Solutions5-dan.html#2109" data-type="S1 ≃ Circle2" class="Function">circles-equivalent</a> <a id="2128" class="Symbol">:</a> <a id="2130" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="2133" href="Lecture5-notes.html#968" data-type="(A : Set l1) (B : Set l2) → Set (l1 ⊔ l2)" class="Record Operator">≃</a> <a id="2135" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a>
<a id="2143" href="Solutions5-dan.html#2109" data-type="S1 ≃ Circle2" class="Function">circles-equivalent</a> <a id="2162" class="Symbol">=</a> <a id="2164" href="Lecture5-notes.html#1565" data-type="A ≅ B → A ≃ B" class="Function">improve</a> <a id="2172" class="Symbol">(</a><a id="2173" href="new-prelude.html#2950" data-type="(bijection : A → B) (bijectivity : is-bijection bijection) → A ≅ B" class="InductiveConstructor">Isomorphism</a> <a id="2185" href="Lecture5-notes.html#6661" data-type="S1 → Circle2" class="Function">to</a> <a id="2188" class="Symbol">(</a><a id="2189" href="new-prelude.html#2765" data-type="(inverse : B → A) (η : (inverse ∘ f) ∼ id)
(ε : (f ∘ inverse) ∼ id) →
is-bijection f" class="InductiveConstructor">Inverse</a> <a id="2197" href="Lecture5-notes.html#6720" data-type="Circle2 → S1" class="Function">from</a> <a id="2202" href="Solutions5-dan.html#1940" data-type="(x : S1) → from (to x) ≡ x" class="Function">to-from</a> <a id="2210" href="Lecture5-notes.html#8252" data-type="(y : Circle2) → to (from y) ≡ y" class="Function">from-to</a><a id="2217" class="Symbol">))</a>
</pre>
<h1 id="reversing-the-circle">Reversing the circle (⋆⋆)</h1>
<p>Define a map S1 → S1 that “reverses the orientation of the circle”,
i.e. sends loop to ! loop.</p>
<pre class="Agda"><a id="rev"></a><a id="2359" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a> <a id="2363" class="Symbol">:</a> <a id="2365" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="2368" class="Symbol">→</a> <a id="2370" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a>
<a id="2373" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a> <a id="2377" class="Symbol">=</a> <a id="2379" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="2386" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a> <a id="2391" class="Symbol">(</a><a id="2392" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="2394" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a><a id="2398" class="Symbol">)</a>
</pre>
Prove that rev is an equivalence. Hint: you will need to state and prove
one new generalized “path algebra” lemma and to use one of the lemmas
from the “Functions are group homomorphism” section of Lecture 4’s
exercises.<br />
<pre class="Agda"><a id="!-invol"></a><a id="2633" href="Solutions5-dan.html#2633" data-type="(p : x ≡ y) → ! (! p) ≡ p" class="Function">!-invol</a> <a id="2641" class="Symbol">:</a> <a id="2643" class="Symbol">{</a><a id="2644" href="Solutions5-dan.html#2644" class="Bound">l</a> <a id="2646" class="Symbol">:</a> <a id="2648" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="2653" class="Symbol">}</a> <a id="2655" class="Symbol">{</a><a id="2656" href="Solutions5-dan.html#2656" class="Bound">A</a> <a id="2658" class="Symbol">:</a> <a id="2660" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="2665" href="Solutions5-dan.html#2644" class="Bound">l</a><a id="2666" class="Symbol">}</a> <a id="2668" class="Symbol">{</a><a id="2669" href="Solutions5-dan.html#2669" class="Bound">x</a> <a id="2671" href="Solutions5-dan.html#2671" class="Bound">y</a> <a id="2673" class="Symbol">:</a> <a id="2675" href="Solutions5-dan.html#2656" class="Bound">A</a><a id="2676" class="Symbol">}</a> <a id="2678" class="Symbol">→</a> <a id="2680" class="Symbol">(</a><a id="2681" href="Solutions5-dan.html#2681" class="Bound">p</a> <a id="2683" class="Symbol">:</a> <a id="2685" href="Solutions5-dan.html#2669" class="Bound">x</a> <a id="2687" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="2689" href="Solutions5-dan.html#2671" class="Bound">y</a><a id="2690" class="Symbol">)</a> <a id="2692" class="Symbol">→</a> <a id="2694" class="Symbol">(</a><a id="2695" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="2697" class="Symbol">(</a><a id="2698" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="2700" href="Solutions5-dan.html#2681" class="Bound">p</a><a id="2701" class="Symbol">))</a> <a id="2704" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="2706" href="Solutions5-dan.html#2681" class="Bound">p</a>
<a id="2708" href="Solutions5-dan.html#2633" data-type="(p : x ≡ y) → ! (! p) ≡ p" class="Function">!-invol</a> <a id="2716" class="Symbol">(</a><a id="2717" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="2722" class="Symbol">_)</a> <a id="2725" class="Symbol">=</a> <a id="2727" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="2732" class="Symbol">_</a>

<a id="rev-equiv"></a><a id="2735" href="Solutions5-dan.html#2735" data-type="is-equiv rev" class="Function">rev-equiv</a> <a id="2745" class="Symbol">:</a> <a id="2747" href="Lecture5-notes.html#699" data-type="(f : A → B) → Set (l1 ⊔ l2)" class="Record">is-equiv</a> <a id="2756" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a>
<a id="2760" href="Solutions5-dan.html#2735" data-type="is-equiv rev" class="Function">rev-equiv</a> <a id="2770" class="Symbol">=</a> <a id="2772" href="Lecture5-notes.html#801" data-type="(post-inverse : B → A) (is-post-inverse : (post-inverse ∘ f) ∼ id)
(pre-inverse : B → A) (is-pre-inverse : (f ∘ pre-inverse) ∼ id) →
is-equiv f" class="InductiveConstructor">Inverse</a> <a id="2780" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a> <a id="2784" href="Solutions5-dan.html#2808" data-type="(rev ∘ rev) ∼ id" class="Function">invol</a> <a id="2790" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a> <a id="2794" href="Solutions5-dan.html#2808" data-type="(rev ∘ rev) ∼ id" class="Function">invol</a> <a id="2800" class="Keyword">where</a>
  <a id="2808" href="Solutions5-dan.html#2808" data-type="(rev ∘ rev) ∼ id" class="Function">invol</a> <a id="2814" class="Symbol">:</a> <a id="2816" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a> <a id="2820" href="new-prelude.html#2059" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="2822" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a> <a id="2826" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="2828" href="new-prelude.html#2011" data-type="A → A" class="Function">id</a>
  <a id="2833" href="Solutions5-dan.html#2808" data-type="(rev ∘ rev) ∼ id" class="Function">invol</a> <a id="2839" class="Symbol">=</a> <a id="2841" href="Lecture5-notes.html#8628" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="2849" class="Symbol">_</a>
                  <a id="2869" class="Symbol">(</a><a id="2870" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="2875" class="Symbol">_)</a>
                  <a id="2896" class="Symbol">(</a><a id="2897" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
! q ∙ (ap g (ap f p) ∙ r) ≡ p → PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="2917" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a> <a id="2921" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a> <a id="2925" class="Symbol">_</a>
                    <a id="2947" class="Symbol">(</a><a id="2948" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="2956" class="Symbol">_</a> <a id="2958" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                     <a id="2981" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="2984" class="Symbol">(</a><a id="2985" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="2988" href="Solutions5-dan.html#2359" data-type="S1 → S1" class="Function">rev</a><a id="2991" class="Symbol">)</a> <a id="2993" class="Symbol">(</a><a id="2994" href="Lecture4-notes.html#6311" data-type="(x : X) (p : x ≡ x) → ap (S1-rec x p) loop ≡ p" class="Postulate">S1-rec-loop</a> <a id="3006" class="Symbol">_</a> <a id="3008" class="Symbol">_)</a> <a id="3011" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                     <a id="3034" href="Solutions4.html#2239" data-type="(p : x ≡ y) → ap f (! p) ≡ ! (ap f p)" class="Function">ap-!</a> <a id="3039" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="3044" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                     <a id="3067" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="3070" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="3072" class="Symbol">(</a><a id="3073" href="Lecture4-notes.html#6311" data-type="(x : X) (p : x ≡ x) → ap (S1-rec x p) loop ≡ p" class="Postulate">S1-rec-loop</a> <a id="3085" class="Symbol">_</a> <a id="3087" class="Symbol">_)</a> <a id="3090" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                     <a id="3113" href="Solutions5-dan.html#2633" data-type="(p : x ≡ y) → ! (! p) ≡ p" class="Function">!-invol</a> <a id="3121" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a><a id="3125" class="Symbol">))</a>
</pre>
<h1 id="circles-to-torus">Circles to torus (⋆⋆)</h1>
<p>In the Lecture 4 exercises, you defined a map from the Torus to S1 ×
S1. In this problem, you will define a converse map. The goal is for
these two maps to be part of an equivalence, but we won’t prove that in
these exercises.</p>
<p>You will need to state and prove a lemma characterizing a path over a
path in a path fibration. Then, to define the map S1 × S1 → Torus, you
will want to curry it and use S1-rec and/or S1-elim on each circle.</p>
<pre class="Agda"><a id="PathOver-path≡"></a><a id="3611" href="Solutions5-dan.html#3611" data-type="q ∙ ap g p ≡ ap f p ∙ r → PathOver (λ x → f x ≡ g x) p q r" class="Function">PathOver-path≡</a> <a id="3626" class="Symbol">:</a> <a id="3628" class="Symbol">∀</a> <a id="3630" class="Symbol">{</a><a id="3631" href="Solutions5-dan.html#3631" class="Bound">A</a> <a id="3633" href="Solutions5-dan.html#3633" class="Bound">B</a> <a id="3635" class="Symbol">:</a> <a id="3637" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="3641" class="Symbol">}</a> <a id="3643" class="Symbol">{</a><a id="3644" href="Solutions5-dan.html#3644" class="Bound">g</a> <a id="3646" class="Symbol">:</a> <a id="3648" href="Solutions5-dan.html#3631" class="Bound">A</a> <a id="3650" class="Symbol">→</a> <a id="3652" href="Solutions5-dan.html#3633" class="Bound">B</a><a id="3653" class="Symbol">}</a> <a id="3655" class="Symbol">{</a><a id="3656" href="Solutions5-dan.html#3656" class="Bound">f</a> <a id="3658" class="Symbol">:</a> <a id="3660" href="Solutions5-dan.html#3631" class="Bound">A</a> <a id="3662" class="Symbol">→</a> <a id="3664" href="Solutions5-dan.html#3633" class="Bound">B</a><a id="3665" class="Symbol">}</a>
                          <a id="3693" class="Symbol">{</a><a id="3694" href="Solutions5-dan.html#3694" class="Bound">a</a> <a id="3696" href="Solutions5-dan.html#3696" class="Bound">a&#39;</a> <a id="3699" class="Symbol">:</a> <a id="3701" href="Solutions5-dan.html#3631" class="Bound">A</a><a id="3702" class="Symbol">}</a> <a id="3704" class="Symbol">{</a><a id="3705" href="Solutions5-dan.html#3705" class="Bound">p</a> <a id="3707" class="Symbol">:</a> <a id="3709" href="Solutions5-dan.html#3694" class="Bound">a</a> <a id="3711" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="3713" href="Solutions5-dan.html#3696" class="Bound">a&#39;</a><a id="3715" class="Symbol">}</a>
                          <a id="3743" class="Symbol">{</a><a id="3744" href="Solutions5-dan.html#3744" class="Bound">q</a> <a id="3746" class="Symbol">:</a> <a id="3748" class="Symbol">(</a><a id="3749" href="Solutions5-dan.html#3656" class="Bound">f</a> <a id="3751" href="Solutions5-dan.html#3694" class="Bound">a</a><a id="3752" class="Symbol">)</a> <a id="3754" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="3756" class="Symbol">(</a><a id="3757" href="Solutions5-dan.html#3644" class="Bound">g</a> <a id="3759" href="Solutions5-dan.html#3694" class="Bound">a</a><a id="3760" class="Symbol">)}</a>
                          <a id="3789" class="Symbol">{</a><a id="3790" href="Solutions5-dan.html#3790" class="Bound">r</a> <a id="3792" class="Symbol">:</a> <a id="3794" class="Symbol">(</a><a id="3795" href="Solutions5-dan.html#3656" class="Bound">f</a> <a id="3797" href="Solutions5-dan.html#3696" class="Bound">a&#39;</a><a id="3799" class="Symbol">)</a> <a id="3801" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="3803" class="Symbol">(</a><a id="3804" href="Solutions5-dan.html#3644" class="Bound">g</a> <a id="3806" href="Solutions5-dan.html#3696" class="Bound">a&#39;</a><a id="3808" class="Symbol">)}</a>
                        <a id="3835" class="Symbol">→</a> <a id="3837" href="Solutions5-dan.html#3744" class="Bound">q</a> <a id="3839" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3841" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="3844" href="Solutions5-dan.html#3644" class="Bound">g</a> <a id="3846" href="Solutions5-dan.html#3705" class="Bound">p</a> <a id="3848" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="3850" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="3853" href="Solutions5-dan.html#3656" class="Bound">f</a> <a id="3855" href="Solutions5-dan.html#3705" class="Bound">p</a> <a id="3857" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3859" href="Solutions5-dan.html#3790" class="Bound">r</a>
                        <a id="3885" class="Symbol">→</a> <a id="3887" href="Solutions5-dan.html#3744" class="Bound">q</a> <a id="3889" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="3891" href="Solutions5-dan.html#3790" class="Bound">r</a> <a id="3893" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="3895" class="Symbol">(\</a> <a id="3898" href="Solutions5-dan.html#3898" class="Bound">x</a> <a id="3900" class="Symbol">→</a> <a id="3902" class="Symbol">(</a><a id="3903" href="Solutions5-dan.html#3656" class="Bound">f</a> <a id="3905" href="Solutions5-dan.html#3898" class="Bound">x</a><a id="3906" class="Symbol">)</a> <a id="3908" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="3910" class="Symbol">(</a><a id="3911" href="Solutions5-dan.html#3644" class="Bound">g</a> <a id="3913" href="Solutions5-dan.html#3898" class="Bound">x</a><a id="3914" class="Symbol">))</a> <a id="3917" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="3919" href="Solutions5-dan.html#3705" class="Bound">p</a> <a id="3921" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a>
<a id="3923" href="Solutions5-dan.html#3611" data-type="q ∙ ap g p ≡ ap f p ∙ r → PathOver (λ x → f x ≡ g x) p q r" class="Function">PathOver-path≡</a> <a id="3938" class="Symbol">{</a><a id="3939" class="Argument">p</a> <a id="3941" class="Symbol">=</a> <a id="3943" class="Symbol">(</a><a id="3944" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="3949" class="Symbol">_)}</a> <a id="3953" href="Solutions5-dan.html#3953" class="Bound">h</a> <a id="3955" class="Symbol">=</a> <a id="3957" href="Lecture5-notes.html#4578" data-type="x ≡ y → PathOver B (refl a) x y" class="Function">path-to-pathover</a> <a id="3974" class="Symbol">(</a><a id="3975" href="Solutions5-dan.html#3953" class="Bound">h</a> <a id="3977" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="3979" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="3987" class="Symbol">_)</a>

<a id="circles-to-torus"></a><a id="3991" href="Solutions5-dan.html#3991" data-type="S1 → S1 → Torus" class="Function">circles-to-torus</a> <a id="4008" class="Symbol">:</a> <a id="4010" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="4013" class="Symbol">→</a> <a id="4015" class="Symbol">(</a><a id="4016" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="4019" class="Symbol">→</a> <a id="4021" href="Lecture4-notes.html#10700" data-type="Set" class="Postulate">Torus</a><a id="4026" class="Symbol">)</a>
<a id="4028" href="Solutions5-dan.html#3991" data-type="S1 → S1 → Torus" class="Function">circles-to-torus</a> <a id="4045" class="Symbol">=</a> <a id="4047" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="4054" class="Symbol">(</a><a id="4055" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="4062" href="Lecture4-notes.html#10715" data-type="Torus" class="Postulate">baseT</a> <a id="4068" href="Lecture4-notes.html#10752" data-type="baseT ≡ baseT" class="Postulate">qT</a><a id="4070" class="Symbol">)</a>
                          <a id="4098" class="Symbol">(</a><a id="4099" href="new-prelude.html#2559" data-type="f ∼ g → f ≡ g" class="Postulate">λ≡</a> <a id="4102" class="Symbol">(</a><a id="4103" href="Lecture5-notes.html#8628" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="4111" class="Symbol">_</a>
                                       <a id="4152" href="Lecture4-notes.html#10731" data-type="baseT ≡ baseT" class="Postulate">pT</a>
                                       <a id="4194" class="Symbol">(</a><a id="4195" href="Solutions5-dan.html#3611" data-type="q ∙ ap g p ≡ ap f p ∙ r → PathOver (λ x → f x ≡ g x) p q r" class="Function">PathOver-path≡</a> <a id="4210" class="Symbol">(</a><a id="4211" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="4214" class="Symbol">(\</a> <a id="4217" href="Solutions5-dan.html#4217" class="Bound">H</a> <a id="4219" class="Symbol">→</a> <a id="4221" href="Lecture4-notes.html#10731" data-type="baseT ≡ baseT" class="Postulate">pT</a> <a id="4224" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4226" href="Solutions5-dan.html#4217" class="Bound">H</a><a id="4227" class="Symbol">)</a> <a id="4229" class="Symbol">(</a><a id="4230" href="Lecture4-notes.html#6311" data-type="(x : X) (p : x ≡ x) → ap (S1-rec x p) loop ≡ p" class="Postulate">S1-rec-loop</a> <a id="4242" class="Symbol">_</a> <a id="4244" class="Symbol">_)</a> <a id="4247" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                        <a id="4305" href="Lecture4-notes.html#10773" data-type="pT ∙ qT ≡ qT ∙ pT" class="Postulate">sT</a> <a id="4308" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                        <a id="4366" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="4369" class="Symbol">(\</a> <a id="4372" href="Solutions5-dan.html#4372" class="Bound">H</a> <a id="4374" class="Symbol">→</a> <a id="4376" href="Solutions5-dan.html#4372" class="Bound">H</a> <a id="4378" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4380" href="Lecture4-notes.html#10731" data-type="baseT ≡ baseT" class="Postulate">pT</a><a id="4382" class="Symbol">)</a> <a id="4384" class="Symbol">(</a><a id="4385" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="4387" class="Symbol">(</a><a id="4388" href="Lecture4-notes.html#6311" data-type="(x : X) (p : x ≡ x) → ap (S1-rec x p) loop ≡ p" class="Postulate">S1-rec-loop</a> <a id="4400" class="Symbol">_</a> <a id="4402" class="Symbol">_))))))</a>

<a id="circles-to-torus-nofunext"></a><a id="4411" href="Solutions5-dan.html#4411" data-type="S1 → S1 → Torus" class="Function">circles-to-torus-nofunext</a> <a id="4437" class="Symbol">:</a> <a id="4439" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="4442" class="Symbol">→</a> <a id="4444" class="Symbol">(</a><a id="4445" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="4448" class="Symbol">→</a> <a id="4450" href="Lecture4-notes.html#10700" data-type="Set" class="Postulate">Torus</a><a id="4455" class="Symbol">)</a>
<a id="4457" href="Solutions5-dan.html#4411" data-type="S1 → S1 → Torus" class="Function">circles-to-torus-nofunext</a> <a id="4483" href="Solutions5-dan.html#4483" class="Bound">x</a> <a id="4485" href="Solutions5-dan.html#4485" class="Bound">y</a> <a id="4487" class="Symbol">=</a> <a id="4489" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="4496" class="Symbol">(</a><a id="4497" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="4504" href="Lecture4-notes.html#10715" data-type="Torus" class="Postulate">baseT</a> <a id="4510" href="Lecture4-notes.html#10752" data-type="baseT ≡ baseT" class="Postulate">qT</a> <a id="4513" href="Solutions5-dan.html#4485" class="Bound">y</a><a id="4514" class="Symbol">)</a>
                                       <a id="4555" class="Symbol">(</a> <a id="4557" class="Symbol">(</a><a id="4558" href="Lecture5-notes.html#8628" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="4566" class="Symbol">(\</a> <a id="4569" href="Solutions5-dan.html#4569" class="Bound">y</a> <a id="4571" class="Symbol">→</a> <a id="4573" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="4580" href="Lecture4-notes.html#10715" data-type="Torus" class="Postulate">baseT</a> <a id="4586" href="Lecture4-notes.html#10752" data-type="baseT ≡ baseT" class="Postulate">qT</a> <a id="4589" href="Solutions5-dan.html#4569" class="Bound">y</a> <a id="4591" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="4593" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="4600" href="Lecture4-notes.html#10715" data-type="Torus" class="Postulate">baseT</a> <a id="4606" href="Lecture4-notes.html#10752" data-type="baseT ≡ baseT" class="Postulate">qT</a> <a id="4609" href="Solutions5-dan.html#4569" class="Bound">y</a><a id="4610" class="Symbol">)</a>
                                            <a id="4656" href="Lecture4-notes.html#10731" data-type="baseT ≡ baseT" class="Postulate">pT</a>
                                            <a id="4703" class="Symbol">(</a><a id="4704" href="Solutions5-dan.html#3611" data-type="q ∙ ap g p ≡ ap f p ∙ r → PathOver (λ x → f x ≡ g x) p q r" class="Function">PathOver-path≡</a> <a id="4719" class="Symbol">(</a><a id="4720" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="4723" class="Symbol">(\</a> <a id="4726" href="Solutions5-dan.html#4726" class="Bound">H</a> <a id="4728" class="Symbol">→</a> <a id="4730" href="Lecture4-notes.html#10731" data-type="baseT ≡ baseT" class="Postulate">pT</a> <a id="4733" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4735" href="Solutions5-dan.html#4726" class="Bound">H</a><a id="4736" class="Symbol">)</a> <a id="4738" class="Symbol">(</a><a id="4739" href="Lecture4-notes.html#6311" data-type="(x : X) (p : x ≡ x) → ap (S1-rec x p) loop ≡ p" class="Postulate">S1-rec-loop</a> <a id="4751" class="Symbol">_</a> <a id="4753" class="Symbol">_)</a> <a id="4756" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                             <a id="4819" href="Lecture4-notes.html#10773" data-type="pT ∙ qT ≡ qT ∙ pT" class="Postulate">sT</a> <a id="4822" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                             <a id="4885" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="4888" class="Symbol">(\</a> <a id="4891" href="Solutions5-dan.html#4891" class="Bound">H</a> <a id="4893" class="Symbol">→</a> <a id="4895" href="Solutions5-dan.html#4891" class="Bound">H</a> <a id="4897" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="4899" href="Lecture4-notes.html#10731" data-type="baseT ≡ baseT" class="Postulate">pT</a><a id="4901" class="Symbol">)</a> <a id="4903" class="Symbol">(</a><a id="4904" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="4906" class="Symbol">(</a><a id="4907" href="Lecture4-notes.html#6311" data-type="(x : X) (p : x ≡ x) → ap (S1-rec x p) loop ≡ p" class="Postulate">S1-rec-loop</a> <a id="4919" class="Symbol">_</a> <a id="4921" class="Symbol">_)))))</a> <a id="4928" href="Solutions5-dan.html#4485" class="Bound">y</a> <a id="4930" class="Symbol">)</a>
                                       <a id="4971" href="Solutions5-dan.html#4483" class="Bound">x</a>

<a id="circles-to-torus&#39;"></a><a id="4974" href="Solutions5-dan.html#4974" data-type="S1 × S1 → Torus" class="Function">circles-to-torus&#39;</a> <a id="4992" class="Symbol">:</a> <a id="4994" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="4997" href="new-prelude.html#2217" data-type="Set l1 → Set l2 → Set (l1 ⊔ l2)" class="Function Operator">×</a> <a id="4999" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a> <a id="5002" class="Symbol">→</a> <a id="5004" href="Lecture4-notes.html#10700" data-type="Set" class="Postulate">Torus</a>
<a id="5010" href="Solutions5-dan.html#4974" data-type="S1 × S1 → Torus" class="Function">circles-to-torus&#39;</a> <a id="5028" class="Symbol">(</a><a id="5029" href="Solutions5-dan.html#5029" class="Bound">x</a> <a id="5031" href="new-prelude.html#1801" data-type="(pr₁ : A) (pr₂ : B pr₁) → Σ B" class="InductiveConstructor Operator">,</a> <a id="5033" href="Solutions5-dan.html#5033" class="Bound">y</a><a id="5034" class="Symbol">)</a> <a id="5036" class="Symbol">=</a> <a id="5038" href="Solutions5-dan.html#3991" data-type="S1 → S1 → Torus" class="Function">circles-to-torus</a> <a id="5055" href="Solutions5-dan.html#5029" class="Bound">x</a> <a id="5057" href="Solutions5-dan.html#5033" class="Bound">y</a>
</pre>
<p><strong>Below are some “extra credit” exercises if you want more to
do. These are (even more) optional: nothing in the next lecture will
depend on you understanding them. The next section (H space) is harder
code but uses only the circle, whereas the following sections are a bit
easier code but require understanding the suspension type, which we
haven’t talked about too much yet.</strong></p>
<h1 id="h-space">H space</h1>
<p>The multiplication operation on the circle discussed in lecture is
part of what is called an “H space” structure on the circle. One part of
this structure is that the circle’s basepoint is a unit element for
multiplication.</p>
(⋆) Show that base is a left unit.
<pre class="Agda"><a id="mult-unit-l"></a><a id="5727" href="Solutions5-dan.html#5727" data-type="(y : S1) → mult base y ≡ y" class="Function">mult-unit-l</a> <a id="5739" class="Symbol">:</a> <a id="5741" class="Symbol">(</a><a id="5742" href="Solutions5-dan.html#5742" class="Bound">y</a> <a id="5744" class="Symbol">:</a> <a id="5746" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a><a id="5748" class="Symbol">)</a> <a id="5750" class="Symbol">→</a> <a id="5752" href="Lecture5-notes.html#9770" data-type="S1 → S1 → S1" class="Function">mult</a> <a id="5757" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a> <a id="5762" href="Solutions5-dan.html#5742" class="Bound">y</a> <a id="5764" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="5766" href="Solutions5-dan.html#5742" class="Bound">y</a>
<a id="5768" href="Solutions5-dan.html#5727" data-type="(y : S1) → mult base y ≡ y" class="Function">mult-unit-l</a> <a id="5780" href="Solutions5-dan.html#5780" class="Bound">y</a> <a id="5782" class="Symbol">=</a> <a id="5784" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="5789" class="Symbol">_</a>
</pre>
(⋆) Because we’ll need it in a second, show that ap distributes over
function composition:
<pre class="Agda"><a id="ap-∘"></a><a id="5895" href="Solutions5-dan.html#5895" data-type="(f : A → B) (g : B → C) (p : a ≡ a&#39;) → ap (g ∘ f) p ≡ ap g (ap f p)" class="Function">ap-∘</a> <a id="5900" class="Symbol">:</a> <a id="5902" class="Symbol">∀</a> <a id="5904" class="Symbol">{</a><a id="5905" href="Solutions5-dan.html#5905" class="Bound">l1</a> <a id="5908" href="Solutions5-dan.html#5908" class="Bound">l2</a> <a id="5911" href="Solutions5-dan.html#5911" class="Bound">l3</a> <a id="5914" class="Symbol">:</a> <a id="5916" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="5921" class="Symbol">}</a> <a id="5923" class="Symbol">{</a><a id="5924" href="Solutions5-dan.html#5924" class="Bound">A</a> <a id="5926" class="Symbol">:</a> <a id="5928" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="5933" href="Solutions5-dan.html#5905" class="Bound">l1</a><a id="5935" class="Symbol">}</a> <a id="5937" class="Symbol">{</a><a id="5938" href="Solutions5-dan.html#5938" class="Bound">B</a> <a id="5940" class="Symbol">:</a> <a id="5942" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="5947" href="Solutions5-dan.html#5908" class="Bound">l2</a><a id="5949" class="Symbol">}</a> <a id="5951" class="Symbol">{</a><a id="5952" href="Solutions5-dan.html#5952" class="Bound">C</a> <a id="5954" class="Symbol">:</a> <a id="5956" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="5961" href="Solutions5-dan.html#5911" class="Bound">l3</a><a id="5963" class="Symbol">}</a>
       <a id="5972" class="Symbol">(</a><a id="5973" href="Solutions5-dan.html#5973" class="Bound">f</a> <a id="5975" class="Symbol">:</a> <a id="5977" href="Solutions5-dan.html#5924" class="Bound">A</a> <a id="5979" class="Symbol">→</a> <a id="5981" href="Solutions5-dan.html#5938" class="Bound">B</a><a id="5982" class="Symbol">)</a> <a id="5984" class="Symbol">(</a><a id="5985" href="Solutions5-dan.html#5985" class="Bound">g</a> <a id="5987" class="Symbol">:</a> <a id="5989" href="Solutions5-dan.html#5938" class="Bound">B</a> <a id="5991" class="Symbol">→</a> <a id="5993" href="Solutions5-dan.html#5952" class="Bound">C</a><a id="5994" class="Symbol">)</a>
       <a id="6003" class="Symbol">{</a><a id="6004" href="Solutions5-dan.html#6004" class="Bound">a</a> <a id="6006" href="Solutions5-dan.html#6006" class="Bound">a&#39;</a> <a id="6009" class="Symbol">:</a> <a id="6011" href="Solutions5-dan.html#5924" class="Bound">A</a><a id="6012" class="Symbol">}</a>
       <a id="6021" class="Symbol">(</a><a id="6022" href="Solutions5-dan.html#6022" class="Bound">p</a> <a id="6024" class="Symbol">:</a> <a id="6026" href="Solutions5-dan.html#6004" class="Bound">a</a> <a id="6028" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6030" href="Solutions5-dan.html#6006" class="Bound">a&#39;</a><a id="6032" class="Symbol">)</a>
     <a id="6039" class="Symbol">→</a> <a id="6041" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="6044" class="Symbol">(</a><a id="6045" href="Solutions5-dan.html#5985" class="Bound">g</a> <a id="6047" href="new-prelude.html#2059" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="6049" href="Solutions5-dan.html#5973" class="Bound">f</a><a id="6050" class="Symbol">)</a> <a id="6052" href="Solutions5-dan.html#6022" class="Bound">p</a> <a id="6054" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6056" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="6059" href="Solutions5-dan.html#5985" class="Bound">g</a> <a id="6061" class="Symbol">(</a><a id="6062" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="6065" href="Solutions5-dan.html#5973" class="Bound">f</a> <a id="6067" href="Solutions5-dan.html#6022" class="Bound">p</a><a id="6068" class="Symbol">)</a>
<a id="6070" href="Solutions5-dan.html#5895" data-type="(f : A → B) (g : B → C) (p : a ≡ a&#39;) → ap (g ∘ f) p ≡ ap g (ap f p)" class="Function">ap-∘</a> <a id="6075" class="Symbol">_</a> <a id="6077" class="Symbol">_</a> <a id="6079" class="Symbol">(</a><a id="6080" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="6085" class="Symbol">_)</a> <a id="6088" class="Symbol">=</a> <a id="6090" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="6095" class="Symbol">_</a>
</pre>
<p>(⋆⋆) Suppose we have a curried function f : S1 → A → B. Under the
equivalence between paths in S1 × A and pairs of paths discussed in
Lecture 3, we can then “apply” (the uncurried version of) f to a pair of
paths (p : x ≡ y [ S1 ] , q : z ≡ w [ A ]) to get a path (f x z ≡ f y w
[ B ]). In the special case where q is reflexivity on a, this
application to p and q can be simplified to ap ( x → f x a) p : f x a ≡
f y a [ B ].</p>
Now, suppose that f is defined by circle recursion. We would expect some
kind of reduction for applying f to the pair of paths (loop , q) —
i.e. we should have reductions for <em>nested</em> pattern matching on
HITs. In the case where q is reflexivity, applying f to the pair (loop ,
refl) can reduce like this:
<pre class="Agda"><a id="S1-rec-loop-1"></a><a id="6848" href="Solutions5-dan.html#6848" data-type="ap (λ x → S1-rec f h x a) loop ≡ app≡ h a" class="Function">S1-rec-loop-1</a> <a id="6862" class="Symbol">:</a> <a id="6864" class="Symbol">∀</a> <a id="6866" class="Symbol">{</a><a id="6867" href="Solutions5-dan.html#6867" class="Bound">A</a> <a id="6869" href="Solutions5-dan.html#6869" class="Bound">B</a> <a id="6871" class="Symbol">:</a> <a id="6873" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="6877" class="Symbol">}</a> <a id="6879" class="Symbol">{</a><a id="6880" href="Solutions5-dan.html#6880" class="Bound">f</a> <a id="6882" class="Symbol">:</a> <a id="6884" href="Solutions5-dan.html#6867" class="Bound">A</a> <a id="6886" class="Symbol">→</a> <a id="6888" href="Solutions5-dan.html#6869" class="Bound">B</a><a id="6889" class="Symbol">}</a> <a id="6891" class="Symbol">{</a><a id="6892" href="Solutions5-dan.html#6892" class="Bound">h</a> <a id="6894" class="Symbol">:</a> <a id="6896" href="Solutions5-dan.html#6880" class="Bound">f</a> <a id="6898" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6900" href="Solutions5-dan.html#6880" class="Bound">f</a><a id="6901" class="Symbol">}</a> <a id="6903" class="Symbol">{</a><a id="6904" href="Solutions5-dan.html#6904" class="Bound">a</a> <a id="6906" class="Symbol">:</a> <a id="6908" href="Solutions5-dan.html#6867" class="Bound">A</a><a id="6909" class="Symbol">}</a>
                     <a id="6932" class="Symbol">→</a>  <a id="6935" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="6938" class="Symbol">(\</a> <a id="6941" href="Solutions5-dan.html#6941" class="Bound">x</a> <a id="6943" class="Symbol">→</a> <a id="6945" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="6952" href="Solutions5-dan.html#6880" class="Bound">f</a> <a id="6954" href="Solutions5-dan.html#6892" class="Bound">h</a> <a id="6956" href="Solutions5-dan.html#6941" class="Bound">x</a> <a id="6958" href="Solutions5-dan.html#6904" class="Bound">a</a><a id="6959" class="Symbol">)</a> <a id="6961" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a> <a id="6966" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="6968" href="Lecture5-notes.html#10539" data-type="f ≡ g → f ∼ g" class="Function">app≡</a> <a id="6973" href="Solutions5-dan.html#6892" class="Bound">h</a> <a id="6975" href="Solutions5-dan.html#6904" class="Bound">a</a>
<a id="6977" href="Solutions5-dan.html#6848" data-type="ap (λ x → S1-rec f h x a) loop ≡ app≡ h a" class="Function">S1-rec-loop-1</a> <a id="6991" class="Symbol">{</a><a id="6992" class="Argument">f</a> <a id="6994" class="Symbol">=</a> <a id="6996" href="Solutions5-dan.html#6996" class="Bound">f</a><a id="6997" class="Symbol">}{</a><a id="6999" href="Solutions5-dan.html#6999" class="Bound">h</a><a id="7000" class="Symbol">}{</a><a id="7002" href="Solutions5-dan.html#7002" class="Bound">a</a><a id="7003" class="Symbol">}</a> <a id="7005" class="Symbol">=</a> <a id="7007" class="Symbol">(</a><a id="7008" href="Solutions5-dan.html#5895" data-type="(f : A → B) (g : B → C) (p : a ≡ a&#39;) → ap (g ∘ f) p ≡ ap g (ap f p)" class="Function">ap-∘</a> <a id="7013" class="Symbol">(</a><a id="7014" href="Lecture4-notes.html#5544" data-type="(x : X) → x ≡ x → S1 → X" class="Postulate">S1-rec</a> <a id="7021" href="Solutions5-dan.html#6996" class="Bound">f</a> <a id="7023" href="Solutions5-dan.html#6999" class="Bound">h</a><a id="7024" class="Symbol">)</a> <a id="7026" class="Symbol">(\</a> <a id="7029" href="Solutions5-dan.html#7029" class="Bound">z</a> <a id="7031" class="Symbol">→</a> <a id="7033" href="Solutions5-dan.html#7029" class="Bound">z</a> <a id="7035" href="Solutions5-dan.html#7002" class="Bound">a</a><a id="7036" class="Symbol">)</a> <a id="7038" href="Lecture4-notes.html#769" data-type="base ≡ base" class="Postulate">loop</a><a id="7042" class="Symbol">)</a> <a id="7044" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7046" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7049" class="Symbol">(</a><a id="7050" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7053" class="Symbol">(\</a> <a id="7056" href="Solutions5-dan.html#7056" class="Bound">z</a> <a id="7058" class="Symbol">→</a> <a id="7060" href="Solutions5-dan.html#7056" class="Bound">z</a> <a id="7062" href="Solutions5-dan.html#7002" class="Bound">a</a><a id="7063" class="Symbol">))</a> <a id="7066" class="Symbol">(</a><a id="7067" href="Lecture4-notes.html#6311" data-type="(x : X) (p : x ≡ x) → ap (S1-rec x p) loop ≡ p" class="Postulate">S1-rec-loop</a> <a id="7079" class="Symbol">_</a> <a id="7081" class="Symbol">_)</a>
</pre>
<p>Prove this reduction using ap-∘ and the reduction rule for S1-rec on
the loop.</p>
<p>(⋆⋆⋆) Show that base is a right unit for multiplication. You will
need a slightly different path-over lemma than before.</p>
<pre class="Agda"><a id="PathOver-endo≡"></a><a id="7301" href="Solutions5-dan.html#7301" data-type="! q ∙ (ap f p ∙ r) ≡ p → PathOver (λ x → f x ≡ x) p q r" class="Function">PathOver-endo≡</a> <a id="7316" class="Symbol">:</a> <a id="7318" class="Symbol">∀</a> <a id="7320" class="Symbol">{</a><a id="7321" href="Solutions5-dan.html#7321" class="Bound">A</a> <a id="7323" class="Symbol">:</a> <a id="7325" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="7329" class="Symbol">}</a> <a id="7331" class="Symbol">{</a><a id="7332" href="Solutions5-dan.html#7332" class="Bound">f</a> <a id="7334" class="Symbol">:</a> <a id="7336" href="Solutions5-dan.html#7321" class="Bound">A</a> <a id="7338" class="Symbol">→</a> <a id="7340" href="Solutions5-dan.html#7321" class="Bound">A</a><a id="7341" class="Symbol">}</a>
                 <a id="7360" class="Symbol">{</a><a id="7361" href="Solutions5-dan.html#7361" class="Bound">a</a> <a id="7363" href="Solutions5-dan.html#7363" class="Bound">a&#39;</a> <a id="7366" class="Symbol">:</a> <a id="7368" href="Solutions5-dan.html#7321" class="Bound">A</a><a id="7369" class="Symbol">}</a> <a id="7371" class="Symbol">{</a><a id="7372" href="Solutions5-dan.html#7372" class="Bound">p</a> <a id="7374" class="Symbol">:</a> <a id="7376" href="Solutions5-dan.html#7361" class="Bound">a</a> <a id="7378" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7380" href="Solutions5-dan.html#7363" class="Bound">a&#39;</a><a id="7382" class="Symbol">}</a>
                 <a id="7401" class="Symbol">{</a><a id="7402" href="Solutions5-dan.html#7402" class="Bound">q</a> <a id="7404" class="Symbol">:</a> <a id="7406" class="Symbol">(</a><a id="7407" href="Solutions5-dan.html#7332" class="Bound">f</a> <a id="7409" href="Solutions5-dan.html#7361" class="Bound">a</a><a id="7410" class="Symbol">)</a> <a id="7412" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7414" href="Solutions5-dan.html#7361" class="Bound">a</a><a id="7415" class="Symbol">}</a>
                 <a id="7434" class="Symbol">{</a><a id="7435" href="Solutions5-dan.html#7435" class="Bound">r</a> <a id="7437" class="Symbol">:</a> <a id="7439" class="Symbol">(</a><a id="7440" href="Solutions5-dan.html#7332" class="Bound">f</a> <a id="7442" href="Solutions5-dan.html#7363" class="Bound">a&#39;</a><a id="7444" class="Symbol">)</a> <a id="7446" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7448" href="Solutions5-dan.html#7363" class="Bound">a&#39;</a><a id="7450" class="Symbol">}</a>
               <a id="7467" class="Symbol">→</a> <a id="7469" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="7471" href="Solutions5-dan.html#7402" class="Bound">q</a> <a id="7473" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7475" class="Symbol">((</a><a id="7477" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7480" href="Solutions5-dan.html#7332" class="Bound">f</a> <a id="7482" href="Solutions5-dan.html#7372" class="Bound">p</a><a id="7483" class="Symbol">)</a> <a id="7485" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7487" href="Solutions5-dan.html#7435" class="Bound">r</a><a id="7488" class="Symbol">)</a> <a id="7490" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7492" href="Solutions5-dan.html#7372" class="Bound">p</a>
               <a id="7509" class="Symbol">→</a> <a id="7511" href="Solutions5-dan.html#7402" class="Bound">q</a> <a id="7513" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="7515" href="Solutions5-dan.html#7435" class="Bound">r</a> <a id="7517" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="7519" class="Symbol">(\</a> <a id="7522" href="Solutions5-dan.html#7522" class="Bound">x</a> <a id="7524" class="Symbol">→</a> <a id="7526" href="Solutions5-dan.html#7332" class="Bound">f</a> <a id="7528" href="Solutions5-dan.html#7522" class="Bound">x</a> <a id="7530" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7532" href="Solutions5-dan.html#7522" class="Bound">x</a><a id="7533" class="Symbol">)</a> <a id="7535" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="7537" href="Solutions5-dan.html#7372" class="Bound">p</a> <a id="7539" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a>
<a id="7541" href="Solutions5-dan.html#7301" data-type="! q ∙ (ap f p ∙ r) ≡ p → PathOver (λ x → f x ≡ x) p q r" class="Function">PathOver-endo≡</a> <a id="7556" class="Symbol">{</a><a id="7557" class="Argument">p</a> <a id="7559" class="Symbol">=</a> <a id="7561" class="Symbol">(</a><a id="7562" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="7567" class="Symbol">_)}</a> <a id="7571" class="Symbol">{</a><a id="7572" class="Argument">q</a> <a id="7574" class="Symbol">=</a> <a id="7576" href="Solutions5-dan.html#7576" class="Bound">q</a><a id="7577" class="Symbol">}</a> <a id="7579" class="Symbol">{</a><a id="7580" href="Solutions5-dan.html#7580" class="Bound">r</a><a id="7581" class="Symbol">}</a> <a id="7583" href="Solutions5-dan.html#7583" class="Bound">h</a> <a id="7585" class="Symbol">=</a>
  <a id="7589" href="Lecture5-notes.html#4578" data-type="x ≡ y → PathOver B (refl a) x y" class="Function">path-to-pathover</a> <a id="7606" class="Symbol">(</a><a id="7607" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7610" class="Symbol">(\</a> <a id="7613" href="Solutions5-dan.html#7613" class="Bound">H</a> <a id="7615" class="Symbol">→</a> <a id="7617" href="Solutions5-dan.html#7576" class="Bound">q</a> <a id="7619" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7621" href="Solutions5-dan.html#7613" class="Bound">H</a><a id="7622" class="Symbol">)</a> <a id="7624" class="Symbol">(</a><a id="7625" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="7627" href="Solutions5-dan.html#7583" class="Bound">h</a><a id="7628" class="Symbol">)</a> <a id="7630" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                       <a id="7655" class="Symbol">(</a> <a id="7657" href="Lecture4-notes.html#2836" data-type="(p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → p ∙ (q ∙ r) ≡ p ∙ q ∙ r" class="Function">∙assoc</a> <a id="7664" class="Symbol">_</a> <a id="7666" class="Symbol">_</a> <a id="7668" class="Symbol">(</a><a id="7669" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="7674" class="Symbol">_</a> <a id="7676" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7678" href="Solutions5-dan.html#7580" class="Bound">r</a><a id="7679" class="Symbol">)</a> <a id="7681" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                        <a id="7707" class="Symbol">(</a><a id="7708" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="7711" class="Symbol">(\</a> <a id="7714" href="Solutions5-dan.html#7714" class="Bound">H</a> <a id="7716" class="Symbol">→</a> <a id="7718" href="Solutions5-dan.html#7714" class="Bound">H</a> <a id="7720" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7722" class="Symbol">(</a><a id="7723" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="7728" class="Symbol">_</a> <a id="7730" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7732" href="Solutions5-dan.html#7580" class="Bound">r</a><a id="7733" class="Symbol">))</a> <a id="7736" class="Symbol">(</a><a id="7737" href="Lecture4-notes.html#3074" data-type="(p : x ≡ y) → p ∙ ! p ≡ refl x" class="Function">!-inv-r</a> <a id="7745" href="Solutions5-dan.html#7576" class="Bound">q</a><a id="7746" class="Symbol">)</a> <a id="7748" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                         <a id="7775" class="Symbol">(</a><a id="7776" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="7784" class="Symbol">(</a><a id="7785" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="7790" class="Symbol">_</a> <a id="7792" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7794" href="Solutions5-dan.html#7580" class="Bound">r</a><a id="7795" class="Symbol">)</a> <a id="7797" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>  <a id="7800" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="7808" href="Solutions5-dan.html#7580" class="Bound">r</a> <a id="7810" class="Symbol">))</a> <a id="7813" class="Symbol">))</a>

<a id="mult-unit-r"></a><a id="7817" href="Solutions5-dan.html#7817" data-type="(x : S1) → mult x base ≡ x" class="Function">mult-unit-r</a> <a id="7829" class="Symbol">:</a> <a id="7831" class="Symbol">(</a><a id="7832" href="Solutions5-dan.html#7832" class="Bound">x</a> <a id="7834" class="Symbol">:</a> <a id="7836" href="Lecture4-notes.html#745" data-type="Set" class="Postulate">S1</a><a id="7838" class="Symbol">)</a> <a id="7840" class="Symbol">→</a> <a id="7842" href="Lecture5-notes.html#9770" data-type="S1 → S1 → S1" class="Function">mult</a> <a id="7847" href="Solutions5-dan.html#7832" class="Bound">x</a> <a id="7849" href="Lecture4-notes.html#757" data-type="S1" class="Postulate">base</a> <a id="7854" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="7856" href="Solutions5-dan.html#7832" class="Bound">x</a>
<a id="7858" href="Solutions5-dan.html#7817" data-type="(x : S1) → mult x base ≡ x" class="Function">mult-unit-r</a> <a id="7870" class="Symbol">=</a> <a id="7872" href="Lecture5-notes.html#8628" data-type="(X : S1 → Set) (x : X base) →
PathOver X loop x x → (x₁ : S1) → X x₁" class="Postulate">S1-elim</a> <a id="7880" class="Symbol">_</a>
                      <a id="7904" class="Symbol">(</a><a id="7905" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="7910" class="Symbol">_)</a>
                      <a id="7935" class="Symbol">(</a><a id="7936" href="Solutions5-dan.html#7301" data-type="! q ∙ (ap f p ∙ r) ≡ p → PathOver (λ x → f x ≡ x) p q r" class="Function">PathOver-endo≡</a>
                        <a id="7975" class="Symbol">((</a><a id="7977" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="7985" class="Symbol">_)</a> <a id="7988" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7990" class="Symbol">(</a><a id="7991" href="Solutions5-dan.html#6848" data-type="ap (λ x → S1-rec f h x a) loop ≡ app≡ h a" class="Function">S1-rec-loop-1</a> <a id="8005" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8007" class="Symbol">(</a> <a id="8009" href="Lecture5-notes.html#10846" data-type="(h : f ∼ g) → app≡ (λ≡ h) ∼ h" class="Function">λ≡β</a> <a id="8013" class="Symbol">_</a> <a id="8015" class="Symbol">_))</a> <a id="8019" class="Symbol">))</a>
</pre>
<h1 id="suspensions-and-the-2-point-circle">Suspensions and the 2-point
circle</h1>
(⋆) Postulate the computation rules for the non-dependent susp-rec and
declare rewrites for the point reduction rules on the point
constructors.<br />
<pre class="Agda"><a id="8220" class="Keyword">postulate</a>
  <a id="Susp-rec-north"></a><a id="8232" href="Solutions5-dan.html#8232" data-type="(n s : X) (m : A → n ≡ s) → Susp-rec n s m northS ≡ n" class="Postulate">Susp-rec-north</a> <a id="8247" class="Symbol">:</a> <a id="8249" class="Symbol">{</a><a id="8250" href="Solutions5-dan.html#8250" class="Bound">l</a> <a id="8252" class="Symbol">:</a> <a id="8254" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="8259" class="Symbol">}</a> <a id="8261" class="Symbol">{</a><a id="8262" href="Solutions5-dan.html#8262" class="Bound">A</a> <a id="8264" class="Symbol">:</a> <a id="8266" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="8270" class="Symbol">}</a> <a id="8272" class="Symbol">{</a><a id="8273" href="Solutions5-dan.html#8273" class="Bound">X</a> <a id="8275" class="Symbol">:</a> <a id="8277" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="8282" href="Solutions5-dan.html#8250" class="Bound">l</a><a id="8283" class="Symbol">}</a>
                 <a id="8302" class="Symbol">(</a><a id="8303" href="Solutions5-dan.html#8303" class="Bound">n</a> <a id="8305" class="Symbol">:</a> <a id="8307" href="Solutions5-dan.html#8273" class="Bound">X</a><a id="8308" class="Symbol">)</a> <a id="8310" class="Symbol">(</a><a id="8311" href="Solutions5-dan.html#8311" class="Bound">s</a> <a id="8313" class="Symbol">:</a> <a id="8315" href="Solutions5-dan.html#8273" class="Bound">X</a><a id="8316" class="Symbol">)</a> <a id="8318" class="Symbol">(</a><a id="8319" href="Solutions5-dan.html#8319" class="Bound">m</a> <a id="8321" class="Symbol">:</a> <a id="8323" href="Solutions5-dan.html#8262" class="Bound">A</a> <a id="8325" class="Symbol">→</a> <a id="8327" href="Solutions5-dan.html#8303" class="Bound">n</a> <a id="8329" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="8331" href="Solutions5-dan.html#8311" class="Bound">s</a><a id="8332" class="Symbol">)</a>
                 <a id="8351" class="Symbol">→</a> <a id="8353" href="Lecture4-notes.html#11753" data-type="(n s : X) → (A → n ≡ s) → Susp A → X" class="Postulate">Susp-rec</a> <a id="8362" href="Solutions5-dan.html#8303" class="Bound">n</a> <a id="8364" href="Solutions5-dan.html#8311" class="Bound">s</a> <a id="8366" href="Solutions5-dan.html#8319" class="Bound">m</a> <a id="8368" href="Lecture4-notes.html#11636" data-type="Susp A" class="Postulate">northS</a> <a id="8375" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="8377" href="Solutions5-dan.html#8303" class="Bound">n</a>
  <a id="Susp-rec-south"></a><a id="8381" href="Solutions5-dan.html#8381" data-type="(n s : X) (m : A → n ≡ s) → Susp-rec n s m southS ≡ s" class="Postulate">Susp-rec-south</a> <a id="8396" class="Symbol">:</a> <a id="8398" class="Symbol">{</a><a id="8399" href="Solutions5-dan.html#8399" class="Bound">l</a> <a id="8401" class="Symbol">:</a> <a id="8403" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="8408" class="Symbol">}</a> <a id="8410" class="Symbol">{</a><a id="8411" href="Solutions5-dan.html#8411" class="Bound">A</a> <a id="8413" class="Symbol">:</a> <a id="8415" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="8419" class="Symbol">}</a> <a id="8421" class="Symbol">{</a><a id="8422" href="Solutions5-dan.html#8422" class="Bound">X</a> <a id="8424" class="Symbol">:</a> <a id="8426" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="8431" href="Solutions5-dan.html#8399" class="Bound">l</a><a id="8432" class="Symbol">}</a>
                   <a id="8453" class="Symbol">(</a><a id="8454" href="Solutions5-dan.html#8454" class="Bound">n</a> <a id="8456" class="Symbol">:</a> <a id="8458" href="Solutions5-dan.html#8422" class="Bound">X</a><a id="8459" class="Symbol">)</a> <a id="8461" class="Symbol">(</a><a id="8462" href="Solutions5-dan.html#8462" class="Bound">s</a> <a id="8464" class="Symbol">:</a> <a id="8466" href="Solutions5-dan.html#8422" class="Bound">X</a><a id="8467" class="Symbol">)</a> <a id="8469" class="Symbol">(</a><a id="8470" href="Solutions5-dan.html#8470" class="Bound">m</a> <a id="8472" class="Symbol">:</a> <a id="8474" href="Solutions5-dan.html#8411" class="Bound">A</a> <a id="8476" class="Symbol">→</a> <a id="8478" href="Solutions5-dan.html#8454" class="Bound">n</a> <a id="8480" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="8482" href="Solutions5-dan.html#8462" class="Bound">s</a><a id="8483" class="Symbol">)</a>
                   <a id="8504" class="Symbol">→</a> <a id="8506" href="Lecture4-notes.html#11753" data-type="(n s : X) → (A → n ≡ s) → Susp A → X" class="Postulate">Susp-rec</a> <a id="8515" href="Solutions5-dan.html#8454" class="Bound">n</a> <a id="8517" href="Solutions5-dan.html#8462" class="Bound">s</a> <a id="8519" href="Solutions5-dan.html#8470" class="Bound">m</a> <a id="8521" href="Lecture4-notes.html#11667" data-type="Susp A" class="Postulate">southS</a> <a id="8528" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="8530" href="Solutions5-dan.html#8462" class="Bound">s</a>
<a id="8532" class="Symbol">{-#</a> <a id="8536" class="Keyword">REWRITE</a> <a id="8544" href="Solutions5-dan.html#8232" data-type="(n s : X) (m : A → n ≡ s) → Susp-rec n s m northS ≡ n" class="Postulate">Susp-rec-north</a> <a id="8559" class="Symbol">#-}</a>
<a id="8563" class="Symbol">{-#</a> <a id="8567" class="Keyword">REWRITE</a> <a id="8575" href="Solutions5-dan.html#8381" data-type="(n s : X) (m : A → n ≡ s) → Susp-rec n s m southS ≡ s" class="Postulate">Susp-rec-south</a> <a id="8590" class="Symbol">#-}</a>
<a id="8594" class="Keyword">postulate</a>
  <a id="Susp-rec-merid"></a><a id="8606" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="8621" class="Symbol">:</a> <a id="8623" class="Symbol">{</a><a id="8624" href="Solutions5-dan.html#8624" class="Bound">l</a> <a id="8626" class="Symbol">:</a> <a id="8628" href="Agda.Primitive.html#597" data-type="Set" class="Postulate">Level</a><a id="8633" class="Symbol">}</a> <a id="8635" class="Symbol">{</a><a id="8636" href="Solutions5-dan.html#8636" class="Bound">A</a> <a id="8638" class="Symbol">:</a> <a id="8640" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="8644" class="Symbol">}</a> <a id="8646" class="Symbol">{</a><a id="8647" href="Solutions5-dan.html#8647" class="Bound">X</a> <a id="8649" class="Symbol">:</a> <a id="8651" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="8656" href="Solutions5-dan.html#8624" class="Bound">l</a><a id="8657" class="Symbol">}</a>
                   <a id="8678" class="Symbol">(</a><a id="8679" href="Solutions5-dan.html#8679" class="Bound">n</a> <a id="8681" class="Symbol">:</a> <a id="8683" href="Solutions5-dan.html#8647" class="Bound">X</a><a id="8684" class="Symbol">)</a> <a id="8686" class="Symbol">(</a><a id="8687" href="Solutions5-dan.html#8687" class="Bound">s</a> <a id="8689" class="Symbol">:</a> <a id="8691" href="Solutions5-dan.html#8647" class="Bound">X</a><a id="8692" class="Symbol">)</a> <a id="8694" class="Symbol">(</a><a id="8695" href="Solutions5-dan.html#8695" class="Bound">m</a> <a id="8697" class="Symbol">:</a> <a id="8699" href="Solutions5-dan.html#8636" class="Bound">A</a> <a id="8701" class="Symbol">→</a> <a id="8703" href="Solutions5-dan.html#8679" class="Bound">n</a> <a id="8705" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="8707" href="Solutions5-dan.html#8687" class="Bound">s</a><a id="8708" class="Symbol">)</a>
                 <a id="8727" class="Symbol">→</a> <a id="8729" class="Symbol">(</a><a id="8730" href="Solutions5-dan.html#8730" class="Bound">x</a> <a id="8732" class="Symbol">:</a> <a id="8734" href="Solutions5-dan.html#8636" class="Bound">A</a><a id="8735" class="Symbol">)</a> <a id="8737" class="Symbol">→</a> <a id="8739" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="8742" class="Symbol">(</a><a id="8743" href="Lecture4-notes.html#11753" data-type="(n s : X) → (A → n ≡ s) → Susp A → X" class="Postulate">Susp-rec</a> <a id="8752" href="Solutions5-dan.html#8679" class="Bound">n</a> <a id="8754" href="Solutions5-dan.html#8687" class="Bound">s</a> <a id="8756" href="Solutions5-dan.html#8695" class="Bound">m</a><a id="8757" class="Symbol">)</a> <a id="8759" class="Symbol">(</a><a id="8760" href="Lecture4-notes.html#11698" data-type="A → Path (Susp A) northS southS" class="Postulate">merid</a> <a id="8766" href="Solutions5-dan.html#8730" class="Bound">x</a><a id="8767" class="Symbol">)</a> <a id="8769" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="8771" href="Solutions5-dan.html#8695" class="Bound">m</a> <a id="8773" href="Solutions5-dan.html#8730" class="Bound">x</a>
</pre>
<p>(⋆) Postulate the dependent elimination rule for suspensions:</p>
<pre class="Agda"><a id="8851" class="Keyword">postulate</a> 
  <a id="Susp-elim"></a><a id="8864" href="Solutions5-dan.html#8864" data-type="(P : Susp A → Set) (n : P northS) (s : P southS) →
((x : A) → PathOver P (merid x) n s) → (x : Susp A) → P x" class="Postulate">Susp-elim</a> <a id="8874" class="Symbol">:</a> <a id="8876" class="Symbol">{</a><a id="8877" href="Solutions5-dan.html#8877" class="Bound">A</a> <a id="8879" class="Symbol">:</a> <a id="8881" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="8885" class="Symbol">}</a> <a id="8887" class="Symbol">(</a><a id="8888" href="Solutions5-dan.html#8888" class="Bound">P</a> <a id="8890" class="Symbol">:</a> <a id="8892" href="Lecture4-notes.html#11615" data-type="Set → Set" class="Postulate">Susp</a> <a id="8897" href="Solutions5-dan.html#8877" class="Bound">A</a> <a id="8899" class="Symbol">→</a> <a id="8901" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="8905" class="Symbol">)</a>
            <a id="8919" class="Symbol">→</a> <a id="8921" class="Symbol">(</a><a id="8922" href="Solutions5-dan.html#8922" class="Bound">n</a> <a id="8924" class="Symbol">:</a> <a id="8926" href="Solutions5-dan.html#8888" class="Bound">P</a> <a id="8928" href="Lecture4-notes.html#11636" data-type="Susp A" class="Postulate">northS</a><a id="8934" class="Symbol">)</a>
            <a id="8948" class="Symbol">→</a> <a id="8950" class="Symbol">(</a><a id="8951" href="Solutions5-dan.html#8951" class="Bound">s</a> <a id="8953" class="Symbol">:</a> <a id="8955" href="Solutions5-dan.html#8888" class="Bound">P</a> <a id="8957" href="Lecture4-notes.html#11667" data-type="Susp A" class="Postulate">southS</a><a id="8963" class="Symbol">)</a>
            <a id="8977" class="Symbol">→</a> <a id="8979" class="Symbol">(</a><a id="8980" href="Solutions5-dan.html#8980" class="Bound">m</a> <a id="8982" class="Symbol">:</a> <a id="8984" class="Symbol">(</a><a id="8985" href="Solutions5-dan.html#8985" class="Bound">x</a> <a id="8987" class="Symbol">:</a> <a id="8989" href="Solutions5-dan.html#8877" class="Bound">A</a><a id="8990" class="Symbol">)</a> <a id="8992" class="Symbol">→</a> <a id="8994" href="Solutions5-dan.html#8922" class="Bound">n</a> <a id="8996" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">≡</a> <a id="8998" href="Solutions5-dan.html#8951" class="Bound">s</a> <a id="9000" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">[</a> <a id="9002" href="Solutions5-dan.html#8888" class="Bound">P</a> <a id="9004" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">↓</a> <a id="9006" href="Lecture4-notes.html#11698" data-type="A → Path (Susp A) northS southS" class="Postulate">merid</a> <a id="9012" href="Solutions5-dan.html#8985" class="Bound">x</a> <a id="9014" href="Lecture5-notes.html#3169" data-type="(B : A → Set l2) → a1 ≡ a2 → B a1 → B a2 → Set (l1 ⊔ l2)" class="Datatype">]</a><a id="9015" class="Symbol">)</a>
            <a id="9029" class="Symbol">→</a> <a id="9031" class="Symbol">(</a><a id="9032" href="Solutions5-dan.html#9032" class="Bound">x</a> <a id="9034" class="Symbol">:</a> <a id="9036" href="Lecture4-notes.html#11615" data-type="Set → Set" class="Postulate">Susp</a> <a id="9041" href="Solutions5-dan.html#8877" class="Bound">A</a><a id="9042" class="Symbol">)</a> <a id="9044" class="Symbol">→</a> <a id="9046" href="Solutions5-dan.html#8888" class="Bound">P</a> <a id="9048" href="Solutions5-dan.html#9032" class="Bound">x</a>
</pre>
<p>(⋆⋆) Show that the maps s2c and c2s from the Lecture 4 exercises are
mutually inverse:</p>
<pre class="Agda"><a id="c2s2c"></a><a id="9151" href="Solutions5-dan.html#9151" data-type="(x : Circle2) → s2c (c2s x) ≡ x" class="Function">c2s2c</a> <a id="9157" class="Symbol">:</a> <a id="9159" class="Symbol">(</a><a id="9160" href="Solutions5-dan.html#9160" class="Bound">x</a> <a id="9162" class="Symbol">:</a> <a id="9164" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a><a id="9171" class="Symbol">)</a> <a id="9173" class="Symbol">→</a> <a id="9175" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a> <a id="9179" class="Symbol">(</a><a id="9180" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a> <a id="9184" href="Solutions5-dan.html#9160" class="Bound">x</a><a id="9185" class="Symbol">)</a> <a id="9187" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9189" href="Solutions5-dan.html#9160" class="Bound">x</a>
<a id="9191" href="Solutions5-dan.html#9151" data-type="(x : Circle2) → s2c (c2s x) ≡ x" class="Function">c2s2c</a> <a id="9197" class="Symbol">=</a> <a id="9199" href="Lecture5-notes.html#5381" data-type="(X : Circle2 → Set) (n : X north) (s : X south) →
PathOver X west n s → PathOver X east n s → (x : Circle2) → X x" class="Postulate">Circle2-elim</a> <a id="9212" class="Symbol">_</a> <a id="9214" class="Symbol">(</a><a id="9215" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="9220" class="Symbol">_)</a> <a id="9223" class="Symbol">(</a><a id="9224" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="9229" class="Symbol">_)</a>
                    <a id="9252" class="Symbol">(</a><a id="9253" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
! q ∙ (ap g (ap f p) ∙ r) ≡ p → PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="9273" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a> <a id="9277" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a> <a id="9281" class="Symbol">_</a>
                     <a id="9304" class="Symbol">(</a><a id="9305" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="9313" class="Symbol">_</a> <a id="9315" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9317" class="Symbol">(</a><a id="9318" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="9321" class="Symbol">(</a><a id="9322" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="9325" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a><a id="9328" class="Symbol">)</a> <a id="9330" class="Symbol">(</a><a id="9331" href="Lecture4-notes.html#8400" data-type="(n s : X) (w e : n ≡ s) → ap (Circle2-rec n s w e) west ≡ w" class="Postulate">Circle2-rec-west</a> <a id="9348" class="Symbol">_</a> <a id="9350" class="Symbol">_</a> <a id="9352" class="Symbol">_</a> <a id="9354" class="Symbol">_)</a> <a id="9357" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9359" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="9374" class="Symbol">_</a> <a id="9376" class="Symbol">_</a> <a id="9378" class="Symbol">_</a> <a id="9380" class="Symbol">_)))</a>
                    <a id="9405" class="Symbol">(</a><a id="9406" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
! q ∙ (ap g (ap f p) ∙ r) ≡ p → PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="9426" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a> <a id="9430" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a> <a id="9434" class="Symbol">_</a>
                     <a id="9457" class="Symbol">(</a><a id="9458" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="9466" class="Symbol">_</a> <a id="9468" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9470" class="Symbol">(</a><a id="9471" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="9474" class="Symbol">(</a><a id="9475" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="9478" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a><a id="9481" class="Symbol">)</a> <a id="9483" class="Symbol">(</a><a id="9484" href="Lecture4-notes.html#8527" data-type="(n s : X) (w e : n ≡ s) → ap (Circle2-rec n s w e) east ≡ e" class="Postulate">Circle2-rec-east</a> <a id="9501" class="Symbol">_</a> <a id="9503" class="Symbol">_</a> <a id="9505" class="Symbol">_</a> <a id="9507" class="Symbol">_)</a> <a id="9510" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9512" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="9527" class="Symbol">_</a> <a id="9529" class="Symbol">_</a> <a id="9531" class="Symbol">_</a> <a id="9533" class="Symbol">_)))</a>

<a id="s2c2s"></a><a id="9539" href="Solutions5-dan.html#9539" data-type="(x : Susp Bool) → c2s (s2c x) ≡ x" class="Function">s2c2s</a> <a id="9545" class="Symbol">:</a> <a id="9547" class="Symbol">(</a><a id="9548" href="Solutions5-dan.html#9548" class="Bound">x</a> <a id="9550" class="Symbol">:</a> <a id="9552" href="Lecture4-notes.html#11615" data-type="Set → Set" class="Postulate">Susp</a> <a id="9557" href="new-prelude.html#3253" data-type="Set" class="Function">Bool</a><a id="9561" class="Symbol">)</a> <a id="9563" class="Symbol">→</a> <a id="9565" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a> <a id="9569" class="Symbol">(</a><a id="9570" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a> <a id="9574" href="Solutions5-dan.html#9548" class="Bound">x</a><a id="9575" class="Symbol">)</a> <a id="9577" href="new-prelude.html#449" data-type="A → A → Set l" class="Datatype Operator">≡</a> <a id="9579" href="Solutions5-dan.html#9548" class="Bound">x</a>
<a id="9581" href="Solutions5-dan.html#9539" data-type="(x : Susp Bool) → c2s (s2c x) ≡ x" class="Function">s2c2s</a> <a id="9587" class="Symbol">=</a> <a id="9589" href="Solutions5-dan.html#8864" data-type="(P : Susp A → Set) (n : P northS) (s : P southS) →
((x : A) → PathOver P (merid x) n s) → (x : Susp A) → P x" class="Postulate">Susp-elim</a> <a id="9599" class="Symbol">_</a> <a id="9601" class="Symbol">(</a><a id="9602" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="9607" class="Symbol">_)</a> <a id="9610" class="Symbol">(</a><a id="9611" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="9616" class="Symbol">_)</a> <a id="9619" class="Symbol">\</a> <a id="9621" class="Symbol">{</a> <a id="9623" href="new-prelude.html#3233" data-type="BoolL" class="InductiveConstructor">true</a> <a id="9628" class="Symbol">→</a> <a id="9630" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
! q ∙ (ap g (ap f p) ∙ r) ≡ p → PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="9650" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a> <a id="9654" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a> <a id="9658" class="Symbol">_</a>
                                                 <a id="9709" class="Symbol">(</a><a id="9710" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="9718" class="Symbol">_</a> <a id="9720" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                  <a id="9772" class="Symbol">(</a><a id="9773" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="9776" class="Symbol">(</a><a id="9777" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="9780" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a><a id="9783" class="Symbol">)</a> <a id="9785" class="Symbol">(</a><a id="9786" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="9801" class="Symbol">_</a> <a id="9803" class="Symbol">_</a> <a id="9805" class="Symbol">_</a> <a id="9807" class="Symbol">_)</a>
                                                  <a id="9860" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9862" href="Lecture4-notes.html#8400" data-type="(n s : X) (w e : n ≡ s) → ap (Circle2-rec n s w e) west ≡ w" class="Postulate">Circle2-rec-west</a> <a id="9879" class="Symbol">_</a> <a id="9881" class="Symbol">_</a> <a id="9883" class="Symbol">_</a> <a id="9885" class="Symbol">_))</a> <a id="9889" class="Symbol">;</a>
                                          <a id="9933" href="new-prelude.html#3238" data-type="BoolL" class="InductiveConstructor">false</a> <a id="9939" class="Symbol">→</a> <a id="9941" href="Lecture5-notes.html#7675" data-type="(g : B → A) (f : A → B) (p : a ≡ a&#39;) →
! q ∙ (ap g (ap f p) ∙ r) ≡ p → PathOver (λ x → g (f x) ≡ x) p q r" class="Function">PathOver-roundtrip≡</a> <a id="9961" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a> <a id="9965" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a> <a id="9969" class="Symbol">_</a>
                                                  <a id="10021" class="Symbol">(</a><a id="10022" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="10030" class="Symbol">_</a> <a id="10032" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                  <a id="10084" class="Symbol">(</a><a id="10085" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="10088" class="Symbol">(</a><a id="10089" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="10092" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a><a id="10095" class="Symbol">)</a> <a id="10097" class="Symbol">(</a><a id="10098" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="10113" class="Symbol">_</a> <a id="10115" class="Symbol">_</a> <a id="10117" class="Symbol">_</a> <a id="10119" class="Symbol">_)</a>
                                                  <a id="10172" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10174" href="Lecture4-notes.html#8527" data-type="(n s : X) (w e : n ≡ s) → ap (Circle2-rec n s w e) east ≡ e" class="Postulate">Circle2-rec-east</a> <a id="10191" class="Symbol">_</a> <a id="10193" class="Symbol">_</a> <a id="10195" class="Symbol">_</a> <a id="10197" class="Symbol">_))}</a>
</pre>
<p>(⋆) Conclude that Circle2 is equivalent to Susp Bool:</p>
<pre class="Agda"><a id="Circle2-Susp-Bool"></a><a id="10270" href="Solutions5-dan.html#10270" data-type="Circle2 ≃ Susp Bool" class="Function">Circle2-Susp-Bool</a> <a id="10288" class="Symbol">:</a> <a id="10290" href="Lecture4-notes.html#7873" data-type="Set" class="Postulate">Circle2</a> <a id="10298" href="Lecture5-notes.html#968" data-type="(A : Set l1) (B : Set l2) → Set (l1 ⊔ l2)" class="Record Operator">≃</a> <a id="10300" href="Lecture4-notes.html#11615" data-type="Set → Set" class="Postulate">Susp</a> <a id="10305" href="new-prelude.html#3253" data-type="Set" class="Function">Bool</a>
<a id="10310" href="Solutions5-dan.html#10270" data-type="Circle2 ≃ Susp Bool" class="Function">Circle2-Susp-Bool</a> <a id="10328" class="Symbol">=</a> <a id="10330" href="Lecture5-notes.html#1565" data-type="A ≅ B → A ≃ B" class="Function">improve</a> <a id="10338" class="Symbol">(</a><a id="10339" href="new-prelude.html#2950" data-type="(bijection : A → B) (bijectivity : is-bijection bijection) → A ≅ B" class="InductiveConstructor">Isomorphism</a> <a id="10351" href="Solutions4.html#4919" data-type="Circle2 → Susp Bool" class="Function">c2s</a> <a id="10355" class="Symbol">(</a><a id="10356" href="new-prelude.html#2765" data-type="(inverse : B → A) (η : (inverse ∘ f) ∼ id)
(ε : (f ∘ inverse) ∼ id) →
is-bijection f" class="InductiveConstructor">Inverse</a> <a id="10364" href="Solutions4.html#5005" data-type="Susp Bool → Circle2" class="Function">s2c</a> <a id="10368" href="Solutions5-dan.html#9151" data-type="(x : Circle2) → s2c (c2s x) ≡ x" class="Function">c2s2c</a> <a id="10374" href="Solutions5-dan.html#9539" data-type="(x : Susp Bool) → c2s (s2c x) ≡ x" class="Function">s2c2s</a><a id="10379" class="Symbol">))</a> 
</pre>
<h1 id="functoriality-of-suspension">Functoriality of suspension
(⋆⋆)</h1>
In the Lecture 4 exercises, we defined functoriality for the suspension
type, which given a function X → Y gives a function Σ X → Σ Y. Show that
this operation is functorial, meaning that it preserves identity and
composition of functions:
<pre class="Agda"><a id="susp-func-id"></a><a id="10673" href="Solutions5-dan.html#10673" data-type="susp-func id ∼ id" class="Function">susp-func-id</a> <a id="10686" class="Symbol">:</a> <a id="10688" class="Symbol">∀</a> <a id="10690" class="Symbol">{</a><a id="10691" href="Solutions5-dan.html#10691" class="Bound">X</a> <a id="10693" class="Symbol">:</a> <a id="10695" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="10699" class="Symbol">}</a> <a id="10701" class="Symbol">→</a> <a id="10703" href="Solutions4.html#5241" data-type="(X → Y) → Susp X → Susp Y" class="Function">susp-func</a> <a id="10713" class="Symbol">{</a><a id="10714" href="Solutions5-dan.html#10691" class="Bound">X</a><a id="10715" class="Symbol">}</a> <a id="10717" href="new-prelude.html#2011" data-type="A → A" class="Function">id</a> <a id="10720" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="10722" href="new-prelude.html#2011" data-type="A → A" class="Function">id</a>
<a id="10725" href="Solutions5-dan.html#10673" data-type="susp-func id ∼ id" class="Function">susp-func-id</a> <a id="10738" class="Symbol">=</a> <a id="10740" href="Solutions5-dan.html#8864" data-type="(P : Susp A → Set) (n : P northS) (s : P southS) →
((x : A) → PathOver P (merid x) n s) → (x : Susp A) → P x" class="Postulate">Susp-elim</a> <a id="10750" class="Symbol">_</a> <a id="10752" class="Symbol">(</a><a id="10753" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="10758" class="Symbol">_)</a>
                           <a id="10788" class="Symbol">(</a><a id="10789" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="10794" class="Symbol">_)</a>
                           <a id="10824" class="Symbol">(\</a><a id="10826" href="Solutions5-dan.html#10826" class="Bound">x</a> <a id="10828" class="Symbol">→</a> <a id="10830" href="Solutions5-dan.html#7301" data-type="! q ∙ (ap f p ∙ r) ≡ p → PathOver (λ x → f x ≡ x) p q r" class="Function">PathOver-endo≡</a> <a id="10845" class="Symbol">(</a><a id="10846" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="10854" class="Symbol">_</a> <a id="10856" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10858" class="Symbol">(</a><a id="10859" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="10874" class="Symbol">_</a> <a id="10876" class="Symbol">_</a> <a id="10878" class="Symbol">_</a> <a id="10880" class="Symbol">_))</a> <a id="10884" class="Symbol">)</a>

<a id="susp-func-∘"></a><a id="10887" href="Solutions5-dan.html#10887" data-type="(f : X → Y) (g : Y → Z) →
susp-func (g ∘ f) ∼ (susp-func g ∘ susp-func f)" class="Function">susp-func-∘</a> <a id="10899" class="Symbol">:</a> <a id="10901" class="Symbol">∀</a> <a id="10903" class="Symbol">{</a><a id="10904" href="Solutions5-dan.html#10904" class="Bound">X</a> <a id="10906" href="Solutions5-dan.html#10906" class="Bound">Y</a> <a id="10908" href="Solutions5-dan.html#10908" class="Bound">Z</a> <a id="10910" class="Symbol">:</a> <a id="10912" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="10916" class="Symbol">}</a> <a id="10918" class="Symbol">(</a><a id="10919" href="Solutions5-dan.html#10919" class="Bound">f</a> <a id="10921" class="Symbol">:</a> <a id="10923" href="Solutions5-dan.html#10904" class="Bound">X</a> <a id="10925" class="Symbol">→</a> <a id="10927" href="Solutions5-dan.html#10906" class="Bound">Y</a><a id="10928" class="Symbol">)</a> <a id="10930" class="Symbol">(</a><a id="10931" href="Solutions5-dan.html#10931" class="Bound">g</a> <a id="10933" class="Symbol">:</a> <a id="10935" href="Solutions5-dan.html#10906" class="Bound">Y</a> <a id="10937" class="Symbol">→</a> <a id="10939" href="Solutions5-dan.html#10908" class="Bound">Z</a><a id="10940" class="Symbol">)</a>
            <a id="10954" class="Symbol">→</a> <a id="10956" href="Solutions4.html#5241" data-type="(X → Y) → Susp X → Susp Y" class="Function">susp-func</a> <a id="10966" class="Symbol">{</a><a id="10967" href="Solutions5-dan.html#10904" class="Bound">X</a><a id="10968" class="Symbol">}</a> <a id="10970" class="Symbol">(</a><a id="10971" href="Solutions5-dan.html#10931" class="Bound">g</a> <a id="10973" href="new-prelude.html#2059" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="10975" href="Solutions5-dan.html#10919" class="Bound">f</a><a id="10976" class="Symbol">)</a> <a id="10978" href="new-prelude.html#1372" data-type="((x : A) → B x) → ((x : A) → B x) → Set (l1 ⊔ l2)" class="Function Operator">∼</a> <a id="10980" href="Solutions4.html#5241" data-type="(X → Y) → Susp X → Susp Y" class="Function">susp-func</a> <a id="10990" href="Solutions5-dan.html#10931" class="Bound">g</a> <a id="10992" href="new-prelude.html#2059" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="10994" href="Solutions4.html#5241" data-type="(X → Y) → Susp X → Susp Y" class="Function">susp-func</a> <a id="11004" href="Solutions5-dan.html#10919" class="Bound">f</a>
<a id="11006" href="Solutions5-dan.html#10887" data-type="(f : X → Y) (g : Y → Z) →
susp-func (g ∘ f) ∼ (susp-func g ∘ susp-func f)" class="Function">susp-func-∘</a> <a id="11018" href="Solutions5-dan.html#11018" class="Bound">f</a> <a id="11020" href="Solutions5-dan.html#11020" class="Bound">g</a> <a id="11022" class="Symbol">=</a> <a id="11024" href="Solutions5-dan.html#8864" data-type="(P : Susp A → Set) (n : P northS) (s : P southS) →
((x : A) → PathOver P (merid x) n s) → (x : Susp A) → P x" class="Postulate">Susp-elim</a> <a id="11034" class="Symbol">_</a>
                            <a id="11064" class="Symbol">(</a><a id="11065" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="11070" class="Symbol">_)</a>
                            <a id="11101" class="Symbol">(</a><a id="11102" href="new-prelude.html#502" data-type="(x : A) → x ≡ x" class="InductiveConstructor">refl</a> <a id="11107" class="Symbol">_)</a>
                            <a id="11138" class="Symbol">(\</a><a id="11140" href="Solutions5-dan.html#11140" class="Bound">x</a> <a id="11142" class="Symbol">→</a> <a id="11144" href="Solutions5-dan.html#3611" data-type="q ∙ ap g p ≡ ap f p ∙ r → PathOver (λ x → f x ≡ g x) p q r" class="Function">PathOver-path≡</a> <a id="11159" class="Symbol">(</a><a id="11160" href="Lecture4-notes.html#2745" data-type="(p : x ≡ y) → refl x ∙ p ≡ p" class="Function">∙unit-l</a> <a id="11168" class="Symbol">_</a> <a id="11170" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                 <a id="11221" href="Solutions5-dan.html#5895" data-type="(f : A → B) (g : B → C) (p : a ≡ a&#39;) → ap (g ∘ f) p ≡ ap g (ap f p)" class="Function">ap-∘</a> <a id="11226" class="Symbol">(</a><a id="11227" href="Solutions4.html#5241" data-type="(X → Y) → Susp X → Susp Y" class="Function">susp-func</a> <a id="11237" href="Solutions5-dan.html#11018" class="Bound">f</a><a id="11238" class="Symbol">)</a>  <a id="11241" class="Symbol">(</a><a id="11242" href="Solutions4.html#5241" data-type="(X → Y) → Susp X → Susp Y" class="Function">susp-func</a> <a id="11252" href="Solutions5-dan.html#11020" class="Bound">g</a><a id="11253" class="Symbol">)</a> <a id="11255" class="Symbol">_</a> <a id="11257" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                 <a id="11308" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="11311" class="Symbol">(</a><a id="11312" href="new-prelude.html#937" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="11315" class="Symbol">(</a><a id="11316" href="Solutions4.html#5241" data-type="(X → Y) → Susp X → Susp Y" class="Function">susp-func</a> <a id="11326" href="Solutions5-dan.html#11020" class="Bound">g</a><a id="11327" class="Symbol">))</a> <a id="11330" class="Symbol">(</a><a id="11331" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="11346" class="Symbol">_</a> <a id="11348" class="Symbol">_</a> <a id="11350" class="Symbol">_</a> <a id="11352" class="Symbol">_)</a> <a id="11355" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                 <a id="11406" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="11421" class="Symbol">_</a> <a id="11423" class="Symbol">_</a> <a id="11425" class="Symbol">_</a> <a id="11427" class="Symbol">_</a> <a id="11429" href="new-prelude.html#642" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>
                                                 <a id="11480" href="new-prelude.html#861" data-type="x ≡ y → y ≡ x" class="Function">!</a> <a id="11482" class="Symbol">(</a><a id="11483" href="Solutions5-dan.html#8606" data-type="(n s : X) (m : A → n ≡ s) (x : A) →
ap (Susp-rec n s m) (merid x) ≡ m x" class="Postulate">Susp-rec-merid</a> <a id="11498" class="Symbol">_</a> <a id="11500" class="Symbol">_</a> <a id="11502" class="Symbol">_</a> <a id="11504" class="Symbol">_)))</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em;
    border: 1px solid black; }
  table th {
    border-bottom: 2px solid black; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
