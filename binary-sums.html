<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<p><a href="Https://www.Cs.Bham.Ac.Uk/~mhe/">Martin Escardo</a>. Notes
originally written for the module <em>Advanced Functional
Programming</em> of the <a
href="https://www.birmingham.ac.uk/index.aspx">University of
Birmingham</a>, UK.</p>
<!--
<pre class="Agda"><a id="222" class="Symbol">{-#</a> <a id="226" class="Keyword">OPTIONS</a> <a id="234" class="Pragma">--without-K</a> <a id="246" class="Pragma">--safe</a> <a id="253" class="Symbol">#-}</a>

<a id="258" class="Keyword">module</a> <a id="265" href="binary-sums.html" class="Module">binary-sums</a> <a id="277" class="Keyword">where</a>

<a id="284" class="Keyword">open</a> <a id="289" class="Keyword">import</a> <a id="296" href="general-notation.html" class="Module">general-notation</a>
</pre>-->
<h1 id="the-binary-sum-type-former-__">The binary-sum type former
<code>_∔_</code></h1>
This is the same as (or, more precisely, <a
href="isomorphisms.html">isomorphic</a> to) the <code>Either</code> type
defined earlier (you can try this as an exercise). The notation in type
theory is <code>_+_</code>, but we want to reserve this for addition of
natural numbers, and hence we use the same symbol with a dot on top:
<pre class="Agda"><a id="667" class="Keyword">data</a> <a id="_∔_"></a><a id="672" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">_∔_</a> <a id="676" class="Symbol">(</a><a id="677" href="binary-sums.html#677" class="Bound">A</a> <a id="679" href="binary-sums.html#679" class="Bound">B</a> <a id="681" class="Symbol">:</a> <a id="683" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="687" class="Symbol">)</a> <a id="689" class="Symbol">:</a> <a id="691" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a> <a id="696" class="Keyword">where</a>
 <a id="_∔_.inl"></a><a id="703" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="707" class="Symbol">:</a> <a id="709" href="binary-sums.html#677" class="Bound">A</a> <a id="711" class="Symbol">→</a> <a id="713" href="binary-sums.html#677" class="Bound">A</a> <a id="715" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="717" href="binary-sums.html#679" class="Bound">B</a>
 <a id="_∔_.inr"></a><a id="720" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="724" class="Symbol">:</a> <a id="726" href="binary-sums.html#679" class="Bound">B</a> <a id="728" class="Symbol">→</a> <a id="730" href="binary-sums.html#677" class="Bound">A</a> <a id="732" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="734" href="binary-sums.html#679" class="Bound">B</a>

<a id="737" class="Keyword">infixr</a> <a id="744" class="Number">20</a> <a id="747" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">_∔_</a>
</pre>
<p>The type <code>A ∔ B</code> is called the coproduct of <code>A</code>
and <code>B</code>, or the sum of <code>A</code> and <code>B</code>, or
the disjoint union of <code>A</code> and <code>B</code>. The elements of
<code>A ∔ B</code> are of the form <code>inl x</code> with
<code>x : A</code> and <code>inr y</code> with <code>y : B</code>.</p>
<p>In terms of computation, we use the type <code>A ∔ B</code> when we
want to put the two types together into a single type. It is also
possible to write <code>A ∔ A</code>, in which case we will have two
copies of the type <code>A</code>, so that now every element
<code>x</code> of <code>A</code> has two different incarnations
<code>inl a</code> and <code>inr a</code> in the type
<code>A ∔ A</code>. For example, the <a href="unit-type.html">unit
type</a> <code>𝟙</code> has exactly one element, namely
<code>⋆ : 𝟙</code>, and hence the type <code>𝟙 ∔ 𝟙</code> has precisely
two elements, namely <code>inl ⋆</code> and <code>inr ⋆</code>.</p>
<h2 id="logical-disjunction-or">Logical disjunction (“or”)</h2>
<p>In terms of logic, we use the type <code>A ∔ B</code> to express “A
or B”. This is because in order for “A or B” to hold, at least one of A
and B must hold. The type <code>A → A ∔ B</code> of the function
<code>inl</code> is interpreted as saying that if A holds then so does
“A or B”, and similarly, the type of B → A ∔ B of the function
<code>inr</code> says that if B holds then so does “A or B”. In other
words, if <code>x : A</code> is a proof of <code>A</code>, then
<code>inl x : A + B</code> is a proof of <code>A or B</code>, and if
<code>y : B</code> is a proof of B, them <code>inr y : A + B</code> is a
proof of “A or B”. Here when we said “proof” we meant “program” after
the propositions-as-types and proofs-as-programs paradigm.</p>
<h2 id="logical-disjunction-in-hottuf">Logical disjunction in
HoTT/UF</h2>
<p>In HoTT/UF it useful to have an alternative disjunction operation
<code>A ∨ B</code> defined to be <code>∥ A ∔ B ∥</code> where
<code>∥_∥</code> is a certain <em>propositional truncation</em>
operation.</p>
<h2 id="elimination-principle">Elimination principle</h2>
<p>Now suppose we want to define a dependent function
<code>(z : A ∔ B) → C z</code>. How can we do that? If we have two
functions <code>f : (x : A) → C (inl x)</code> and
<code>g : (y : B) → C (inr y)</code>, then, given
<code>z : A ∔ B</code>, we can inspect whether <code>z</code> is of the
form <code>inl x</code> with <code>x : A</code> or of the form
<code>inr y</code> with <code>y : B</code>, and the respectively apply
<code>f</code> or <code>g</code> to get an element of <code>C z</code>.
This procedure is called the <em>elimination</em> principle for the type
former <code>_∔_</code> and can be written in Agda as follows:</p>
<pre class="Agda"><a id="∔-elim"></a><a id="2842" href="binary-sums.html#2842" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((x : A) → C (binary-sums.inl x)) →
((y : B) → C (binary-sums.inr y)) → (z : A binary-sums.∔ B) → C z" class="Function">∔-elim</a> <a id="2849" class="Symbol">:</a> <a id="2851" class="Symbol">{</a><a id="2852" href="binary-sums.html#2852" class="Bound">A</a> <a id="2854" href="binary-sums.html#2854" class="Bound">B</a> <a id="2856" class="Symbol">:</a> <a id="2858" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="2862" class="Symbol">}</a> <a id="2864" class="Symbol">(</a><a id="2865" href="binary-sums.html#2865" class="Bound">C</a> <a id="2867" class="Symbol">:</a> <a id="2869" href="binary-sums.html#2852" class="Bound">A</a> <a id="2871" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="2873" href="binary-sums.html#2854" class="Bound">B</a> <a id="2875" class="Symbol">→</a> <a id="2877" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="2881" class="Symbol">)</a>
       <a id="2890" class="Symbol">→</a> <a id="2892" class="Symbol">((</a><a id="2894" href="binary-sums.html#2894" class="Bound">x</a> <a id="2896" class="Symbol">:</a> <a id="2898" href="binary-sums.html#2852" class="Bound">A</a><a id="2899" class="Symbol">)</a> <a id="2901" class="Symbol">→</a> <a id="2903" href="binary-sums.html#2865" class="Bound">C</a> <a id="2905" class="Symbol">(</a><a id="2906" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="2910" href="binary-sums.html#2894" class="Bound">x</a><a id="2911" class="Symbol">))</a>
       <a id="2921" class="Symbol">→</a> <a id="2923" class="Symbol">((</a><a id="2925" href="binary-sums.html#2925" class="Bound">y</a> <a id="2927" class="Symbol">:</a> <a id="2929" href="binary-sums.html#2854" class="Bound">B</a><a id="2930" class="Symbol">)</a> <a id="2932" class="Symbol">→</a> <a id="2934" href="binary-sums.html#2865" class="Bound">C</a> <a id="2936" class="Symbol">(</a><a id="2937" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="2941" href="binary-sums.html#2925" class="Bound">y</a><a id="2942" class="Symbol">))</a>
       <a id="2952" class="Symbol">→</a> <a id="2954" class="Symbol">(</a><a id="2955" href="binary-sums.html#2955" class="Bound">z</a> <a id="2957" class="Symbol">:</a> <a id="2959" href="binary-sums.html#2852" class="Bound">A</a> <a id="2961" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="2963" href="binary-sums.html#2854" class="Bound">B</a><a id="2964" class="Symbol">)</a> <a id="2966" class="Symbol">→</a> <a id="2968" href="binary-sums.html#2865" class="Bound">C</a> <a id="2970" href="binary-sums.html#2955" class="Bound">z</a>
<a id="2972" href="binary-sums.html#2842" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((x : A) → C (binary-sums.inl x)) →
((y : B) → C (binary-sums.inr y)) → (z : A binary-sums.∔ B) → C z" class="Function">∔-elim</a> <a id="2979" href="binary-sums.html#2979" class="Bound">C</a> <a id="2981" href="binary-sums.html#2981" class="Bound">f</a> <a id="2983" href="binary-sums.html#2983" class="Bound">g</a> <a id="2985" class="Symbol">(</a><a id="2986" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="2990" href="binary-sums.html#2990" class="Bound">x</a><a id="2991" class="Symbol">)</a> <a id="2993" class="Symbol">=</a> <a id="2995" href="binary-sums.html#2981" class="Bound">f</a> <a id="2997" href="binary-sums.html#2990" class="Bound">x</a>
<a id="2999" href="binary-sums.html#2842" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((x : A) → C (binary-sums.inl x)) →
((y : B) → C (binary-sums.inr y)) → (z : A binary-sums.∔ B) → C z" class="Function">∔-elim</a> <a id="3006" href="binary-sums.html#3006" class="Bound">C</a> <a id="3008" href="binary-sums.html#3008" class="Bound">f</a> <a id="3010" href="binary-sums.html#3010" class="Bound">g</a> <a id="3012" class="Symbol">(</a><a id="3013" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="3017" href="binary-sums.html#3017" class="Bound">y</a><a id="3018" class="Symbol">)</a> <a id="3020" class="Symbol">=</a> <a id="3022" href="binary-sums.html#3010" class="Bound">g</a> <a id="3024" href="binary-sums.html#3017" class="Bound">y</a>
</pre>
So the eliminator amounts to simply definition by cases. In terms of
logic, it says that in order to show that “for all z : A ∔ B we have
that C z holds” it is enough to show two things: (1) “for all x : A it
is the case that C (inl x) holds”, and (2) “forall y : B it is the case
that C (inr y) holds”. This is not only sufficient, but also necessary:
<pre class="Agda"><a id="3391" class="Keyword">open</a> <a id="3396" class="Keyword">import</a> <a id="3403" href="binary-products.html" class="Module">binary-products</a>

<a id="∔-split"></a><a id="3420" href="binary-sums.html#3420" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) →
((x : A) → C (binary-sums.inl x)) binary-products.×
((y : B) → C (binary-sums.inr y))" class="Function">∔-split</a> <a id="3428" class="Symbol">:</a> <a id="3430" class="Symbol">{</a><a id="3431" href="binary-sums.html#3431" class="Bound">A</a> <a id="3433" href="binary-sums.html#3433" class="Bound">B</a> <a id="3435" class="Symbol">:</a> <a id="3437" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="3441" class="Symbol">}</a> <a id="3443" class="Symbol">(</a><a id="3444" href="binary-sums.html#3444" class="Bound">C</a> <a id="3446" class="Symbol">:</a> <a id="3448" href="binary-sums.html#3431" class="Bound">A</a> <a id="3450" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="3452" href="binary-sums.html#3433" class="Bound">B</a> <a id="3454" class="Symbol">→</a> <a id="3456" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="3460" class="Symbol">)</a>
        <a id="3470" class="Symbol">→</a> <a id="3472" class="Symbol">((</a><a id="3474" href="binary-sums.html#3474" class="Bound">z</a> <a id="3476" class="Symbol">:</a> <a id="3478" href="binary-sums.html#3431" class="Bound">A</a> <a id="3480" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="3482" href="binary-sums.html#3433" class="Bound">B</a><a id="3483" class="Symbol">)</a> <a id="3485" class="Symbol">→</a> <a id="3487" href="binary-sums.html#3444" class="Bound">C</a> <a id="3489" href="binary-sums.html#3474" class="Bound">z</a><a id="3490" class="Symbol">)</a>
        <a id="3500" class="Symbol">→</a> <a id="3502" class="Symbol">((</a><a id="3504" href="binary-sums.html#3504" class="Bound">x</a> <a id="3506" class="Symbol">:</a> <a id="3508" href="binary-sums.html#3431" class="Bound">A</a><a id="3509" class="Symbol">)</a> <a id="3511" class="Symbol">→</a> <a id="3513" href="binary-sums.html#3444" class="Bound">C</a> <a id="3515" class="Symbol">(</a><a id="3516" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="3520" href="binary-sums.html#3504" class="Bound">x</a><a id="3521" class="Symbol">))</a> <a id="3524" href="binary-products.html#670" data-type="general-notation.Type →
general-notation.Type → general-notation.Type" class="Function Operator">×</a> <a id="3526" class="Symbol">((</a><a id="3528" href="binary-sums.html#3528" class="Bound">y</a> <a id="3530" class="Symbol">:</a> <a id="3532" href="binary-sums.html#3433" class="Bound">B</a><a id="3533" class="Symbol">)</a> <a id="3535" class="Symbol">→</a> <a id="3537" href="binary-sums.html#3444" class="Bound">C</a> <a id="3539" class="Symbol">(</a><a id="3540" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="3544" href="binary-sums.html#3528" class="Bound">y</a><a id="3545" class="Symbol">))</a>
<a id="3548" href="binary-sums.html#3420" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) →
((x : A) → C (binary-sums.inl x)) binary-products.×
((y : B) → C (binary-sums.inr y))" class="Function">∔-split</a> <a id="3556" class="Symbol">{</a><a id="3557" href="binary-sums.html#3557" class="Bound">A</a><a id="3558" class="Symbol">}</a> <a id="3560" class="Symbol">{</a><a id="3561" href="binary-sums.html#3561" class="Bound">B</a><a id="3562" class="Symbol">}</a> <a id="3564" href="binary-sums.html#3564" class="Bound">C</a> <a id="3566" href="binary-sums.html#3566" class="Bound">h</a> <a id="3568" class="Symbol">=</a> <a id="3570" href="binary-sums.html#3585" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) → (x : A) → C (binary-sums.inl x)" class="Function">f</a> <a id="3572" href="sums.html#2522" data-type="(pr₁ : A) (pr₂ : B pr₁) → sums.Σ B" class="InductiveConstructor Operator">,</a> <a id="3574" href="binary-sums.html#3630" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) → (y : B) → C (binary-sums.inr y)" class="Function">g</a>
 <a id="3577" class="Keyword">where</a>
  <a id="3585" href="binary-sums.html#3585" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) → (x : A) → C (binary-sums.inl x)" class="Function">f</a> <a id="3587" class="Symbol">:</a> <a id="3589" class="Symbol">(</a><a id="3590" href="binary-sums.html#3590" class="Bound">x</a> <a id="3592" class="Symbol">:</a> <a id="3594" href="binary-sums.html#3557" class="Bound">A</a><a id="3595" class="Symbol">)</a> <a id="3597" class="Symbol">→</a> <a id="3599" href="binary-sums.html#3564" class="Bound">C</a> <a id="3601" class="Symbol">(</a><a id="3602" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="3606" href="binary-sums.html#3590" class="Bound">x</a><a id="3607" class="Symbol">)</a>
  <a id="3611" href="binary-sums.html#3585" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) → (x : A) → C (binary-sums.inl x)" class="Function">f</a> <a id="3613" href="binary-sums.html#3613" class="Bound">x</a> <a id="3615" class="Symbol">=</a> <a id="3617" href="binary-sums.html#3566" class="Bound">h</a> <a id="3619" class="Symbol">(</a><a id="3620" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="3624" href="binary-sums.html#3613" class="Bound">x</a><a id="3625" class="Symbol">)</a>

  <a id="3630" href="binary-sums.html#3630" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) → (y : B) → C (binary-sums.inr y)" class="Function">g</a> <a id="3632" class="Symbol">:</a> <a id="3634" class="Symbol">(</a><a id="3635" href="binary-sums.html#3635" class="Bound">y</a> <a id="3637" class="Symbol">:</a> <a id="3639" href="binary-sums.html#3561" class="Bound">B</a><a id="3640" class="Symbol">)</a> <a id="3642" class="Symbol">→</a> <a id="3644" href="binary-sums.html#3564" class="Bound">C</a> <a id="3646" class="Symbol">(</a><a id="3647" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="3651" href="binary-sums.html#3635" class="Bound">y</a><a id="3652" class="Symbol">)</a>
  <a id="3656" href="binary-sums.html#3630" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) → (y : B) → C (binary-sums.inr y)" class="Function">g</a> <a id="3658" href="binary-sums.html#3658" class="Bound">y</a> <a id="3660" class="Symbol">=</a> <a id="3662" href="binary-sums.html#3566" class="Bound">h</a> <a id="3664" class="Symbol">(</a><a id="3665" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="3669" href="binary-sums.html#3658" class="Bound">y</a><a id="3670" class="Symbol">)</a>
</pre>
There is also a version of the eliminator in which <code>C</code>
doesn’t depend on <code>z : A ∔ B</code> and is always the same:
<pre class="Agda"><a id="∔-nondep-elim"></a><a id="3794" href="binary-sums.html#3794" data-type="(A → C) → (B → C) → A binary-sums.∔ B → C" class="Function">∔-nondep-elim</a> <a id="3808" class="Symbol">:</a> <a id="3810" class="Symbol">{</a><a id="3811" href="binary-sums.html#3811" class="Bound">A</a> <a id="3813" href="binary-sums.html#3813" class="Bound">B</a> <a id="3815" href="binary-sums.html#3815" class="Bound">C</a> <a id="3817" class="Symbol">:</a> <a id="3819" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="3823" class="Symbol">}</a>
              <a id="3839" class="Symbol">→</a> <a id="3841" class="Symbol">(</a><a id="3842" href="binary-sums.html#3811" class="Bound">A</a> <a id="3844" class="Symbol">→</a> <a id="3846" href="binary-sums.html#3815" class="Bound">C</a><a id="3847" class="Symbol">)</a>
              <a id="3863" class="Symbol">→</a> <a id="3865" class="Symbol">(</a><a id="3866" href="binary-sums.html#3813" class="Bound">B</a> <a id="3868" class="Symbol">→</a> <a id="3870" href="binary-sums.html#3815" class="Bound">C</a><a id="3871" class="Symbol">)</a>
              <a id="3887" class="Symbol">→</a> <a id="3889" class="Symbol">(</a><a id="3890" href="binary-sums.html#3811" class="Bound">A</a> <a id="3892" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="3894" href="binary-sums.html#3813" class="Bound">B</a> <a id="3896" class="Symbol">→</a> <a id="3898" href="binary-sums.html#3815" class="Bound">C</a><a id="3899" class="Symbol">)</a>
<a id="3901" href="binary-sums.html#3794" data-type="(A → C) → (B → C) → A binary-sums.∔ B → C" class="Function">∔-nondep-elim</a> <a id="3915" class="Symbol">{</a><a id="3916" href="binary-sums.html#3916" class="Bound">A</a><a id="3917" class="Symbol">}</a> <a id="3919" class="Symbol">{</a><a id="3920" href="binary-sums.html#3920" class="Bound">B</a><a id="3921" class="Symbol">}</a> <a id="3923" class="Symbol">{</a><a id="3924" href="binary-sums.html#3924" class="Bound">C</a><a id="3925" class="Symbol">}</a> <a id="3927" class="Symbol">=</a> <a id="3929" href="binary-sums.html#2842" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((x : A) → C (binary-sums.inl x)) →
((y : B) → C (binary-sums.inr y)) → (z : A binary-sums.∔ B) → C z" class="Function">∔-elim</a> <a id="3936" class="Symbol">(λ</a> <a id="3939" href="binary-sums.html#3939" class="Bound">z</a> <a id="3941" class="Symbol">→</a> <a id="3943" href="binary-sums.html#3924" class="Bound">C</a><a id="3944" class="Symbol">)</a>
</pre>
In terms of logic, this means that in order to show that “A or B implies
C”, it is enough to show that both “A implies C” and “B implies C”. This
also can be inverted:
<pre class="Agda"><a id="∔-nondep-split"></a><a id="4126" href="binary-sums.html#4126" data-type="(A binary-sums.∔ B → C) → (A → C) binary-products.× (B → C)" class="Function">∔-nondep-split</a> <a id="4141" class="Symbol">:</a> <a id="4143" class="Symbol">{</a><a id="4144" href="binary-sums.html#4144" class="Bound">A</a> <a id="4146" href="binary-sums.html#4146" class="Bound">B</a> <a id="4148" href="binary-sums.html#4148" class="Bound">C</a> <a id="4150" class="Symbol">:</a> <a id="4152" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="4156" class="Symbol">}</a>
               <a id="4173" class="Symbol">→</a> <a id="4175" class="Symbol">(</a><a id="4176" href="binary-sums.html#4144" class="Bound">A</a> <a id="4178" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="4180" href="binary-sums.html#4146" class="Bound">B</a> <a id="4182" class="Symbol">→</a> <a id="4184" href="binary-sums.html#4148" class="Bound">C</a><a id="4185" class="Symbol">)</a>
               <a id="4202" class="Symbol">→</a> <a id="4204" class="Symbol">(</a><a id="4205" href="binary-sums.html#4144" class="Bound">A</a> <a id="4207" class="Symbol">→</a> <a id="4209" href="binary-sums.html#4148" class="Bound">C</a><a id="4210" class="Symbol">)</a> <a id="4212" href="binary-products.html#670" data-type="general-notation.Type →
general-notation.Type → general-notation.Type" class="Function Operator">×</a> <a id="4214" class="Symbol">(</a><a id="4215" href="binary-sums.html#4146" class="Bound">B</a> <a id="4217" class="Symbol">→</a> <a id="4219" href="binary-sums.html#4148" class="Bound">C</a><a id="4220" class="Symbol">)</a>
<a id="4222" href="binary-sums.html#4126" data-type="(A binary-sums.∔ B → C) → (A → C) binary-products.× (B → C)" class="Function">∔-nondep-split</a> <a id="4237" class="Symbol">{</a><a id="4238" href="binary-sums.html#4238" class="Bound">A</a><a id="4239" class="Symbol">}</a> <a id="4241" class="Symbol">{</a><a id="4242" href="binary-sums.html#4242" class="Bound">B</a><a id="4243" class="Symbol">}</a> <a id="4245" class="Symbol">{</a><a id="4246" href="binary-sums.html#4246" class="Bound">C</a><a id="4247" class="Symbol">}</a> <a id="4249" class="Symbol">=</a> <a id="4251" href="binary-sums.html#3420" data-type="(C : A binary-sums.∔ B → general-notation.Type) →
((z : A binary-sums.∔ B) → C z) →
((x : A) → C (binary-sums.inl x)) binary-products.×
((y : B) → C (binary-sums.inr y))" class="Function">∔-split</a> <a id="4259" class="Symbol">(λ</a> <a id="4262" href="binary-sums.html#4262" class="Bound">z</a> <a id="4264" class="Symbol">→</a> <a id="4266" href="binary-sums.html#4246" class="Bound">C</a><a id="4267" class="Symbol">)</a>
</pre>
<p>In terms of logic, this means that if <code>A or B implies C</code>
then both <code>A implies C</code> and <code>B implies C</code>.</p>
<h2 id="alternative-definition-of-__">Alternative definition of
<code>_∔_</code></h2>
<p>There is <a href="binary-sums-as-sums.html">another way to define
binary sums</a> as a special case of <code>Σ</code>.</p>
<p><a href="https://martinescardo.github.io/HoTTEST-Summer-School/">Go
back to the table of contents</a></p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em;
    border: 1px solid black; }
  table th {
    border-bottom: 2px solid black; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
