<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<h1 id="lecture-7-cubical-agda">Lecture 7: Cubical Agda</h1>
<p>Contents:</p>
<ul>
<li>The interval and Path/PathP types</li>
<li>Cubical higher inductive types</li>
</ul>
<h2 id="some-introductory-pointers-for-further-reading">Some
introductory pointers for further reading</h2>
<p>Documentation of the Cubical Agda mode can be found <a
href="https://agda.readthedocs.io/en/v2.6.2.2/language/cubical.html">here</a>.</p>
<p>These lectures about Cubical Agda will be inspired by my material
from the <a
href="https://github.com/HoTT/EPIT-2020/tree/main/04-cubical-type-theory">2020
EPIT school on HoTT</a>.</p>
<p>For students interested in a more in depth introduction to cubical
type theory see <a
href="https://www.cambridge.org/core/journals/mathematical-structures-in-computer-science/article/cubical-methods-in-homotopy-type-theory-and-univalent-foundations/ECB3FE6B4A0B19AED2D3A2D785C38AF9">my
lecture notes for the 2019 HoTT school</a>. Those notes contain a lot
more background and motivation to cubical methods in HoTT and an
extensive list of references for those that want to read more background
material.</p>
<p>If one wants a library to work with when doing Cubical Agda there is
the <a href="https://github.com/agda/cubical/">agda/cubical</a> library
that I started developing with Andrea Vezzosi (the implementor of
Cubical Agda) in 2018 and which has now over 70 contributors. It
contains a variety of things, including data structures, algebra,
synthetic homotopy and cohomology theory, etc..</p>
<p>For a slower-paced introduction to mathematics in Cubical Agda, there
is the more recent <a href="https://1lab.dev/">1lab</a>. Although meant
to be read on the web, it also doubles as a community-maintained library
of formalized mathematics, most notably category theory.</p>
<h1 id="cubical-agda">Cubical Agda</h1>
<p>To make Agda cubical simply add the following option:</p>
<pre class="Agda"><a id="1668" class="Symbol">{-#</a> <a id="1672" class="Keyword">OPTIONS</a> <a id="1680" class="Pragma">--cubical</a> <a id="1690" class="Symbol">#-}</a>

<a id="1695" class="Keyword">module</a> <a id="1702" href="Lecture7-notes.html" class="Module">Lecture7-notes</a> <a id="1717" class="Keyword">where</a>
</pre>
<p>We also have a small cubical prelude which sets things up to work
nicely and which provides whatever we might need for the lectures.</p>
<pre class="Agda"><a id="1870" class="Keyword">open</a> <a id="1875" class="Keyword">import</a> <a id="1882" href="cubical-prelude.html" class="Module">cubical-prelude</a>
</pre>
<p>The key idea in cubical type theories like Cubical Agda is to not
have equality be inductively defined as in Book HoTT, but rather we
assume that there is a primitive interval and define equality literally
as paths, i.e. as functions out of the interval. By iterating these
paths we get squares, cubes, hypercubes, …, making the type theory
inherently cubical.</p>
<h1 id="the-interval-and-path-types">The interval and path types</h1>
<p>The interval is a primitive concept in Cubical Agda. It’s written
<code>I</code>. It has two endpoints:</p>
<pre class="text"><code>  i0 : I
  i1 : I</code></pre>
<p>These stand for “interval 0” and “interval 1”.</p>
<p>We can apply a function out of the interval to an endpoint just like
we would with any Agda function:</p>
<pre class="Agda"><a id="apply0"></a><a id="2582" href="Lecture7-notes.html#2582" data-type="(A : Set ℓ) → (I → A) → A" class="Function">apply0</a> <a id="2589" class="Symbol">:</a> <a id="2591" class="Symbol">(</a><a id="2592" href="Lecture7-notes.html#2592" class="Bound">A</a> <a id="2594" class="Symbol">:</a> <a id="2596" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="2601" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="2602" class="Symbol">)</a> <a id="2604" class="Symbol">(</a><a id="2605" href="Lecture7-notes.html#2605" class="Bound">p</a> <a id="2607" class="Symbol">:</a> <a id="2609" href="Agda.Primitive.Cubical.html#108" data-type="SSet lzero" class="Datatype">I</a> <a id="2611" class="Symbol">→</a> <a id="2613" href="Lecture7-notes.html#2592" class="Bound">A</a><a id="2614" class="Symbol">)</a> <a id="2616" class="Symbol">→</a> <a id="2618" href="Lecture7-notes.html#2592" class="Bound">A</a>
<a id="2620" href="Lecture7-notes.html#2582" data-type="(A : Set ℓ) → (I → A) → A" class="Function">apply0</a> <a id="2627" href="Lecture7-notes.html#2627" class="Bound">A</a> <a id="2629" href="Lecture7-notes.html#2629" class="Bound">p</a> <a id="2631" class="Symbol">=</a> <a id="2633" href="Lecture7-notes.html#2629" class="Bound">p</a> <a id="2635" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a>
</pre>
<p>The equality type <code>_≡_</code> is not inductively defined in
Cubical Agda, instead it’s a builtin primitive notion defined using the
interval. An element of <code>x ≡ y</code> consists of a function
<code>p : I → A</code> such that <code>p i0</code> is definitionally
<code>x</code> and <code>p i1</code> is definitionally <code>y</code>.
The check that the endpoints are correct when we provide a
<code>p : I → A</code> is automatically performed by Agda during
typechecking, so introducing an element of <code>x ≡ y</code> is done
just like how we introduce elements of <code>I → A</code> but Agda will
check the side conditions.</p>
<p>We can hence write paths using λ-abstraction:</p>
<pre class="Agda"><a id="mypath"></a><a id="3225" href="Lecture7-notes.html#3225" data-type="(x : A) → x ≡ x" class="Function">mypath</a> <a id="3232" class="Symbol">:</a> <a id="3234" class="Symbol">{</a><a id="3235" href="Lecture7-notes.html#3235" class="Bound">A</a> <a id="3237" class="Symbol">:</a> <a id="3239" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="3244" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="3245" class="Symbol">}</a> <a id="3247" class="Symbol">(</a><a id="3248" href="Lecture7-notes.html#3248" class="Bound">x</a> <a id="3250" class="Symbol">:</a> <a id="3252" href="Lecture7-notes.html#3235" class="Bound">A</a><a id="3253" class="Symbol">)</a> <a id="3255" class="Symbol">→</a> <a id="3257" href="Lecture7-notes.html#3248" class="Bound">x</a> <a id="3259" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="3261" href="Lecture7-notes.html#3248" class="Bound">x</a>
<a id="3263" href="Lecture7-notes.html#3225" data-type="(x : A) → x ≡ x" class="Function">mypath</a> <a id="3270" href="Lecture7-notes.html#3270" class="Bound">x</a> <a id="3272" class="Symbol">=</a> <a id="3274" class="Symbol">λ</a> <a id="3276" href="Lecture7-notes.html#3276" class="Bound">i</a> <a id="3278" class="Symbol">→</a> <a id="3280" href="Lecture7-notes.html#3270" class="Bound">x</a>
</pre>
<p>As explained above Agda checks that whatever we written as definition
matches the path that we have provided (so the endpoints have to be
correct). In this case everything is fine and mypath can be thought of
as a proof reflexivity. Let’s give it a nicer name and more implicit
arguments:</p>
<pre class="Agda"><a id="refl"></a><a id="3585" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a> <a id="3590" class="Symbol">:</a> <a id="3592" class="Symbol">{</a><a id="3593" href="Lecture7-notes.html#3593" class="Bound">A</a> <a id="3595" class="Symbol">:</a> <a id="3597" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="3602" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="3603" class="Symbol">}</a> <a id="3605" class="Symbol">{</a><a id="3606" href="Lecture7-notes.html#3606" class="Bound">x</a> <a id="3608" class="Symbol">:</a> <a id="3610" href="Lecture7-notes.html#3593" class="Bound">A</a><a id="3611" class="Symbol">}</a> <a id="3613" class="Symbol">→</a> <a id="3615" href="Lecture7-notes.html#3606" class="Bound">x</a> <a id="3617" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="3619" href="Lecture7-notes.html#3606" class="Bound">x</a>
<a id="3621" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a> <a id="3626" class="Symbol">{</a><a id="3627" class="Argument">x</a> <a id="3629" class="Symbol">=</a> <a id="3631" href="Lecture7-notes.html#3631" class="Bound">x</a><a id="3632" class="Symbol">}</a> <a id="3634" class="Symbol">=</a> <a id="3636" class="Symbol">λ</a> <a id="3638" href="Lecture7-notes.html#3638" class="Bound">i</a> <a id="3640" class="Symbol">→</a> <a id="3642" href="Lecture7-notes.html#3631" class="Bound">x</a>
</pre>
<p>The notation <code>{x = x}</code> lets us access the implicit
argument <code>x</code> (the <code>x</code> in the LHS of
<code>x = x</code>) and rename it to <code>x</code> (the <code>x</code>
in the RHS <code>x = x</code>) in the body of <code>refl</code>. We
could just as well have written:</p>
<pre class="text"><code>refl : {A : Type ℓ} {x : A} → x ≡ x
refl {x = y} = λ i → y</code></pre>
<p>Note that we cannot pattern-match on interval variables as
<code>I</code> is not inductively defined. Try uncommenting and typing
<code>C-c C-c</code> in the hole:</p>
<pre class="text"><code>oops : {A : Type} → I → A
oops r = {!r!}</code></pre>
<p>It quickly gets tiring to write <code>{A : Type ℓ}</code> everywhere,
so let’s assume that we have some types (in fact, we’ve already assumed
that <code>ℓ</code> is a <code>Level</code> in the cubical-prelude):</p>
<pre class="Agda"><a id="4311" class="Keyword">private</a>
  <a id="4321" class="Keyword">variable</a>
    <a id="4334" href="Lecture7-notes.html#4334" class="Generalizable">A</a> <a id="4336" href="Lecture7-notes.html#4336" class="Generalizable">B</a> <a id="4338" class="Symbol">:</a> <a id="4340" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="4345" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a>
</pre>
<p>This will make <code>A</code> and <code>B</code> elements of
different universes (all arguments is maximally generalized) and all
definitions that use them will have them as implicit arguments.</p>
<p>We can now implement some basic operations on <code>_≡_</code>. Let’s
start with <code>ap</code>:</p>
<pre class="Agda"><a id="ap"></a><a id="4610" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="4613" class="Symbol">:</a> <a id="4615" class="Symbol">(</a><a id="4616" href="Lecture7-notes.html#4616" class="Bound">f</a> <a id="4618" class="Symbol">:</a> <a id="4620" href="Lecture7-notes.html#4334" class="Generalizable">A</a> <a id="4622" class="Symbol">→</a> <a id="4624" href="Lecture7-notes.html#4336" class="Generalizable">B</a><a id="4625" class="Symbol">)</a> <a id="4627" class="Symbol">{</a><a id="4628" href="Lecture7-notes.html#4628" class="Bound">x</a> <a id="4630" href="Lecture7-notes.html#4630" class="Bound">y</a> <a id="4632" class="Symbol">:</a> <a id="4634" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="4635" class="Symbol">}</a> <a id="4637" class="Symbol">→</a> <a id="4639" href="Lecture7-notes.html#4628" class="Bound">x</a> <a id="4641" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="4643" href="Lecture7-notes.html#4630" class="Bound">y</a> <a id="4645" class="Symbol">→</a> <a id="4647" href="Lecture7-notes.html#4616" class="Bound">f</a> <a id="4649" href="Lecture7-notes.html#4628" class="Bound">x</a> <a id="4651" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="4653" href="Lecture7-notes.html#4616" class="Bound">f</a> <a id="4655" href="Lecture7-notes.html#4630" class="Bound">y</a>
<a id="4657" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="4660" href="Lecture7-notes.html#4660" class="Bound">f</a> <a id="4662" href="Lecture7-notes.html#4662" class="Bound">p</a> <a id="4664" href="Lecture7-notes.html#4664" class="Bound">i</a> <a id="4666" class="Symbol">=</a> <a id="4668" href="Lecture7-notes.html#4660" class="Bound">f</a> <a id="4670" class="Symbol">(</a><a id="4671" href="Lecture7-notes.html#4662" class="Bound">p</a> <a id="4673" href="Lecture7-notes.html#4664" class="Bound">i</a><a id="4674" class="Symbol">)</a>
</pre>
<p>Note that the definition differs from the Book HoTT definition in
that it is not defined by path induction or pattern-matching on
<code>p</code>, but rather it’s just a direct definition as a
composition of functions. Agda treats <code>p : x ≡ y</code> like any
function, so we can apply it to <code>i</code> to get an element of
<code>A</code> which at <code>i0</code> is <code>x</code> and at
<code>i1</code> is <code>y</code>. By applying <code>f</code> to this
element we hence get an element of <code>B</code> which at
<code>i0</code> is <code>f x</code> and at <code>i1</code> is
<code>f y</code>.</p>
<p>As this is just function composition it satisfies lots of nice
definitional equalities, see the exercises. Some of these are not
satisfied by the Book HoTT definition of <code>ap</code>.</p>
<p>In Book HoTT function extensionality is proved as a consequence of
univalence using a rather ingenious proof due to Voevodsky, but in
cubical systems it has a much more direct proof. As paths are just
functions we can get it by swapping the arguments to <code>p</code>:</p>
<pre class="Agda"><a id="funExt"></a><a id="5577" href="Lecture7-notes.html#5577" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funExt</a> <a id="5584" class="Symbol">:</a> <a id="5586" class="Symbol">{</a><a id="5587" href="Lecture7-notes.html#5587" class="Bound">f</a> <a id="5589" href="Lecture7-notes.html#5589" class="Bound">g</a> <a id="5591" class="Symbol">:</a> <a id="5593" href="Lecture7-notes.html#4334" class="Generalizable">A</a> <a id="5595" class="Symbol">→</a> <a id="5597" href="Lecture7-notes.html#4336" class="Generalizable">B</a><a id="5598" class="Symbol">}</a> <a id="5600" class="Symbol">(</a><a id="5601" href="Lecture7-notes.html#5601" class="Bound">p</a> <a id="5603" class="Symbol">:</a> <a id="5605" class="Symbol">(</a><a id="5606" href="Lecture7-notes.html#5606" class="Bound">x</a> <a id="5608" class="Symbol">:</a> <a id="5610" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="5611" class="Symbol">)</a> <a id="5613" class="Symbol">→</a> <a id="5615" href="Lecture7-notes.html#5587" class="Bound">f</a> <a id="5617" href="Lecture7-notes.html#5606" class="Bound">x</a> <a id="5619" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="5621" href="Lecture7-notes.html#5589" class="Bound">g</a> <a id="5623" href="Lecture7-notes.html#5606" class="Bound">x</a><a id="5624" class="Symbol">)</a> <a id="5626" class="Symbol">→</a> <a id="5628" href="Lecture7-notes.html#5587" class="Bound">f</a> <a id="5630" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="5632" href="Lecture7-notes.html#5589" class="Bound">g</a>
<a id="5634" href="Lecture7-notes.html#5577" data-type="((x : A) → f x ≡ g x) → f ≡ g" class="Function">funExt</a> <a id="5641" href="Lecture7-notes.html#5641" class="Bound">p</a> <a id="5643" href="Lecture7-notes.html#5643" class="Bound">i</a> <a id="5645" href="Lecture7-notes.html#5645" class="Bound">x</a> <a id="5647" class="Symbol">=</a> <a id="5649" href="Lecture7-notes.html#5641" class="Bound">p</a> <a id="5651" href="Lecture7-notes.html#5645" class="Bound">x</a> <a id="5653" href="Lecture7-notes.html#5643" class="Bound">i</a>
</pre>
<p>To see that this has the correct type, note that when <code>i</code>
is <code>i0</code> we have <code>p x i0 = f x</code> and when
<code>i</code> is <code>i1</code> we have <code>p x i1 = g x</code>, so
by η for function types we have a path <code>f ≡ g</code> as
desired.</p>
<p>The interval has additional operations:</p>
<pre class="text"><code>Minimum:     _∧_ : I → I → I             (corresponds to min(i,j))
Maximum:     _∨_ : I → I → I             (corresponds to max(i,j))
Symmetry:     ~_ : I → I                 (corresponds to 1 - i)</code></pre>
<p>These satisfy the equations of a De Morgan algebra (i.e. a
distributive lattice (<em>∧</em> , <em>∨</em> , i0 , i1) with an “De
Morgan” involution ~). This just means that we have the following kinds
of equations definitionally:</p>
<pre class="text"><code>i0 ∨ i    ≐ i
i  ∨ i1   ≐ i1
i  ∨ j    ≐ j ∨ i
i0 ∧ i    ≐ i0
i1 ∧ i    ≐ i
i  ∧ j    ≐ j ∧ i
~ (~ i)   ≐ i
i0        ≐ ~ i1
~ (i ∨ j) ≐ ~ i ∧ ~ j
~ (i ∧ j) ≐ ~ i ∨ ~ j</code></pre>
<p>However, we do not have <code>i ∨ ~ i = i1</code> and
<code>i ∧ ~ i = i0</code>. The reason is that I represents an abstract
interval, so we if we think of it as the real interval [0,1] ⊂ ℝ we
clearly don’t always have “max(i,1-i) = 1” or “min(i,1-i) = 0)” for all
i ∈ [0,1].</p>
<p>These operations on <code>I</code> are very useful as they let us
define even more things directly. For example symmetry of paths is
easily defined using <code>~_</code>.</p>
<pre class="Agda"><a id="sym"></a><a id="6920" href="Lecture7-notes.html#6920" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="6924" class="Symbol">:</a> <a id="6926" class="Symbol">{</a><a id="6927" href="Lecture7-notes.html#6927" class="Bound">x</a> <a id="6929" href="Lecture7-notes.html#6929" class="Bound">y</a> <a id="6931" class="Symbol">:</a> <a id="6933" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="6934" class="Symbol">}</a> <a id="6936" class="Symbol">→</a> <a id="6938" href="Lecture7-notes.html#6927" class="Bound">x</a> <a id="6940" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="6942" href="Lecture7-notes.html#6929" class="Bound">y</a> <a id="6944" class="Symbol">→</a> <a id="6946" href="Lecture7-notes.html#6929" class="Bound">y</a> <a id="6948" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="6950" href="Lecture7-notes.html#6927" class="Bound">x</a>
<a id="6952" href="Lecture7-notes.html#6920" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="6956" href="Lecture7-notes.html#6956" class="Bound">p</a> <a id="6958" href="Lecture7-notes.html#6958" class="Bound">i</a> <a id="6960" class="Symbol">=</a> <a id="6962" href="Lecture7-notes.html#6956" class="Bound">p</a> <a id="6964" class="Symbol">(</a><a id="6965" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="6967" href="Lecture7-notes.html#6958" class="Bound">i</a><a id="6968" class="Symbol">)</a>
</pre>
<p>Remark: this has been called <code>⁻¹</code> and <code>!</code> in
the previous lectures. Here we stick to <code>sym</code> for the cubical
version following the agda/cubical notation.</p>
<p>The operations <code>_∧_</code> and <code>_∨_</code> are called
<em>connections</em> and let us build higher dimensional cubes from
lower dimensional ones, for example if we have a path
<code>p : x ≡ y</code> then</p>
<pre class="text"><code>  sq i j = p (i ∧ j)</code></pre>
<p>is a square (as we’ve parametrized by <code>i</code> and
<code>j</code>) with the following boundary:</p>
<pre class="text"><code>   sq i0 j = p (i0 ∧ j) = p i0 = x
   sq i1 j = p (i1 ∧ j) = p j
   sq i i0 = p (i ∧ i0) = p i0 = x
   sq i i1 = p (i ∧ i1) = p i</code></pre>
<p>If we draw this we get:</p>
<pre class="text"><code>             p
       x --------&gt; y
       ^           ^
       ¦           ¦
  refl ¦     sq    ¦ p
       ¦           ¦
       ¦           ¦
       x --------&gt; x
           refl</code></pre>
<p>Being able to make this square directly is very useful. It for
example let’s prove that singletons are contractible (a.k.a. based path
induction).</p>
<p>We define the type of singletons as follows</p>
<pre class="Agda"><a id="singl"></a><a id="7980" href="Lecture7-notes.html#7980" data-type="A → Set ℓ" class="Function">singl</a> <a id="7986" class="Symbol">:</a> <a id="7988" class="Symbol">{</a><a id="7989" href="Lecture7-notes.html#7989" class="Bound">A</a> <a id="7991" class="Symbol">:</a> <a id="7993" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="7998" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="7999" class="Symbol">}</a> <a id="8001" class="Symbol">(</a><a id="8002" href="Lecture7-notes.html#8002" class="Bound">a</a> <a id="8004" class="Symbol">:</a> <a id="8006" href="Lecture7-notes.html#7989" class="Bound">A</a><a id="8007" class="Symbol">)</a> <a id="8009" class="Symbol">→</a> <a id="8011" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="8016" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a>
<a id="8018" href="Lecture7-notes.html#7980" data-type="A → Set ℓ" class="Function">singl</a> <a id="8024" class="Symbol">{</a><a id="8025" class="Argument">A</a> <a id="8027" class="Symbol">=</a> <a id="8029" href="Lecture7-notes.html#8029" class="Bound">A</a><a id="8030" class="Symbol">}</a> <a id="8032" href="Lecture7-notes.html#8032" class="Bound">a</a> <a id="8034" class="Symbol">=</a> <a id="8036" href="cubical-prelude.html#3695" data-type="(A : Set l1) → (A → Set l2) → Set (l1 ⊔ l2)" class="Function">Σ</a> <a id="8038" href="Lecture7-notes.html#8038" class="Bound">x</a> <a id="8040" href="cubical-prelude.html#3695" data-type="(A : Set l1) → (A → Set l2) → Set (l1 ⊔ l2)" class="Function">꞉</a> <a id="8042" href="Lecture7-notes.html#8029" class="Bound">A</a> <a id="8044" href="cubical-prelude.html#3695" data-type="(A : Set l1) → (A → Set l2) → Set (l1 ⊔ l2)" class="Function">,</a> <a id="8046" href="Lecture7-notes.html#8032" class="Bound">a</a> <a id="8048" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="8050" href="Lecture7-notes.html#8038" class="Bound">x</a>
</pre>
<p>To show that this type is contractible we need to provide a center of
contraction and the fact that any element of it is path-equal to the
center</p>
<pre class="Agda"><a id="isContrSingl"></a><a id="8212" href="Lecture7-notes.html#8212" data-type="(x : A) → isContr (singl x)" class="Function">isContrSingl</a> <a id="8225" class="Symbol">:</a> <a id="8227" class="Symbol">(</a><a id="8228" href="Lecture7-notes.html#8228" class="Bound">x</a> <a id="8230" class="Symbol">:</a> <a id="8232" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="8233" class="Symbol">)</a> <a id="8235" class="Symbol">→</a> <a id="8237" href="cubical-prelude.html#4004" data-type="Set ℓ → Set ℓ" class="Function">isContr</a> <a id="8245" class="Symbol">(</a><a id="8246" href="Lecture7-notes.html#7980" data-type="A → Set ℓ" class="Function">singl</a> <a id="8252" href="Lecture7-notes.html#8228" class="Bound">x</a><a id="8253" class="Symbol">)</a>
<a id="8255" href="Lecture7-notes.html#8212" data-type="(x : A) → isContr (singl x)" class="Function">isContrSingl</a> <a id="8268" href="Lecture7-notes.html#8268" class="Bound">x</a> <a id="8270" class="Symbol">=</a> <a id="8272" href="Lecture7-notes.html#8339" data-type="(x : A) → singl x" class="Function">ctr</a> <a id="8276" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="8278" href="Lecture7-notes.html#8757" data-type="(x : A) (s : singl x) → ctr x ≡ s" class="Function">prf</a>
  <a id="8284" class="Keyword">where</a>
  <a id="8292" class="Comment">-- The center is just a pair with x and refl</a>
  <a id="8339" href="Lecture7-notes.html#8339" data-type="(x : A) → singl x" class="Function">ctr</a> <a id="8343" class="Symbol">:</a> <a id="8345" href="Lecture7-notes.html#7980" data-type="A → Set ℓ" class="Function">singl</a> <a id="8351" href="Lecture7-notes.html#8268" class="Bound">x</a>
  <a id="8355" href="Lecture7-notes.html#8339" data-type="(x : A) → singl x" class="Function">ctr</a> <a id="8359" class="Symbol">=</a> <a id="8361" href="Lecture7-notes.html#8268" class="Bound">x</a> <a id="8363" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="8365" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>

  <a id="8373" class="Comment">-- We then need to prove that ctr is equal to any element s : singl x.</a>
  <a id="8446" class="Comment">-- This is an equality in a Σ-type, so the first component is a path</a>
  <a id="8517" class="Comment">-- and the second is a path over the path we pick as first argument,</a>
  <a id="8588" class="Comment">-- i.e. the second component is a square. In fact, we need a square</a>
  <a id="8658" class="Comment">-- relating refl and pax over a path between refl and pax, so we can</a>
  <a id="8729" class="Comment">-- use an _∧_ connection.</a>
  <a id="8757" href="Lecture7-notes.html#8757" data-type="(x : A) (s : singl x) → ctr x ≡ s" class="Function">prf</a> <a id="8761" class="Symbol">:</a> <a id="8763" class="Symbol">(</a><a id="8764" href="Lecture7-notes.html#8764" class="Bound">s</a> <a id="8766" class="Symbol">:</a> <a id="8768" href="Lecture7-notes.html#7980" data-type="A → Set ℓ" class="Function">singl</a> <a id="8774" href="Lecture7-notes.html#8268" class="Bound">x</a><a id="8775" class="Symbol">)</a> <a id="8777" class="Symbol">→</a> <a id="8779" href="Lecture7-notes.html#8339" data-type="(x : A) → singl x" class="Function">ctr</a> <a id="8783" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="8785" href="Lecture7-notes.html#8764" class="Bound">s</a>
  <a id="8789" href="Lecture7-notes.html#8757" data-type="(x : A) (s : singl x) → ctr x ≡ s" class="Function">prf</a> <a id="8793" class="Symbol">(</a><a id="8794" href="Lecture7-notes.html#8794" class="Bound">y</a> <a id="8796" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="8798" href="Lecture7-notes.html#8798" class="Bound">pax</a><a id="8801" class="Symbol">)</a> <a id="8803" href="Lecture7-notes.html#8803" class="Bound">i</a> <a id="8805" class="Symbol">=</a> <a id="8807" class="Symbol">(</a><a id="8808" href="Lecture7-notes.html#8798" class="Bound">pax</a> <a id="8812" href="Lecture7-notes.html#8803" class="Bound">i</a><a id="8813" class="Symbol">)</a> <a id="8815" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="8817" class="Symbol">λ</a> <a id="8819" href="Lecture7-notes.html#8819" class="Bound">j</a> <a id="8821" class="Symbol">→</a> <a id="8823" href="Lecture7-notes.html#8798" class="Bound">pax</a> <a id="8827" class="Symbol">(</a><a id="8828" href="Lecture7-notes.html#8803" class="Bound">i</a> <a id="8830" href="cubical-prelude.html#449" class="Primitive Operator">∧</a> <a id="8832" href="Lecture7-notes.html#8819" class="Bound">j</a><a id="8833" class="Symbol">)</a>
</pre>
<p>As we saw in the second component of prf we often need squares when
proving things. In fact, <code>pax (i ∧ j)</code> is a path relating
<code>refl</code> to <code>pax</code> <em>over</em> another path
<code>λ j → x ≡ pax j</code>. This notion of path over a path is very
useful when working in Book HoTT as we’ve seen in the previous lectures,
this is also the case when working cubically. In Cubical Agda path-overs
are a primitive notion called <code>PathP</code> (“Path over a Path”).
In general <code>PathP A x y</code> has</p>
<pre class="text"><code>   A : I → Type ℓ
   x : A i0
   y : A i1</code></pre>
<p>So PathP lets us natively define heteorgeneous paths, i.e. paths
where the endpoints are in different types. This allows us to specify
the type of the second component of <code>prf</code>:</p>
<pre class="Agda"><a id="prf&#39;"></a><a id="9539" href="Lecture7-notes.html#9539" data-type="(x : A) (s : singl x) → (x , refl) ≡ s" class="Function">prf&#39;</a> <a id="9544" class="Symbol">:</a> <a id="9546" class="Symbol">(</a><a id="9547" href="Lecture7-notes.html#9547" class="Bound">x</a> <a id="9549" class="Symbol">:</a> <a id="9551" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="9552" class="Symbol">)</a> <a id="9554" class="Symbol">(</a><a id="9555" href="Lecture7-notes.html#9555" class="Bound">s</a> <a id="9557" class="Symbol">:</a> <a id="9559" href="Lecture7-notes.html#7980" data-type="A → Set ℓ" class="Function">singl</a> <a id="9565" href="Lecture7-notes.html#9547" class="Bound">x</a><a id="9566" class="Symbol">)</a> <a id="9568" class="Symbol">→</a> <a id="9570" class="Symbol">(</a><a id="9571" href="Lecture7-notes.html#9547" class="Bound">x</a> <a id="9573" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="9575" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a><a id="9579" class="Symbol">)</a> <a id="9581" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="9583" href="Lecture7-notes.html#9555" class="Bound">s</a>
<a id="9585" href="Lecture7-notes.html#9539" data-type="(x : A) (s : singl x) → (x , refl) ≡ s" class="Function">prf&#39;</a> <a id="9590" href="Lecture7-notes.html#9590" class="Bound">x</a> <a id="9592" class="Symbol">(</a><a id="9593" href="Lecture7-notes.html#9593" class="Bound">y</a> <a id="9595" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="9597" href="Lecture7-notes.html#9597" class="Bound">pax</a><a id="9600" class="Symbol">)</a> <a id="9602" href="Lecture7-notes.html#9602" class="Bound">i</a> <a id="9604" class="Symbol">=</a> <a id="9606" class="Symbol">(</a><a id="9607" href="Lecture7-notes.html#9597" class="Bound">pax</a> <a id="9611" href="Lecture7-notes.html#9602" class="Bound">i</a><a id="9612" class="Symbol">)</a> <a id="9614" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="9616" class="Symbol">λ</a> <a id="9618" href="Lecture7-notes.html#9618" class="Bound">j</a> <a id="9620" class="Symbol">→</a> <a id="9622" href="Lecture7-notes.html#9641" data-type="(x y : A) (pax : x ≡ y) (i : I) → PathP (λ j → x ≡ pax j) refl pax" class="Function">goal</a> <a id="9627" href="Lecture7-notes.html#9602" class="Bound">i</a> <a id="9629" href="Lecture7-notes.html#9618" class="Bound">j</a>
  <a id="9633" class="Keyword">where</a>
  <a id="9641" href="Lecture7-notes.html#9641" data-type="(x y : A) (pax : x ≡ y) (i : I) → PathP (λ j → x ≡ pax j) refl pax" class="Function">goal</a> <a id="9646" class="Symbol">:</a> <a id="9648" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Set ℓ) → A i0 → A i1 → Set ℓ" class="Postulate">PathP</a> <a id="9654" class="Symbol">(λ</a> <a id="9657" href="Lecture7-notes.html#9657" class="Bound">j</a> <a id="9659" class="Symbol">→</a> <a id="9661" href="Lecture7-notes.html#9590" class="Bound">x</a> <a id="9663" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="9665" href="Lecture7-notes.html#9597" class="Bound">pax</a> <a id="9669" href="Lecture7-notes.html#9657" class="Bound">j</a><a id="9670" class="Symbol">)</a> <a id="9672" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a> <a id="9677" href="Lecture7-notes.html#9597" class="Bound">pax</a>
  <a id="9683" href="Lecture7-notes.html#9641" data-type="(x y : A) (pax : x ≡ y) (i : I) → PathP (λ j → x ≡ pax j) refl pax" class="Function">goal</a> <a id="9688" href="Lecture7-notes.html#9688" class="Bound">i</a> <a id="9690" href="Lecture7-notes.html#9690" class="Bound">j</a> <a id="9692" class="Symbol">=</a> <a id="9694" href="Lecture7-notes.html#9597" class="Bound">pax</a> <a id="9698" class="Symbol">(</a><a id="9699" href="Lecture7-notes.html#9688" class="Bound">i</a> <a id="9701" href="cubical-prelude.html#449" class="Primitive Operator">∧</a> <a id="9703" href="Lecture7-notes.html#9690" class="Bound">j</a><a id="9704" class="Symbol">)</a>
</pre>
<p>Just like <code>_×_</code> is a special case of Σ-types we have that
<code>_≡_</code> is a special case of PathP. In fact, <code>x ≡ y</code>
is just short for <code>PathP (λ _ → A) x y</code>:</p>
<pre class="Agda"><a id="reflP"></a><a id="9870" href="Lecture7-notes.html#9870" data-type="x ≡ x" class="Function">reflP</a> <a id="9876" class="Symbol">:</a> <a id="9878" class="Symbol">{</a><a id="9879" href="Lecture7-notes.html#9879" class="Bound">x</a> <a id="9881" class="Symbol">:</a> <a id="9883" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="9884" class="Symbol">}</a> <a id="9886" class="Symbol">→</a> <a id="9888" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Set ℓ) → A i0 → A i1 → Set ℓ" class="Postulate">PathP</a> <a id="9894" class="Symbol">(λ</a> <a id="9897" href="Lecture7-notes.html#9897" class="Bound">_</a> <a id="9899" class="Symbol">→</a> <a id="9901" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="9902" class="Symbol">)</a> <a id="9904" href="Lecture7-notes.html#9879" class="Bound">x</a> <a id="9906" href="Lecture7-notes.html#9879" class="Bound">x</a>
<a id="9908" href="Lecture7-notes.html#9870" data-type="x ≡ x" class="Function">reflP</a> <a id="9914" class="Symbol">=</a> <a id="9916" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>Working directly with paths and equalities makes many proofs from
Book HoTT very short:</p>
<pre class="Agda"><a id="isContrΠ"></a><a id="10023" href="Lecture7-notes.html#10023" data-type="((x : A) → isContr (B x)) → isContr ((x : A) → B x)" class="Function">isContrΠ</a> <a id="10032" class="Symbol">:</a> <a id="10034" class="Symbol">{</a><a id="10035" href="Lecture7-notes.html#10035" class="Bound">B</a> <a id="10037" class="Symbol">:</a> <a id="10039" href="Lecture7-notes.html#4334" class="Generalizable">A</a> <a id="10041" class="Symbol">→</a> <a id="10043" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="10048" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="10049" class="Symbol">}</a> <a id="10051" class="Symbol">(</a><a id="10052" href="Lecture7-notes.html#10052" class="Bound">h</a> <a id="10054" class="Symbol">:</a> <a id="10056" class="Symbol">(</a><a id="10057" href="Lecture7-notes.html#10057" class="Bound">x</a> <a id="10059" class="Symbol">:</a> <a id="10061" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="10062" class="Symbol">)</a> <a id="10064" class="Symbol">→</a> <a id="10066" href="cubical-prelude.html#4004" data-type="Set ℓ → Set ℓ" class="Function">isContr</a> <a id="10074" class="Symbol">(</a><a id="10075" href="Lecture7-notes.html#10035" class="Bound">B</a> <a id="10077" href="Lecture7-notes.html#10057" class="Bound">x</a><a id="10078" class="Symbol">))</a>
         <a id="10090" class="Symbol">→</a> <a id="10092" href="cubical-prelude.html#4004" data-type="Set ℓ → Set ℓ" class="Function">isContr</a> <a id="10100" class="Symbol">((</a><a id="10102" href="Lecture7-notes.html#10102" class="Bound">x</a> <a id="10104" class="Symbol">:</a> <a id="10106" href="Lecture7-notes.html#4334" class="Generalizable">A</a><a id="10107" class="Symbol">)</a> <a id="10109" class="Symbol">→</a> <a id="10111" href="Lecture7-notes.html#10035" class="Bound">B</a> <a id="10113" href="Lecture7-notes.html#10102" class="Bound">x</a><a id="10114" class="Symbol">)</a>
<a id="10116" href="Lecture7-notes.html#10023" data-type="((x : A) → isContr (B x)) → isContr ((x : A) → B x)" class="Function">isContrΠ</a> <a id="10125" href="Lecture7-notes.html#10125" class="Bound">h</a> <a id="10127" class="Symbol">=</a> <a id="10129" class="Symbol">(λ</a> <a id="10132" href="Lecture7-notes.html#10132" class="Bound">x</a> <a id="10134" class="Symbol">→</a> <a id="10136" href="cubical-prelude.html#3676" class="Field">pr₁</a> <a id="10140" class="Symbol">(</a><a id="10141" href="Lecture7-notes.html#10125" class="Bound">h</a> <a id="10143" href="Lecture7-notes.html#10132" class="Bound">x</a><a id="10144" class="Symbol">))</a> <a id="10147" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="10149" class="Symbol">(λ</a> <a id="10152" href="Lecture7-notes.html#10152" class="Bound">f</a> <a id="10154" href="Lecture7-notes.html#10154" class="Bound">i</a> <a id="10156" href="Lecture7-notes.html#10156" class="Bound">x</a> <a id="10158" class="Symbol">→</a> <a id="10160" href="cubical-prelude.html#3689" class="Field">pr₂</a> <a id="10164" class="Symbol">(</a><a id="10165" href="Lecture7-notes.html#10125" class="Bound">h</a> <a id="10167" href="Lecture7-notes.html#10156" class="Bound">x</a><a id="10168" class="Symbol">)</a> <a id="10170" class="Symbol">(</a><a id="10171" href="Lecture7-notes.html#10152" class="Bound">f</a> <a id="10173" href="Lecture7-notes.html#10156" class="Bound">x</a><a id="10174" class="Symbol">)</a> <a id="10176" href="Lecture7-notes.html#10154" class="Bound">i</a><a id="10177" class="Symbol">)</a>
</pre>
<h1 id="cubical-higher-inductive-types">Cubical higher inductive
types</h1>
<p>We have seen various HITs earlier in the course. These were added
axiomatically to Agda by postulating their existence together with
suitable elimination/induction principles. In Cubical Agda they are
instead added just like any inductive data type, but with path
constructors. This is made possible by the fact that paths in Cubical
Agda are just fancy functions.</p>
<h2 id="the-circle">The circle</h2>
<p>We can define the circle as the following simple data
declaration:</p>
<pre class="Agda"><a id="10675" class="Keyword">data</a> <a id="S¹"></a><a id="10680" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a> <a id="10683" class="Symbol">:</a> <a id="10685" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type₀</a> <a id="10691" class="Keyword">where</a>
  <a id="S¹.base"></a><a id="10699" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a> <a id="10704" class="Symbol">:</a> <a id="10706" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a>
  <a id="S¹.loop"></a><a id="10711" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="10716" class="Symbol">:</a> <a id="10718" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a> <a id="10723" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="10725" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a>
</pre>
<p>We can write functions on <code>S¹</code> using pattern-matching:</p>
<pre class="Agda"><a id="double"></a><a id="10799" href="Lecture7-notes.html#10799" data-type="S¹ → S¹" class="Function">double</a> <a id="10806" class="Symbol">:</a> <a id="10808" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a> <a id="10811" class="Symbol">→</a> <a id="10813" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a>
<a id="10816" href="Lecture7-notes.html#10799" data-type="S¹ → S¹" class="Function">double</a> <a id="10823" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a> <a id="10828" class="Symbol">=</a> <a id="10830" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a>
<a id="10835" href="Lecture7-notes.html#10799" data-type="S¹ → S¹" class="Function">double</a> <a id="10842" class="Symbol">(</a><a id="10843" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="10848" href="Lecture7-notes.html#10848" class="Bound">i</a><a id="10849" class="Symbol">)</a> <a id="10851" class="Symbol">=</a> <a id="10853" class="Symbol">(</a><a id="10854" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="10859" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10861" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a><a id="10865" class="Symbol">)</a> <a id="10867" href="Lecture7-notes.html#10848" class="Bound">i</a>
</pre>
<p>Note that loop takes an <code>i : I</code> argument. This is not very
surprising as it’s a path of type <code>base ≡ base</code>, but it’s an
important difference to Book HoTT where we instead would have to state
the equation using <code>ap</code>. Having the native notion of equality
be heterogeneous makes it possible to quite directly define a general
schema for a large class of HITs and use it in the implementation of a
system like Cubical Agda.</p>
<p>Let’s use univalence to compute some winding numbers on the circle.
We first define a family of types over the circle with fibers being the
integers.</p>
<pre class="Agda"><a id="helix"></a><a id="11454" href="Lecture7-notes.html#11454" data-type="S¹ → Set" class="Function">helix</a> <a id="11460" class="Symbol">:</a> <a id="11462" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a> <a id="11465" class="Symbol">→</a> <a id="11467" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type₀</a>
<a id="11473" href="Lecture7-notes.html#11454" data-type="S¹ → Set" class="Function">helix</a> <a id="11479" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a>     <a id="11488" class="Symbol">=</a> <a id="11490" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a>
<a id="11492" href="Lecture7-notes.html#11454" data-type="S¹ → Set" class="Function">helix</a> <a id="11498" class="Symbol">(</a><a id="11499" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="11504" href="Lecture7-notes.html#11504" class="Bound">i</a><a id="11505" class="Symbol">)</a> <a id="11507" class="Symbol">=</a> <a id="11509" href="cubical-prelude.html#9090" data-type="ℤ ≡ ℤ" class="Function">sucPath</a> <a id="11517" href="Lecture7-notes.html#11504" class="Bound">i</a>
</pre>
<p>Here univalence is baked into <code>sucPath : ℤ ≡ ℤ</code>. The
loopspace of the circle is then defined as</p>
<pre class="Agda"><a id="ΩS¹"></a><a id="11629" href="Lecture7-notes.html#11629" data-type="Set" class="Function">ΩS¹</a> <a id="11633" class="Symbol">:</a> <a id="11635" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type₀</a>
<a id="11641" href="Lecture7-notes.html#11629" data-type="Set" class="Function">ΩS¹</a> <a id="11645" class="Symbol">=</a> <a id="11647" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a> <a id="11652" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11654" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a>
</pre>
<p>and we can then define a function computing how many times we’ve
looped around the circle by:</p>
<pre class="Agda"><a id="winding"></a><a id="11767" href="Lecture7-notes.html#11767" data-type="ΩS¹ → ℤ" class="Function">winding</a> <a id="11775" class="Symbol">:</a> <a id="11777" href="Lecture7-notes.html#11629" data-type="Set" class="Function">ΩS¹</a> <a id="11781" class="Symbol">→</a> <a id="11783" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a>
<a id="11785" href="Lecture7-notes.html#11767" data-type="ΩS¹ → ℤ" class="Function">winding</a> <a id="11793" href="Lecture7-notes.html#11793" class="Bound">p</a> <a id="11795" class="Symbol">=</a> <a id="11797" href="cubical-prelude.html#702" class="Primitive">transp</a> <a id="11804" class="Symbol">(λ</a> <a id="11807" href="Lecture7-notes.html#11807" class="Bound">i</a> <a id="11809" class="Symbol">→</a> <a id="11811" href="Lecture7-notes.html#11454" data-type="S¹ → Set" class="Function">helix</a> <a id="11817" class="Symbol">(</a><a id="11818" href="Lecture7-notes.html#11793" class="Bound">p</a> <a id="11820" href="Lecture7-notes.html#11807" class="Bound">i</a><a id="11821" class="Symbol">))</a> <a id="11824" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a> <a id="11827" class="Symbol">(</a><a id="11828" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="11832" class="Number">0</a><a id="11833" class="Symbol">)</a>
</pre>
<p>Here <code>transp</code> is a cubical transport function. We’ll talk
about it in more detail in the next lecture, but for now we can observe
that it reduces as expected:</p>
<pre class="Agda"><a id="12008" href="Lecture7-notes.html#12008" class="Function">_</a> <a id="12010" class="Symbol">:</a> <a id="12012" href="Lecture7-notes.html#11767" data-type="ΩS¹ → ℤ" class="Function">winding</a> <a id="12020" class="Symbol">(λ</a> <a id="12023" href="Lecture7-notes.html#12023" class="Bound">i</a> <a id="12025" class="Symbol">→</a> <a id="12027" href="Lecture7-notes.html#10799" data-type="S¹ → S¹" class="Function">double</a> <a id="12034" class="Symbol">((</a><a id="12036" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="12041" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12043" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a><a id="12047" class="Symbol">)</a> <a id="12049" href="Lecture7-notes.html#12023" class="Bound">i</a><a id="12050" class="Symbol">))</a> <a id="12053" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="12055" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="12059" class="Number">4</a>
<a id="12061" class="Symbol">_</a> <a id="12063" class="Symbol">=</a> <a id="12065" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>This would not reduce definitionally in Book HoTT as univalence is an
axiom. Having things compute definitionally makes it possible to
substantially simplify many proofs from Book HoTT in Cubical Agda.</p>
<p>We can in fact prove that <code>winding</code> is an equivalence,
this is very similar to the Book HoTT proof and uses the encode-decode
method. For details about how this proof looks in Cubical Agda see the
Cubical.HITs.S1.Base file in the agda/cubical library.</p>
<h2 id="the-torus">The torus</h2>
<p>We can define the torus as:</p>
<pre class="Agda"><a id="12582" class="Keyword">data</a> <a id="Torus"></a><a id="12587" href="Lecture7-notes.html#12587" data-type="Set" class="Datatype">Torus</a> <a id="12593" class="Symbol">:</a> <a id="12595" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type₀</a> <a id="12601" class="Keyword">where</a>
  <a id="Torus.point"></a><a id="12609" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a> <a id="12615" class="Symbol">:</a> <a id="12617" href="Lecture7-notes.html#12587" data-type="Set" class="Datatype">Torus</a>
  <a id="Torus.line1"></a><a id="12625" href="Lecture7-notes.html#12625" data-type="point ≡ point" class="InductiveConstructor">line1</a> <a id="12631" class="Symbol">:</a> <a id="12633" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a> <a id="12639" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="12641" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a>
  <a id="Torus.line2"></a><a id="12649" href="Lecture7-notes.html#12649" data-type="point ≡ point" class="InductiveConstructor">line2</a> <a id="12655" class="Symbol">:</a> <a id="12657" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a> <a id="12663" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="12665" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a>
  <a id="Torus.square"></a><a id="12673" href="Lecture7-notes.html#12673" data-type="PathP (λ i → line1 i ≡ line1 i) line2 line2" class="InductiveConstructor">square</a> <a id="12680" class="Symbol">:</a> <a id="12682" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I → Set ℓ) → A i0 → A i1 → Set ℓ" class="Postulate">PathP</a> <a id="12688" class="Symbol">(λ</a> <a id="12691" href="Lecture7-notes.html#12691" class="Bound">i</a> <a id="12693" class="Symbol">→</a> <a id="12695" href="Lecture7-notes.html#12625" data-type="point ≡ point" class="InductiveConstructor">line1</a> <a id="12701" href="Lecture7-notes.html#12691" class="Bound">i</a> <a id="12703" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="12705" href="Lecture7-notes.html#12625" data-type="point ≡ point" class="InductiveConstructor">line1</a> <a id="12711" href="Lecture7-notes.html#12691" class="Bound">i</a><a id="12712" class="Symbol">)</a> <a id="12714" href="Lecture7-notes.html#12649" data-type="point ≡ point" class="InductiveConstructor">line2</a> <a id="12720" href="Lecture7-notes.html#12649" data-type="point ≡ point" class="InductiveConstructor">line2</a>
</pre>
<p>The square corresponds to the usual folding diagram from topology
(where <code>p</code> is short for <code>point</code>):</p>
<pre class="text"><code>             line1
        p ----------&gt; p
        ^             ^
        ¦             ¦
  line2 ¦             ¦ line2
        ¦             ¦
        p ----------&gt; p
             line1</code></pre>
<p>Proving that it is equivalent to two circles is pretty much trivial
as we have definitional computation rules for all constructors,
including higher ones:</p>
<pre class="Agda"><a id="t2c"></a><a id="13197" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="13201" class="Symbol">:</a> <a id="13203" href="Lecture7-notes.html#12587" data-type="Set" class="Datatype">Torus</a> <a id="13209" class="Symbol">→</a> <a id="13211" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a> <a id="13214" href="cubical-prelude.html#3863" data-type="Set l1 → Set l2 → Set (l1 ⊔ l2)" class="Function Operator">×</a> <a id="13216" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a>
<a id="13219" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="13223" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a>        <a id="13236" class="Symbol">=</a> <a id="13238" class="Symbol">(</a><a id="13239" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a> <a id="13244" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13246" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a><a id="13250" class="Symbol">)</a>
<a id="13252" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="13256" class="Symbol">(</a><a id="13257" href="Lecture7-notes.html#12625" data-type="point ≡ point" class="InductiveConstructor">line1</a> <a id="13263" href="Lecture7-notes.html#13263" class="Bound">i</a><a id="13264" class="Symbol">)</a>    <a id="13269" class="Symbol">=</a> <a id="13271" class="Symbol">(</a><a id="13272" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13277" href="Lecture7-notes.html#13263" class="Bound">i</a> <a id="13279" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13281" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a><a id="13285" class="Symbol">)</a>
<a id="13287" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="13291" class="Symbol">(</a><a id="13292" href="Lecture7-notes.html#12649" data-type="point ≡ point" class="InductiveConstructor">line2</a> <a id="13298" href="Lecture7-notes.html#13298" class="Bound">j</a><a id="13299" class="Symbol">)</a>    <a id="13304" class="Symbol">=</a> <a id="13306" class="Symbol">(</a><a id="13307" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a> <a id="13312" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13314" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13319" href="Lecture7-notes.html#13298" class="Bound">j</a><a id="13320" class="Symbol">)</a>
<a id="13322" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="13326" class="Symbol">(</a><a id="13327" href="Lecture7-notes.html#12673" data-type="PathP (λ i → line1 i ≡ line1 i) line2 line2" class="InductiveConstructor">square</a> <a id="13334" href="Lecture7-notes.html#13334" class="Bound">i</a> <a id="13336" href="Lecture7-notes.html#13336" class="Bound">j</a><a id="13337" class="Symbol">)</a> <a id="13339" class="Symbol">=</a> <a id="13341" class="Symbol">(</a><a id="13342" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13347" href="Lecture7-notes.html#13334" class="Bound">i</a> <a id="13349" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13351" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13356" href="Lecture7-notes.html#13336" class="Bound">j</a><a id="13357" class="Symbol">)</a>

<a id="c2t"></a><a id="13360" href="Lecture7-notes.html#13360" data-type="S¹ × S¹ → Torus" class="Function">c2t</a> <a id="13364" class="Symbol">:</a> <a id="13366" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a> <a id="13369" href="cubical-prelude.html#3863" data-type="Set l1 → Set l2 → Set (l1 ⊔ l2)" class="Function Operator">×</a> <a id="13371" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a> <a id="13374" class="Symbol">→</a> <a id="13376" href="Lecture7-notes.html#12587" data-type="Set" class="Datatype">Torus</a>
<a id="13382" href="Lecture7-notes.html#13360" data-type="S¹ × S¹ → Torus" class="Function">c2t</a> <a id="13386" class="Symbol">(</a><a id="13387" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a>   <a id="13394" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13396" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a><a id="13400" class="Symbol">)</a>   <a id="13404" class="Symbol">=</a> <a id="13406" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a>
<a id="13412" href="Lecture7-notes.html#13360" data-type="S¹ × S¹ → Torus" class="Function">c2t</a> <a id="13416" class="Symbol">(</a><a id="13417" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13422" href="Lecture7-notes.html#13422" class="Bound">i</a> <a id="13424" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13426" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a><a id="13430" class="Symbol">)</a>   <a id="13434" class="Symbol">=</a> <a id="13436" href="Lecture7-notes.html#12625" data-type="point ≡ point" class="InductiveConstructor">line1</a> <a id="13442" href="Lecture7-notes.html#13422" class="Bound">i</a>
<a id="13444" href="Lecture7-notes.html#13360" data-type="S¹ × S¹ → Torus" class="Function">c2t</a> <a id="13448" class="Symbol">(</a><a id="13449" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a>   <a id="13456" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13458" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13463" href="Lecture7-notes.html#13463" class="Bound">j</a><a id="13464" class="Symbol">)</a> <a id="13466" class="Symbol">=</a> <a id="13468" href="Lecture7-notes.html#12649" data-type="point ≡ point" class="InductiveConstructor">line2</a> <a id="13474" href="Lecture7-notes.html#13463" class="Bound">j</a>
<a id="13476" href="Lecture7-notes.html#13360" data-type="S¹ × S¹ → Torus" class="Function">c2t</a> <a id="13480" class="Symbol">(</a><a id="13481" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13486" href="Lecture7-notes.html#13486" class="Bound">i</a> <a id="13488" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13490" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13495" href="Lecture7-notes.html#13495" class="Bound">j</a><a id="13496" class="Symbol">)</a> <a id="13498" class="Symbol">=</a> <a id="13500" href="Lecture7-notes.html#12673" data-type="PathP (λ i → line1 i ≡ line1 i) line2 line2" class="InductiveConstructor">square</a> <a id="13507" href="Lecture7-notes.html#13486" class="Bound">i</a> <a id="13509" href="Lecture7-notes.html#13495" class="Bound">j</a>

<a id="c2t-t2c"></a><a id="13512" href="Lecture7-notes.html#13512" data-type="(t : Torus) → c2t (t2c t) ≡ t" class="Function">c2t-t2c</a> <a id="13520" class="Symbol">:</a> <a id="13522" class="Symbol">(</a><a id="13523" href="Lecture7-notes.html#13523" class="Bound">t</a> <a id="13525" class="Symbol">:</a> <a id="13527" href="Lecture7-notes.html#12587" data-type="Set" class="Datatype">Torus</a><a id="13532" class="Symbol">)</a> <a id="13534" class="Symbol">→</a> <a id="13536" href="Lecture7-notes.html#13360" data-type="S¹ × S¹ → Torus" class="Function">c2t</a> <a id="13540" class="Symbol">(</a><a id="13541" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="13545" href="Lecture7-notes.html#13523" class="Bound">t</a><a id="13546" class="Symbol">)</a> <a id="13548" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="13550" href="Lecture7-notes.html#13523" class="Bound">t</a>
<a id="13552" href="Lecture7-notes.html#13512" data-type="(t : Torus) → c2t (t2c t) ≡ t" class="Function">c2t-t2c</a> <a id="13560" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a>        <a id="13573" class="Symbol">=</a> <a id="13575" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="13580" href="Lecture7-notes.html#13512" data-type="(t : Torus) → c2t (t2c t) ≡ t" class="Function">c2t-t2c</a> <a id="13588" class="Symbol">(</a><a id="13589" href="Lecture7-notes.html#12625" data-type="point ≡ point" class="InductiveConstructor">line1</a> <a id="13595" class="Symbol">_)</a>    <a id="13601" class="Symbol">=</a> <a id="13603" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="13608" href="Lecture7-notes.html#13512" data-type="(t : Torus) → c2t (t2c t) ≡ t" class="Function">c2t-t2c</a> <a id="13616" class="Symbol">(</a><a id="13617" href="Lecture7-notes.html#12649" data-type="point ≡ point" class="InductiveConstructor">line2</a> <a id="13623" class="Symbol">_)</a>    <a id="13629" class="Symbol">=</a> <a id="13631" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="13636" href="Lecture7-notes.html#13512" data-type="(t : Torus) → c2t (t2c t) ≡ t" class="Function">c2t-t2c</a> <a id="13644" class="Symbol">(</a><a id="13645" href="Lecture7-notes.html#12673" data-type="PathP (λ i → line1 i ≡ line1 i) line2 line2" class="InductiveConstructor">square</a> <a id="13652" class="Symbol">_</a> <a id="13654" class="Symbol">_)</a> <a id="13657" class="Symbol">=</a> <a id="13659" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>

<a id="t2c-c2t"></a><a id="13665" href="Lecture7-notes.html#13665" data-type="(p : S¹ × S¹) → t2c (c2t p) ≡ p" class="Function">t2c-c2t</a> <a id="13673" class="Symbol">:</a> <a id="13675" class="Symbol">(</a><a id="13676" href="Lecture7-notes.html#13676" class="Bound">p</a> <a id="13678" class="Symbol">:</a> <a id="13680" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a> <a id="13683" href="cubical-prelude.html#3863" data-type="Set l1 → Set l2 → Set (l1 ⊔ l2)" class="Function Operator">×</a> <a id="13685" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a><a id="13687" class="Symbol">)</a> <a id="13689" class="Symbol">→</a> <a id="13691" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="13695" class="Symbol">(</a><a id="13696" href="Lecture7-notes.html#13360" data-type="S¹ × S¹ → Torus" class="Function">c2t</a> <a id="13700" href="Lecture7-notes.html#13676" class="Bound">p</a><a id="13701" class="Symbol">)</a> <a id="13703" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="13705" href="Lecture7-notes.html#13676" class="Bound">p</a>
<a id="13707" href="Lecture7-notes.html#13665" data-type="(p : S¹ × S¹) → t2c (c2t p) ≡ p" class="Function">t2c-c2t</a> <a id="13715" class="Symbol">(</a><a id="13716" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a>   <a id="13723" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13725" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a><a id="13729" class="Symbol">)</a>   <a id="13733" class="Symbol">=</a> <a id="13735" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="13740" href="Lecture7-notes.html#13665" data-type="(p : S¹ × S¹) → t2c (c2t p) ≡ p" class="Function">t2c-c2t</a> <a id="13748" class="Symbol">(</a><a id="13749" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a>   <a id="13756" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13758" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13763" class="Symbol">_)</a> <a id="13766" class="Symbol">=</a> <a id="13768" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="13773" href="Lecture7-notes.html#13665" data-type="(p : S¹ × S¹) → t2c (c2t p) ≡ p" class="Function">t2c-c2t</a> <a id="13781" class="Symbol">(</a><a id="13782" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13787" class="Symbol">_</a> <a id="13789" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13791" href="Lecture7-notes.html#10699" data-type="S¹" class="InductiveConstructor">base</a><a id="13795" class="Symbol">)</a>   <a id="13799" class="Symbol">=</a> <a id="13801" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="13806" href="Lecture7-notes.html#13665" data-type="(p : S¹ × S¹) → t2c (c2t p) ≡ p" class="Function">t2c-c2t</a> <a id="13814" class="Symbol">(</a><a id="13815" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13820" class="Symbol">_</a> <a id="13822" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13824" href="Lecture7-notes.html#10711" data-type="base ≡ base" class="InductiveConstructor">loop</a> <a id="13829" class="Symbol">_)</a> <a id="13832" class="Symbol">=</a> <a id="13834" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>Using univalence we get the following equality:</p>
<pre class="Agda"><a id="Torus≡S¹×S¹"></a><a id="13901" href="Lecture7-notes.html#13901" data-type="Torus ≡ (S¹ × S¹)" class="Function">Torus≡S¹×S¹</a> <a id="13913" class="Symbol">:</a> <a id="13915" href="Lecture7-notes.html#12587" data-type="Set" class="Datatype">Torus</a> <a id="13921" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="13923" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a> <a id="13926" href="cubical-prelude.html#3863" data-type="Set l1 → Set l2 → Set (l1 ⊔ l2)" class="Function Operator">×</a> <a id="13928" href="Lecture7-notes.html#10680" data-type="Set" class="Datatype">S¹</a>
<a id="13931" href="Lecture7-notes.html#13901" data-type="Torus ≡ (S¹ × S¹)" class="Function">Torus≡S¹×S¹</a> <a id="13943" class="Symbol">=</a> <a id="13945" href="cubical-prelude.html#7917" data-type="Iso A B → A ≡ B" class="Function">isoToPath</a> <a id="13955" class="Symbol">(</a><a id="13956" href="cubical-prelude.html#5514" data-type="(fun : A → B) (inv : B → A) (rightInv : section fun inv)
(leftInv : retract fun inv) →
Iso A B" class="InductiveConstructor">iso</a> <a id="13960" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="13964" href="Lecture7-notes.html#13360" data-type="S¹ × S¹ → Torus" class="Function">c2t</a> <a id="13968" href="Lecture7-notes.html#13665" data-type="(p : S¹ × S¹) → t2c (c2t p) ≡ p" class="Function">t2c-c2t</a> <a id="13976" href="Lecture7-notes.html#13512" data-type="(t : Torus) → c2t (t2c t) ≡ t" class="Function">c2t-t2c</a><a id="13983" class="Symbol">)</a>
</pre>
<p>We can also directly compute winding numbers on the torus</p>
<pre class="Agda"><a id="windingTorus"></a><a id="14057" href="Lecture7-notes.html#14057" data-type="point ≡ point → ℤ × ℤ" class="Function">windingTorus</a> <a id="14070" class="Symbol">:</a> <a id="14072" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a> <a id="14078" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="14080" href="Lecture7-notes.html#12609" data-type="Torus" class="InductiveConstructor">point</a> <a id="14086" class="Symbol">→</a> <a id="14088" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a> <a id="14090" href="cubical-prelude.html#3863" data-type="Set l1 → Set l2 → Set (l1 ⊔ l2)" class="Function Operator">×</a> <a id="14092" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a>
<a id="14094" href="Lecture7-notes.html#14057" data-type="point ≡ point → ℤ × ℤ" class="Function">windingTorus</a> <a id="14107" href="Lecture7-notes.html#14107" class="Bound">l</a> <a id="14109" class="Symbol">=</a> <a id="14111" class="Symbol">(</a> <a id="14113" href="Lecture7-notes.html#11767" data-type="ΩS¹ → ℤ" class="Function">winding</a> <a id="14121" class="Symbol">(λ</a> <a id="14124" href="Lecture7-notes.html#14124" class="Bound">i</a> <a id="14126" class="Symbol">→</a> <a id="14128" href="cubical-prelude.html#3676" class="Field">pr₁</a> <a id="14132" class="Symbol">(</a><a id="14133" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="14137" class="Symbol">(</a><a id="14138" href="Lecture7-notes.html#14107" class="Bound">l</a> <a id="14140" href="Lecture7-notes.html#14124" class="Bound">i</a><a id="14141" class="Symbol">)))</a>
                 <a id="14162" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="14164" href="Lecture7-notes.html#11767" data-type="ΩS¹ → ℤ" class="Function">winding</a> <a id="14172" class="Symbol">(λ</a> <a id="14175" href="Lecture7-notes.html#14175" class="Bound">i</a> <a id="14177" class="Symbol">→</a> <a id="14179" href="cubical-prelude.html#3689" class="Field">pr₂</a> <a id="14183" class="Symbol">(</a><a id="14184" href="Lecture7-notes.html#13197" data-type="Torus → S¹ × S¹" class="Function">t2c</a> <a id="14188" class="Symbol">(</a><a id="14189" href="Lecture7-notes.html#14107" class="Bound">l</a> <a id="14191" href="Lecture7-notes.html#14175" class="Bound">i</a><a id="14192" class="Symbol">))))</a>

<a id="14198" href="Lecture7-notes.html#14198" class="Function">_</a> <a id="14200" class="Symbol">:</a> <a id="14202" href="Lecture7-notes.html#14057" data-type="point ≡ point → ℤ × ℤ" class="Function">windingTorus</a> <a id="14215" class="Symbol">(</a><a id="14216" href="Lecture7-notes.html#12625" data-type="point ≡ point" class="InductiveConstructor">line1</a> <a id="14222" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14224" href="Lecture7-notes.html#6920" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14228" href="Lecture7-notes.html#12649" data-type="point ≡ point" class="InductiveConstructor">line2</a><a id="14233" class="Symbol">)</a> <a id="14235" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="14237" class="Symbol">(</a><a id="14238" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="14242" class="Number">1</a> <a id="14244" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="14246" href="cubical-prelude.html#8514" data-type="ℕ → ℤ" class="InductiveConstructor">negsuc</a> <a id="14253" class="Number">0</a><a id="14254" class="Symbol">)</a>
<a id="14256" class="Symbol">_</a> <a id="14258" class="Symbol">=</a> <a id="14260" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
</pre>
<h1 id="bonus-content-if-there-is-time">Bonus content if there is
time</h1>
<h2 id="interval">Interval</h2>
<pre class="Agda"><a id="14325" class="Keyword">data</a> <a id="Interval"></a><a id="14330" href="Lecture7-notes.html#14330" data-type="Set" class="Datatype">Interval</a> <a id="14339" class="Symbol">:</a> <a id="14341" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type₀</a> <a id="14347" class="Keyword">where</a>
  <a id="Interval.zero"></a><a id="14355" href="Lecture7-notes.html#14355" data-type="Interval" class="InductiveConstructor">zero</a> <a id="14360" class="Symbol">:</a> <a id="14362" href="Lecture7-notes.html#14330" data-type="Set" class="Datatype">Interval</a>
  <a id="Interval.one"></a><a id="14373" href="Lecture7-notes.html#14373" data-type="Interval" class="InductiveConstructor">one</a>  <a id="14378" class="Symbol">:</a> <a id="14380" href="Lecture7-notes.html#14330" data-type="Set" class="Datatype">Interval</a>
  <a id="Interval.seg"></a><a id="14391" href="Lecture7-notes.html#14391" data-type="zero ≡ one" class="InductiveConstructor">seg</a>  <a id="14396" class="Symbol">:</a> <a id="14398" href="Lecture7-notes.html#14355" data-type="Interval" class="InductiveConstructor">zero</a> <a id="14403" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="14405" href="Lecture7-notes.html#14373" data-type="Interval" class="InductiveConstructor">one</a>
</pre>
<h2 id="suspension">Suspension</h2>
<pre class="Agda"><a id="14437" class="Keyword">data</a> <a id="Susp"></a><a id="14442" href="Lecture7-notes.html#14442" data-type="Set ℓ → Set ℓ" class="Datatype">Susp</a> <a id="14447" class="Symbol">(</a><a id="14448" href="Lecture7-notes.html#14448" class="Bound">A</a> <a id="14450" class="Symbol">:</a> <a id="14452" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="14457" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="14458" class="Symbol">)</a> <a id="14460" class="Symbol">:</a> <a id="14462" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="14467" href="Lecture7-notes.html#14457" class="Bound">ℓ</a> <a id="14469" class="Keyword">where</a>
  <a id="Susp.north"></a><a id="14477" href="Lecture7-notes.html#14477" data-type="Susp A" class="InductiveConstructor">north</a> <a id="14483" class="Symbol">:</a> <a id="14485" href="Lecture7-notes.html#14442" data-type="Set ℓ → Set ℓ" class="Datatype">Susp</a> <a id="14490" href="Lecture7-notes.html#14448" class="Bound">A</a>
  <a id="Susp.south"></a><a id="14494" href="Lecture7-notes.html#14494" data-type="Susp A" class="InductiveConstructor">south</a> <a id="14500" class="Symbol">:</a> <a id="14502" href="Lecture7-notes.html#14442" data-type="Set ℓ → Set ℓ" class="Datatype">Susp</a> <a id="14507" href="Lecture7-notes.html#14448" class="Bound">A</a>
  <a id="Susp.merid"></a><a id="14511" href="Lecture7-notes.html#14511" data-type="(a : A) → north ≡ south" class="InductiveConstructor">merid</a> <a id="14517" class="Symbol">:</a> <a id="14519" class="Symbol">(</a><a id="14520" href="Lecture7-notes.html#14520" class="Bound">a</a> <a id="14522" class="Symbol">:</a> <a id="14524" href="Lecture7-notes.html#14448" class="Bound">A</a><a id="14525" class="Symbol">)</a> <a id="14527" class="Symbol">→</a> <a id="14529" href="Lecture7-notes.html#14477" data-type="Susp A" class="InductiveConstructor">north</a> <a id="14535" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="14537" href="Lecture7-notes.html#14494" data-type="Susp A" class="InductiveConstructor">south</a>
</pre>
<p>We can define Dan’s Circle2 as the suspension of Bool, or we can do
it directly as:</p>
<pre class="Agda"><a id="14641" class="Keyword">data</a> <a id="Circle2"></a><a id="14646" href="Lecture7-notes.html#14646" data-type="Set" class="Datatype">Circle2</a> <a id="14654" class="Symbol">:</a> <a id="14656" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type₀</a> <a id="14662" class="Keyword">where</a>
  <a id="Circle2.north"></a><a id="14670" href="Lecture7-notes.html#14670" data-type="Circle2" class="InductiveConstructor">north</a> <a id="14676" class="Symbol">:</a> <a id="14678" href="Lecture7-notes.html#14646" data-type="Set" class="Datatype">Circle2</a>
  <a id="Circle2.south"></a><a id="14688" href="Lecture7-notes.html#14688" data-type="Circle2" class="InductiveConstructor">south</a> <a id="14694" class="Symbol">:</a> <a id="14696" href="Lecture7-notes.html#14646" data-type="Set" class="Datatype">Circle2</a>
  <a id="Circle2.west"></a><a id="14706" href="Lecture7-notes.html#14706" data-type="north ≡ south" class="InductiveConstructor">west</a>  <a id="14712" class="Symbol">:</a> <a id="14714" href="Lecture7-notes.html#14670" data-type="Circle2" class="InductiveConstructor">north</a> <a id="14720" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="14722" href="Lecture7-notes.html#14688" data-type="Circle2" class="InductiveConstructor">south</a>
  <a id="Circle2.east"></a><a id="14730" href="Lecture7-notes.html#14730" data-type="north ≡ south" class="InductiveConstructor">east</a>  <a id="14736" class="Symbol">:</a> <a id="14738" href="Lecture7-notes.html#14670" data-type="Circle2" class="InductiveConstructor">north</a> <a id="14744" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="14746" href="Lecture7-notes.html#14688" data-type="Circle2" class="InductiveConstructor">south</a>
</pre>
<h2 id="pushouts">Pushouts</h2>
<pre class="Agda"><a id="14778" class="Keyword">data</a> <a id="Pushout"></a><a id="14783" href="Lecture7-notes.html#14783" data-type="(A → B) → (A → C) → Set (ℓ ⊔ ℓ&#39; ⊔ ℓ&#39;&#39;)" class="Datatype">Pushout</a> <a id="14791" class="Symbol">{</a><a id="14792" href="Lecture7-notes.html#14792" class="Bound">ℓ</a> <a id="14794" href="Lecture7-notes.html#14794" class="Bound">ℓ&#39;</a> <a id="14797" href="Lecture7-notes.html#14797" class="Bound">ℓ&#39;&#39;</a><a id="14800" class="Symbol">}</a> <a id="14802" class="Symbol">{</a><a id="14803" href="Lecture7-notes.html#14803" class="Bound">A</a> <a id="14805" class="Symbol">:</a> <a id="14807" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="14812" href="Lecture7-notes.html#14792" class="Bound">ℓ</a><a id="14813" class="Symbol">}</a> <a id="14815" class="Symbol">{</a><a id="14816" href="Lecture7-notes.html#14816" class="Bound">B</a> <a id="14818" class="Symbol">:</a> <a id="14820" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="14825" href="Lecture7-notes.html#14794" class="Bound">ℓ&#39;</a><a id="14827" class="Symbol">}</a> <a id="14829" class="Symbol">{</a><a id="14830" href="Lecture7-notes.html#14830" class="Bound">C</a> <a id="14832" class="Symbol">:</a> <a id="14834" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="14839" href="Lecture7-notes.html#14797" class="Bound">ℓ&#39;&#39;</a><a id="14842" class="Symbol">}</a>
             <a id="14857" class="Symbol">(</a><a id="14858" href="Lecture7-notes.html#14858" class="Bound">f</a> <a id="14860" class="Symbol">:</a> <a id="14862" href="Lecture7-notes.html#14803" class="Bound">A</a> <a id="14864" class="Symbol">→</a> <a id="14866" href="Lecture7-notes.html#14816" class="Bound">B</a><a id="14867" class="Symbol">)</a> <a id="14869" class="Symbol">(</a><a id="14870" href="Lecture7-notes.html#14870" class="Bound">g</a> <a id="14872" class="Symbol">:</a> <a id="14874" href="Lecture7-notes.html#14803" class="Bound">A</a> <a id="14876" class="Symbol">→</a> <a id="14878" href="Lecture7-notes.html#14830" class="Bound">C</a><a id="14879" class="Symbol">)</a> <a id="14881" class="Symbol">:</a> <a id="14883" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="14888" class="Symbol">(</a><a id="14889" href="Lecture7-notes.html#14792" class="Bound">ℓ</a> <a id="14891" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="14893" href="Lecture7-notes.html#14794" class="Bound">ℓ&#39;</a> <a id="14896" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="14898" href="Lecture7-notes.html#14797" class="Bound">ℓ&#39;&#39;</a><a id="14901" class="Symbol">)</a> <a id="14903" class="Keyword">where</a>
  <a id="Pushout.inl"></a><a id="14911" href="Lecture7-notes.html#14911" data-type="B → Pushout f g" class="InductiveConstructor">inl</a> <a id="14915" class="Symbol">:</a> <a id="14917" href="Lecture7-notes.html#14816" class="Bound">B</a> <a id="14919" class="Symbol">→</a> <a id="14921" href="Lecture7-notes.html#14783" data-type="(A → B) → (A → C) → Set (ℓ ⊔ ℓ&#39; ⊔ ℓ&#39;&#39;)" class="Datatype">Pushout</a> <a id="14929" href="Lecture7-notes.html#14858" class="Bound">f</a> <a id="14931" href="Lecture7-notes.html#14870" class="Bound">g</a>
  <a id="Pushout.inr"></a><a id="14935" href="Lecture7-notes.html#14935" data-type="C → Pushout f g" class="InductiveConstructor">inr</a> <a id="14939" class="Symbol">:</a> <a id="14941" href="Lecture7-notes.html#14830" class="Bound">C</a> <a id="14943" class="Symbol">→</a> <a id="14945" href="Lecture7-notes.html#14783" data-type="(A → B) → (A → C) → Set (ℓ ⊔ ℓ&#39; ⊔ ℓ&#39;&#39;)" class="Datatype">Pushout</a> <a id="14953" href="Lecture7-notes.html#14858" class="Bound">f</a> <a id="14955" href="Lecture7-notes.html#14870" class="Bound">g</a>
  <a id="Pushout.push"></a><a id="14959" href="Lecture7-notes.html#14959" data-type="(a : A) → inl (f a) ≡ inr (g a)" class="InductiveConstructor">push</a> <a id="14964" class="Symbol">:</a> <a id="14966" class="Symbol">(</a><a id="14967" href="Lecture7-notes.html#14967" class="Bound">a</a> <a id="14969" class="Symbol">:</a> <a id="14971" href="Lecture7-notes.html#14803" class="Bound">A</a><a id="14972" class="Symbol">)</a> <a id="14974" class="Symbol">→</a> <a id="14976" href="Lecture7-notes.html#14911" data-type="B → Pushout f g" class="InductiveConstructor">inl</a> <a id="14980" class="Symbol">(</a><a id="14981" href="Lecture7-notes.html#14858" class="Bound">f</a> <a id="14983" href="Lecture7-notes.html#14967" class="Bound">a</a><a id="14984" class="Symbol">)</a> <a id="14986" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="14988" href="Lecture7-notes.html#14935" data-type="C → Pushout f g" class="InductiveConstructor">inr</a> <a id="14992" class="Symbol">(</a><a id="14993" href="Lecture7-notes.html#14870" class="Bound">g</a> <a id="14995" href="Lecture7-notes.html#14967" class="Bound">a</a><a id="14996" class="Symbol">)</a>
</pre>
<h2 id="relation-quotient">Relation quotient</h2>
<pre class="Agda"><a id="15033" class="Keyword">data</a> <a id="_/ₜ_"></a><a id="15038" href="Lecture7-notes.html#15038" data-type="(A : Set ℓ) → (A → A → Set ℓ&#39;) → Set (ℓ ⊔ ℓ&#39;)" class="Datatype Operator">_/ₜ_</a> <a id="15043" class="Symbol">{</a><a id="15044" href="Lecture7-notes.html#15044" class="Bound">ℓ</a> <a id="15046" href="Lecture7-notes.html#15046" class="Bound">ℓ&#39;</a><a id="15048" class="Symbol">}</a> <a id="15050" class="Symbol">(</a><a id="15051" href="Lecture7-notes.html#15051" class="Bound">A</a> <a id="15053" class="Symbol">:</a> <a id="15055" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="15060" href="Lecture7-notes.html#15044" class="Bound">ℓ</a><a id="15061" class="Symbol">)</a> <a id="15063" class="Symbol">(</a><a id="15064" href="Lecture7-notes.html#15064" class="Bound">R</a> <a id="15066" class="Symbol">:</a> <a id="15068" href="Lecture7-notes.html#15051" class="Bound">A</a> <a id="15070" class="Symbol">→</a> <a id="15072" href="Lecture7-notes.html#15051" class="Bound">A</a> <a id="15074" class="Symbol">→</a> <a id="15076" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="15081" href="Lecture7-notes.html#15046" class="Bound">ℓ&#39;</a><a id="15083" class="Symbol">)</a> <a id="15085" class="Symbol">:</a> <a id="15087" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="15092" class="Symbol">(</a><a id="15093" href="Lecture7-notes.html#15044" class="Bound">ℓ</a> <a id="15095" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="15097" href="Lecture7-notes.html#15046" class="Bound">ℓ&#39;</a><a id="15099" class="Symbol">)</a> <a id="15101" class="Keyword">where</a>
  <a id="_/ₜ_.[_]"></a><a id="15109" href="Lecture7-notes.html#15109" data-type="A → A /ₜ R" class="InductiveConstructor Operator">[_]</a> <a id="15113" class="Symbol">:</a> <a id="15115" class="Symbol">(</a><a id="15116" href="Lecture7-notes.html#15116" class="Bound">a</a> <a id="15118" class="Symbol">:</a> <a id="15120" href="Lecture7-notes.html#15051" class="Bound">A</a><a id="15121" class="Symbol">)</a> <a id="15123" class="Symbol">→</a> <a id="15125" href="Lecture7-notes.html#15051" class="Bound">A</a> <a id="15127" href="Lecture7-notes.html#15038" data-type="(A : Set ℓ) → (A → A → Set ℓ&#39;) → Set (ℓ ⊔ ℓ&#39;)" class="Datatype Operator">/ₜ</a> <a id="15130" href="Lecture7-notes.html#15064" class="Bound">R</a>
  <a id="_/ₜ_.eq/"></a><a id="15134" href="Lecture7-notes.html#15134" data-type="(a b : A) (r : R a b) → [ a ] ≡ [ b ]" class="InductiveConstructor">eq/</a> <a id="15138" class="Symbol">:</a> <a id="15140" class="Symbol">(</a><a id="15141" href="Lecture7-notes.html#15141" class="Bound">a</a> <a id="15143" href="Lecture7-notes.html#15143" class="Bound">b</a> <a id="15145" class="Symbol">:</a> <a id="15147" href="Lecture7-notes.html#15051" class="Bound">A</a><a id="15148" class="Symbol">)</a> <a id="15150" class="Symbol">→</a> <a id="15152" class="Symbol">(</a><a id="15153" href="Lecture7-notes.html#15153" class="Bound">r</a> <a id="15155" class="Symbol">:</a> <a id="15157" href="Lecture7-notes.html#15064" class="Bound">R</a> <a id="15159" href="Lecture7-notes.html#15141" class="Bound">a</a> <a id="15161" href="Lecture7-notes.html#15143" class="Bound">b</a><a id="15162" class="Symbol">)</a> <a id="15164" class="Symbol">→</a> <a id="15166" href="Lecture7-notes.html#15109" data-type="A → A /ₜ R" class="InductiveConstructor Operator">[</a> <a id="15168" href="Lecture7-notes.html#15141" class="Bound">a</a> <a id="15170" href="Lecture7-notes.html#15109" data-type="A → A /ₜ R" class="InductiveConstructor Operator">]</a> <a id="15172" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="15174" href="Lecture7-notes.html#15109" data-type="A → A /ₜ R" class="InductiveConstructor Operator">[</a> <a id="15176" href="Lecture7-notes.html#15143" class="Bound">b</a> <a id="15178" href="Lecture7-notes.html#15109" data-type="A → A /ₜ R" class="InductiveConstructor Operator">]</a>
</pre>
<h2 id="propositional-truncation">Propositional truncation</h2>
<pre class="Agda"><a id="15222" class="Keyword">data</a> <a id="∥_∥₋₁"></a><a id="15227" href="Lecture7-notes.html#15227" data-type="Set ℓ → Set ℓ" class="Datatype Operator">∥_∥₋₁</a> <a id="15233" class="Symbol">{</a><a id="15234" href="Lecture7-notes.html#15234" class="Bound">ℓ</a><a id="15235" class="Symbol">}</a> <a id="15237" class="Symbol">(</a><a id="15238" href="Lecture7-notes.html#15238" class="Bound">A</a> <a id="15240" class="Symbol">:</a> <a id="15242" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="15247" href="Lecture7-notes.html#15234" class="Bound">ℓ</a><a id="15248" class="Symbol">)</a> <a id="15250" class="Symbol">:</a> <a id="15252" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="15257" href="Lecture7-notes.html#15234" class="Bound">ℓ</a> <a id="15259" class="Keyword">where</a>
  <a id="∥_∥₋₁.∣_∣₋₁"></a><a id="15267" href="Lecture7-notes.html#15267" data-type="A → ∥ A ∥₋₁" class="InductiveConstructor Operator">∣_∣₋₁</a> <a id="15273" class="Symbol">:</a> <a id="15275" href="Lecture7-notes.html#15238" class="Bound">A</a> <a id="15277" class="Symbol">→</a> <a id="15279" href="Lecture7-notes.html#15227" data-type="Set ℓ → Set ℓ" class="Datatype Operator">∥</a> <a id="15281" href="Lecture7-notes.html#15238" class="Bound">A</a> <a id="15283" href="Lecture7-notes.html#15227" data-type="Set ℓ → Set ℓ" class="Datatype Operator">∥₋₁</a>
  <a id="∥_∥₋₁.squash₁"></a><a id="15289" href="Lecture7-notes.html#15289" data-type="(x y : ∥ A ∥₋₁) → x ≡ y" class="InductiveConstructor">squash₁</a> <a id="15297" class="Symbol">:</a> <a id="15299" class="Symbol">(</a><a id="15300" href="Lecture7-notes.html#15300" class="Bound">x</a> <a id="15302" href="Lecture7-notes.html#15302" class="Bound">y</a> <a id="15304" class="Symbol">:</a> <a id="15306" href="Lecture7-notes.html#15227" data-type="Set ℓ → Set ℓ" class="Datatype Operator">∥</a> <a id="15308" href="Lecture7-notes.html#15238" class="Bound">A</a> <a id="15310" href="Lecture7-notes.html#15227" data-type="Set ℓ → Set ℓ" class="Datatype Operator">∥₋₁</a><a id="15313" class="Symbol">)</a> <a id="15315" class="Symbol">→</a> <a id="15317" href="Lecture7-notes.html#15300" class="Bound">x</a> <a id="15319" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="15321" href="Lecture7-notes.html#15302" class="Bound">y</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em;
    border: 1px solid black; }
  table th {
    border-bottom: 2px solid black; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
