<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<h1 id="week-03---agda-exercises">Week 03 - Agda Exercises</h1>
<h2 id="please-read-before-starting-the-exercises">Please read before
starting the exercises</h2>
<p><strong>The exercises are designed to increase in difficulty so that
we can cater to our large and diverse audience. This also means that it
is <em>perfectly fine</em> if you don’t manage to do all exercises: some
of them are definitely a bit hard for beginners and there are likely too
many exercises! You <em>may</em> wish to come back to them later when
you have learned more.</strong></p>
<p>Having said that, here we go!</p>
<p>This is a markdown file with Agda code, which means that it displays
nicely on GitHub, but at the same time you can load this file in Agda
and fill the holes to solve exercises.</p>
<p><strong>Please make a copy of this file to work in, so that it
doesn’t get overwritten (in case we update the exercises through
<code>git</code>)!</strong></p>
<pre class="Agda"><a id="791" class="Symbol">{-#</a> <a id="795" class="Keyword">OPTIONS</a> <a id="803" class="Pragma">--without-K</a> <a id="815" class="Pragma">--allow-unsolved-metas</a> <a id="838" class="Symbol">#-}</a>

<a id="843" class="Keyword">module</a> <a id="850" href="03-Exercises.html" class="Module">03-Exercises</a> <a id="863" class="Keyword">where</a>

<a id="870" class="Keyword">open</a> <a id="875" class="Keyword">import</a> <a id="882" href="prelude.html" class="Module">prelude</a> <a id="890" class="Keyword">hiding</a> <a id="897" class="Symbol">(</a><a id="898" href="identity-type.html#3258" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">_∼_</a><a id="901" class="Symbol">)</a>
</pre>
<h2 id="part-i-homotopies">Part I – Homotopies</h2>
It is often convenient to work with <em>pointwise equality</em> of
functions, defined as follows.
<pre class="Agda"><a id="1032" class="Keyword">module</a> <a id="1039" href="03-Exercises.html#1039" class="Module">_</a> <a id="1041" class="Symbol">{</a><a id="1042" href="03-Exercises.html#1042" class="Bound">A</a> <a id="1044" class="Symbol">:</a> <a id="1046" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="1050" class="Symbol">}</a> <a id="1052" class="Symbol">{</a><a id="1053" href="03-Exercises.html#1053" class="Bound">B</a> <a id="1055" class="Symbol">:</a> <a id="1057" href="03-Exercises.html#1042" class="Bound">A</a> <a id="1059" class="Symbol">→</a> <a id="1061" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="1065" class="Symbol">}</a> <a id="1067" class="Keyword">where</a>
  <a id="1075" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">_∼_</a> <a id="1079" class="Symbol">:</a> <a id="1081" class="Symbol">((</a><a id="1083" href="03-Exercises.html#1083" class="Bound">x</a> <a id="1085" class="Symbol">:</a> <a id="1087" href="03-Exercises.html#1042" class="Bound">A</a><a id="1088" class="Symbol">)</a> <a id="1090" class="Symbol">→</a> <a id="1092" href="03-Exercises.html#1053" class="Bound">B</a> <a id="1094" href="03-Exercises.html#1083" class="Bound">x</a><a id="1095" class="Symbol">)</a> <a id="1097" class="Symbol">→</a> <a id="1099" class="Symbol">((</a><a id="1101" href="03-Exercises.html#1101" class="Bound">x</a> <a id="1103" class="Symbol">:</a> <a id="1105" href="03-Exercises.html#1042" class="Bound">A</a><a id="1106" class="Symbol">)</a> <a id="1108" class="Symbol">→</a> <a id="1110" href="03-Exercises.html#1053" class="Bound">B</a> <a id="1112" href="03-Exercises.html#1101" class="Bound">x</a><a id="1113" class="Symbol">)</a> <a id="1115" class="Symbol">→</a> <a id="1117" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a>
  <a id="1124" href="03-Exercises.html#1124" class="Bound">f</a> <a id="1126" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="1128" href="03-Exercises.html#1128" class="Bound">g</a> <a id="1130" class="Symbol">=</a> <a id="1132" class="Symbol">∀</a> <a id="1134" href="03-Exercises.html#1134" class="Bound">x</a> <a id="1136" class="Symbol">→</a> <a id="1138" href="03-Exercises.html#1124" class="Bound">f</a> <a id="1140" href="03-Exercises.html#1134" class="Bound">x</a> <a id="1142" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="1144" href="03-Exercises.html#1128" class="Bound">g</a> <a id="1146" href="03-Exercises.html#1134" class="Bound">x</a>
</pre>
<p>An element of <code>f ∼ g</code> is usually called a homotopy.</p>
<h3 id="exercise-1">Exercise 1 (⋆⋆)</h3>
<p>Unsurprisingly, many properties of this type of pointwise equalities
can be inferred directly from the same operations on paths.</p>
Try to prove reflexivity, symmetry and transitivity of <code>_∼_</code>
by filling these holes.
<pre class="Agda">  <a id="1451" href="03-Exercises.html#1451" data-type="(f : (x : A) → B x) → f 03-Exercises.∼ f" class="Function">∼-refl</a> <a id="1458" class="Symbol">:</a> <a id="1460" class="Symbol">(</a><a id="1461" href="03-Exercises.html#1461" class="Bound">f</a> <a id="1463" class="Symbol">:</a> <a id="1465" class="Symbol">(</a><a id="1466" href="03-Exercises.html#1466" class="Bound">x</a> <a id="1468" class="Symbol">:</a> <a id="1470" href="03-Exercises.html#1042" class="Bound">A</a><a id="1471" class="Symbol">)</a> <a id="1473" class="Symbol">→</a> <a id="1475" href="03-Exercises.html#1053" class="Bound">B</a> <a id="1477" href="03-Exercises.html#1466" class="Bound">x</a><a id="1478" class="Symbol">)</a> <a id="1480" class="Symbol">→</a> <a id="1482" href="03-Exercises.html#1461" class="Bound">f</a> <a id="1484" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="1486" href="03-Exercises.html#1461" class="Bound">f</a>
  <a id="1490" href="03-Exercises.html#1451" data-type="(f : (x : A) → B x) → f 03-Exercises.∼ f" class="Function">∼-refl</a> <a id="1497" href="03-Exercises.html#1497" class="Bound">f</a> <a id="1499" class="Symbol">=</a> <a id="1501" class="Hole">{!!}</a>

  <a id="1509" href="03-Exercises.html#1509" data-type="(f g : (x : A) → B x) → f 03-Exercises.∼ g → g 03-Exercises.∼ f" class="Function">∼-inv</a> <a id="1515" class="Symbol">:</a> <a id="1517" class="Symbol">(</a><a id="1518" href="03-Exercises.html#1518" class="Bound">f</a> <a id="1520" href="03-Exercises.html#1520" class="Bound">g</a> <a id="1522" class="Symbol">:</a> <a id="1524" class="Symbol">(</a><a id="1525" href="03-Exercises.html#1525" class="Bound">x</a> <a id="1527" class="Symbol">:</a> <a id="1529" href="03-Exercises.html#1042" class="Bound">A</a><a id="1530" class="Symbol">)</a> <a id="1532" class="Symbol">→</a> <a id="1534" href="03-Exercises.html#1053" class="Bound">B</a> <a id="1536" href="03-Exercises.html#1525" class="Bound">x</a><a id="1537" class="Symbol">)</a> <a id="1539" class="Symbol">→</a> <a id="1541" class="Symbol">(</a><a id="1542" href="03-Exercises.html#1518" class="Bound">f</a> <a id="1544" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="1546" href="03-Exercises.html#1520" class="Bound">g</a><a id="1547" class="Symbol">)</a> <a id="1549" class="Symbol">→</a> <a id="1551" class="Symbol">(</a><a id="1552" href="03-Exercises.html#1520" class="Bound">g</a> <a id="1554" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="1556" href="03-Exercises.html#1518" class="Bound">f</a><a id="1557" class="Symbol">)</a>
  <a id="1561" href="03-Exercises.html#1509" data-type="(f g : (x : A) → B x) → f 03-Exercises.∼ g → g 03-Exercises.∼ f" class="Function">∼-inv</a> <a id="1567" href="03-Exercises.html#1567" class="Bound">f</a> <a id="1569" href="03-Exercises.html#1569" class="Bound">g</a> <a id="1571" href="03-Exercises.html#1571" class="Bound">H</a> <a id="1573" href="03-Exercises.html#1573" class="Bound">x</a> <a id="1575" class="Symbol">=</a> <a id="1577" class="Hole">{!!}</a>

  <a id="1585" href="03-Exercises.html#1585" data-type="(f g h : (x : A) → B x) →
f 03-Exercises.∼ g → g 03-Exercises.∼ h → f 03-Exercises.∼ h" class="Function">∼-concat</a> <a id="1594" class="Symbol">:</a> <a id="1596" class="Symbol">(</a><a id="1597" href="03-Exercises.html#1597" class="Bound">f</a> <a id="1599" href="03-Exercises.html#1599" class="Bound">g</a> <a id="1601" href="03-Exercises.html#1601" class="Bound">h</a> <a id="1603" class="Symbol">:</a> <a id="1605" class="Symbol">(</a><a id="1606" href="03-Exercises.html#1606" class="Bound">x</a> <a id="1608" class="Symbol">:</a> <a id="1610" href="03-Exercises.html#1042" class="Bound">A</a><a id="1611" class="Symbol">)</a> <a id="1613" class="Symbol">→</a> <a id="1615" href="03-Exercises.html#1053" class="Bound">B</a> <a id="1617" href="03-Exercises.html#1606" class="Bound">x</a><a id="1618" class="Symbol">)</a> <a id="1620" class="Symbol">→</a> <a id="1622" href="03-Exercises.html#1597" class="Bound">f</a> <a id="1624" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="1626" href="03-Exercises.html#1599" class="Bound">g</a> <a id="1628" class="Symbol">→</a> <a id="1630" href="03-Exercises.html#1599" class="Bound">g</a> <a id="1632" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="1634" href="03-Exercises.html#1601" class="Bound">h</a> <a id="1636" class="Symbol">→</a> <a id="1638" href="03-Exercises.html#1597" class="Bound">f</a> <a id="1640" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="1642" href="03-Exercises.html#1601" class="Bound">h</a>
  <a id="1646" href="03-Exercises.html#1585" data-type="(f g h : (x : A) → B x) →
f 03-Exercises.∼ g → g 03-Exercises.∼ h → f 03-Exercises.∼ h" class="Function">∼-concat</a> <a id="1655" href="03-Exercises.html#1655" class="Bound">f</a> <a id="1657" href="03-Exercises.html#1657" class="Bound">g</a> <a id="1659" href="03-Exercises.html#1659" class="Bound">h</a> <a id="1661" href="03-Exercises.html#1661" class="Bound">H</a> <a id="1663" href="03-Exercises.html#1663" class="Bound">K</a> <a id="1665" href="03-Exercises.html#1665" class="Bound">x</a> <a id="1667" class="Symbol">=</a> <a id="1669" class="Hole">{!!}</a>

  <a id="1677" class="Keyword">infix</a> <a id="1683" class="Number">0</a> <a id="1685" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">_∼_</a>
</pre>
<h2 id="part-ii-isomorphisms">Part II – Isomorphisms</h2>
<p>A function <code>f : A → B</code> is called a <em>bijection</em> if
there is a function <code>g : B → A</code> in the opposite direction
such that <code>g ∘ f ∼ id</code> and <code>f ∘ g ∼ id</code>. Recall
that <code>_∼_</code> is <a href="identity-type.html">pointwise
equality</a> and that <code>id</code> is the <a
href="products.html">identity function</a>. This means that we can
convert back and forth between the types <code>A</code> and
<code>B</code> landing at the same element we started with, either from
<code>A</code> or from <code>B</code>. In this case, we say that the
types <code>A</code> and <code>B</code> are <em>isomorphic</em>, and we
write <code>A ≅ B</code>. Bijections are also called type
<em>isomorphisms</em>. We can define these concepts in Agda using <a
href="sums.html">sum types</a> or <a
href="https://agda.readthedocs.io/en/latest/language/record-types.html">records</a>.
We will adopt the latter, but we include both definitions for the sake
of illustration. Recall that we <a
href="general-notation.html">defined</a> the domain of a function
<code>f : A → B</code> to be <code>A</code> and its codomain to be
<code>B</code>.</p>
We adopt this definition of isomorphisms using records.
<pre class="Agda"><a id="2806" class="Keyword">record</a> <a id="is-bijection"></a><a id="2813" href="03-Exercises.html#2813" data-type="(f : A → B) → general-notation.Type" class="Record">is-bijection</a> <a id="2826" class="Symbol">{</a><a id="2827" href="03-Exercises.html#2827" class="Bound">A</a> <a id="2829" href="03-Exercises.html#2829" class="Bound">B</a> <a id="2831" class="Symbol">:</a> <a id="2833" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="2837" class="Symbol">}</a> <a id="2839" class="Symbol">(</a><a id="2840" href="03-Exercises.html#2840" class="Bound">f</a> <a id="2842" class="Symbol">:</a> <a id="2844" href="03-Exercises.html#2827" class="Bound">A</a> <a id="2846" class="Symbol">→</a> <a id="2848" href="03-Exercises.html#2829" class="Bound">B</a><a id="2849" class="Symbol">)</a> <a id="2851" class="Symbol">:</a> <a id="2853" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a> <a id="2858" class="Keyword">where</a>
 <a id="2865" class="Keyword">constructor</a>
  <a id="Inverse"></a><a id="2879" href="03-Exercises.html#2879" data-type="(inverse : B → A)
(η : (inverse products.∘ f) 03-Exercises.∼ products.id)
(ε : (f products.∘ inverse) 03-Exercises.∼ products.id) →
03-Exercises.is-bijection f" class="InductiveConstructor">Inverse</a>
 <a id="2888" class="Keyword">field</a>
  <a id="is-bijection.inverse"></a><a id="2896" href="03-Exercises.html#2896" data-type="03-Exercises.is-bijection f → B → A" class="Field">inverse</a> <a id="2904" class="Symbol">:</a> <a id="2906" href="03-Exercises.html#2829" class="Bound">B</a> <a id="2908" class="Symbol">→</a> <a id="2910" href="03-Exercises.html#2827" class="Bound">A</a>
  <a id="is-bijection.η"></a><a id="2914" href="03-Exercises.html#2914" data-type="(r : 03-Exercises.is-bijection f) →
(03-Exercises.is-bijection.inverse r products.∘ f) 03-Exercises.∼
products.id" class="Field">η</a>       <a id="2922" class="Symbol">:</a> <a id="2924" href="03-Exercises.html#2896" data-type="03-Exercises.is-bijection f → B → A" class="Field">inverse</a> <a id="2932" href="products.html#3388" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="2934" href="03-Exercises.html#2840" class="Bound">f</a> <a id="2936" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="2938" href="products.html#1041" data-type="A → A" class="Function">id</a>
  <a id="is-bijection.ε"></a><a id="2943" href="03-Exercises.html#2943" data-type="(r : 03-Exercises.is-bijection f) →
(f products.∘ 03-Exercises.is-bijection.inverse r) 03-Exercises.∼
products.id" class="Field">ε</a>       <a id="2951" class="Symbol">:</a> <a id="2953" href="03-Exercises.html#2840" class="Bound">f</a> <a id="2955" href="products.html#3388" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="2957" href="03-Exercises.html#2896" data-type="03-Exercises.is-bijection f → B → A" class="Field">inverse</a> <a id="2965" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="2967" href="products.html#1041" data-type="A → A" class="Function">id</a>

<a id="2971" class="Keyword">record</a> <a id="_≅_"></a><a id="2978" href="03-Exercises.html#2978" data-type="(A B : general-notation.Type) → general-notation.Type" class="Record Operator">_≅_</a> <a id="2982" class="Symbol">(</a><a id="2983" href="03-Exercises.html#2983" class="Bound">A</a> <a id="2985" href="03-Exercises.html#2985" class="Bound">B</a> <a id="2987" class="Symbol">:</a> <a id="2989" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="2993" class="Symbol">)</a> <a id="2995" class="Symbol">:</a> <a id="2997" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a> <a id="3002" class="Keyword">where</a>
 <a id="3009" class="Keyword">constructor</a>
  <a id="Isomorphism"></a><a id="3023" href="03-Exercises.html#3023" data-type="(bijection : A → B)
(bijectivity : 03-Exercises.is-bijection bijection) →
A 03-Exercises.≅ B" class="InductiveConstructor">Isomorphism</a>
 <a id="3036" class="Keyword">field</a>
  <a id="_≅_.bijection"></a><a id="3044" href="03-Exercises.html#3044" data-type="A 03-Exercises.≅ B → A → B" class="Field">bijection</a>   <a id="3056" class="Symbol">:</a> <a id="3058" href="03-Exercises.html#2983" class="Bound">A</a> <a id="3060" class="Symbol">→</a> <a id="3062" href="03-Exercises.html#2985" class="Bound">B</a>
  <a id="_≅_.bijectivity"></a><a id="3066" href="03-Exercises.html#3066" data-type="(r : A 03-Exercises.≅ B) →
03-Exercises.is-bijection (03-Exercises._≅_.bijection r)" class="Field">bijectivity</a> <a id="3078" class="Symbol">:</a> <a id="3080" href="03-Exercises.html#2813" data-type="(f : A → B) → general-notation.Type" class="Record">is-bijection</a> <a id="3093" href="03-Exercises.html#3044" data-type="A 03-Exercises.≅ B → A → B" class="Field">bijection</a>

<a id="3104" class="Keyword">infix</a> <a id="3110" class="Number">0</a> <a id="3112" href="03-Exercises.html#2978" data-type="(A B : general-notation.Type) → general-notation.Type" class="Record Operator">_≅_</a>
</pre>
<h3 id="exercise-2">Exercise 2 (⋆)</h3>
Reformulate the same definition using Sigma-types.
<pre class="Agda"><a id="is-bijection&#39;"></a><a id="3200" href="03-Exercises.html#3200" data-type="(A → B) → general-notation.Type" class="Function">is-bijection&#39;</a> <a id="3214" class="Symbol">:</a> <a id="3216" class="Symbol">{</a><a id="3217" href="03-Exercises.html#3217" class="Bound">A</a> <a id="3219" href="03-Exercises.html#3219" class="Bound">B</a> <a id="3221" class="Symbol">:</a> <a id="3223" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="3227" class="Symbol">}</a> <a id="3229" class="Symbol">→</a> <a id="3231" class="Symbol">(</a><a id="3232" href="03-Exercises.html#3217" class="Bound">A</a> <a id="3234" class="Symbol">→</a> <a id="3236" href="03-Exercises.html#3219" class="Bound">B</a><a id="3237" class="Symbol">)</a> <a id="3239" class="Symbol">→</a> <a id="3241" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a>
<a id="3246" href="03-Exercises.html#3200" data-type="(A → B) → general-notation.Type" class="Function">is-bijection&#39;</a> <a id="3260" href="03-Exercises.html#3260" class="Bound">f</a> <a id="3262" class="Symbol">=</a> <a id="3264" class="Hole">{!!}</a>

<a id="_≅&#39;_"></a><a id="3270" href="03-Exercises.html#3270" data-type="general-notation.Type →
general-notation.Type → general-notation.Type" class="Function Operator">_≅&#39;_</a> <a id="3275" class="Symbol">:</a> <a id="3277" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a> <a id="3282" class="Symbol">→</a> <a id="3284" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a> <a id="3289" class="Symbol">→</a> <a id="3291" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a>
<a id="3296" href="03-Exercises.html#3296" class="Bound">A</a> <a id="3298" href="03-Exercises.html#3270" data-type="general-notation.Type →
general-notation.Type → general-notation.Type" class="Function Operator">≅&#39;</a> <a id="3301" href="03-Exercises.html#3301" class="Bound">B</a> <a id="3303" class="Symbol">=</a> <a id="3305" class="Hole">{!!}</a>
</pre>
<p>The definition with <code>Σ</code> is probably more intuitive, but,
as discussed above, the definition with a record is often easier to work
with, because we can easily extract the components of the definitions
using the names of the fields. It also often allows Agda to infer more
types, and to give us more sensible goals in the interactive development
of Agda programs and proofs.</p>
<p>Notice that <code>inverse</code> plays the role of <code>g</code>.
The reason we use <code>inverse</code> is that then we can use the word
<code>inverse</code> to extract the inverse of a bijection. Similarly we
use <code>bijection</code> for <code>f</code>, as we can use the word
<code>bijection</code> to extract the bijection from a record.</p>
<p>This type can be defined to be <code>𝟙 ∔ 𝟙</code> using the
coproduct, but we give a direct definition which will allow us to
discuss some relationships between the various type formers of Basic
MLTT.</p>
<pre class="Agda"><a id="4156" class="Keyword">data</a> <a id="𝟚"></a><a id="4161" href="03-Exercises.html#4161" data-type="Set" class="Datatype">𝟚</a> <a id="4163" class="Symbol">:</a> <a id="4165" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a> <a id="4170" class="Keyword">where</a>
 <a id="𝟚.𝟎"></a><a id="4177" href="03-Exercises.html#4177" data-type="03-Exercises.𝟚" class="InductiveConstructor">𝟎</a> <a id="𝟚.𝟏"></a><a id="4179" href="03-Exercises.html#4179" data-type="03-Exercises.𝟚" class="InductiveConstructor">𝟏</a> <a id="4181" class="Symbol">:</a> <a id="4183" href="03-Exercises.html#4161" data-type="Set" class="Datatype">𝟚</a>
</pre>
<h3 id="exercise-3">Exercise 3 (⋆⋆)</h3>
<p>Prove that 𝟚 and Bool are isomorphic</p>
<pre class="Agda"><a id="Bool-𝟚-isomorphism"></a><a id="4257" href="03-Exercises.html#4257" data-type="Bool.Bool 03-Exercises.≅ 03-Exercises.𝟚" class="Function">Bool-𝟚-isomorphism</a> <a id="4276" class="Symbol">:</a> <a id="4278" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a> <a id="4283" href="03-Exercises.html#2978" data-type="(A B : general-notation.Type) → general-notation.Type" class="Record Operator">≅</a> <a id="4285" href="03-Exercises.html#4161" data-type="Set" class="Datatype">𝟚</a>
<a id="4287" href="03-Exercises.html#4257" data-type="Bool.Bool 03-Exercises.≅ 03-Exercises.𝟚" class="Function">Bool-𝟚-isomorphism</a> <a id="4306" class="Symbol">=</a> <a id="4308" class="Keyword">record</a> <a id="4315" class="Symbol">{</a> <a id="4317" href="03-Exercises.html#3044" data-type="A 03-Exercises.≅ B → A → B" class="Field">bijection</a> <a id="4327" class="Symbol">=</a> <a id="4329" class="Hole">{!!}</a> <a id="4334" class="Symbol">;</a> <a id="4336" href="03-Exercises.html#3066" data-type="(r : A 03-Exercises.≅ B) →
03-Exercises.is-bijection (03-Exercises._≅_.bijection r)" class="Field">bijectivity</a> <a id="4348" class="Symbol">=</a> <a id="4350" class="Hole">{!!}</a> <a id="4355" class="Symbol">}</a>
 <a id="4358" class="Keyword">where</a>
  <a id="4366" href="03-Exercises.html#4366" class="Function">f</a> <a id="4368" class="Symbol">:</a> <a id="4370" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a> <a id="4375" class="Symbol">→</a> <a id="4377" href="03-Exercises.html#4161" data-type="Set" class="Datatype">𝟚</a>
  <a id="4381" href="03-Exercises.html#4366" class="Function">f</a> <a id="4383" href="Bool.html#516" data-type="Bool.Bool" class="InductiveConstructor">false</a> <a id="4389" class="Symbol">=</a> <a id="4391" class="Hole">{!!}</a>
  <a id="4398" href="03-Exercises.html#4366" class="Function">f</a> <a id="4400" href="Bool.html#511" data-type="Bool.Bool" class="InductiveConstructor">true</a>  <a id="4406" class="Symbol">=</a> <a id="4408" class="Hole">{!!}</a>

  <a id="4416" href="03-Exercises.html#4416" class="Function">g</a> <a id="4418" class="Symbol">:</a> <a id="4420" href="03-Exercises.html#4161" data-type="Set" class="Datatype">𝟚</a> <a id="4422" class="Symbol">→</a> <a id="4424" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a>
  <a id="4431" href="03-Exercises.html#4416" class="Function">g</a> <a id="4433" href="03-Exercises.html#4177" data-type="03-Exercises.𝟚" class="InductiveConstructor">𝟎</a> <a id="4435" class="Symbol">=</a> <a id="4437" class="Hole">{!!}</a>
  <a id="4444" href="03-Exercises.html#4416" class="Function">g</a> <a id="4446" href="03-Exercises.html#4179" data-type="03-Exercises.𝟚" class="InductiveConstructor">𝟏</a> <a id="4448" class="Symbol">=</a> <a id="4450" class="Hole">{!!}</a>

  <a id="4458" href="03-Exercises.html#4458" class="Function">gf</a> <a id="4461" class="Symbol">:</a> <a id="4463" href="03-Exercises.html#4416" class="Function">g</a> <a id="4465" href="products.html#3388" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="4467" href="03-Exercises.html#4366" class="Function">f</a> <a id="4469" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="4471" href="products.html#1041" data-type="A → A" class="Function">id</a>
  <a id="4476" href="03-Exercises.html#4458" class="Function">gf</a> <a id="4479" href="Bool.html#511" data-type="Bool.Bool" class="InductiveConstructor">true</a>  <a id="4485" class="Symbol">=</a> <a id="4487" class="Hole">{!!}</a>
  <a id="4494" href="03-Exercises.html#4458" class="Function">gf</a> <a id="4497" href="Bool.html#516" data-type="Bool.Bool" class="InductiveConstructor">false</a> <a id="4503" class="Symbol">=</a> <a id="4505" class="Hole">{!!}</a>

  <a id="4513" href="03-Exercises.html#4513" class="Function">fg</a> <a id="4516" class="Symbol">:</a> <a id="4518" href="03-Exercises.html#4366" class="Function">f</a> <a id="4520" href="products.html#3388" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="4522" href="03-Exercises.html#4416" class="Function">g</a> <a id="4524" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="4526" href="products.html#1041" data-type="A → A" class="Function">id</a>
  <a id="4531" href="03-Exercises.html#4513" class="Function">fg</a> <a id="4534" href="03-Exercises.html#4177" data-type="03-Exercises.𝟚" class="InductiveConstructor">𝟎</a> <a id="4536" class="Symbol">=</a> <a id="4538" class="Hole">{!!}</a>
  <a id="4545" href="03-Exercises.html#4513" class="Function">fg</a> <a id="4548" href="03-Exercises.html#4179" data-type="03-Exercises.𝟚" class="InductiveConstructor">𝟏</a> <a id="4550" class="Symbol">=</a> <a id="4552" class="Hole">{!!}</a>

  <a id="4560" href="03-Exercises.html#4560" class="Function">f-is-bijection</a> <a id="4575" class="Symbol">:</a> <a id="4577" href="03-Exercises.html#2813" data-type="(f : A → B) → general-notation.Type" class="Record">is-bijection</a> <a id="4590" href="03-Exercises.html#4366" class="Function">f</a>
  <a id="4594" href="03-Exercises.html#4560" class="Function">f-is-bijection</a> <a id="4609" class="Symbol">=</a> <a id="4611" class="Keyword">record</a> <a id="4618" class="Symbol">{</a> <a id="4620" href="03-Exercises.html#2896" data-type="03-Exercises.is-bijection f → B → A" class="Field">inverse</a> <a id="4628" class="Symbol">=</a> <a id="4630" class="Hole">{!!}</a> <a id="4635" class="Symbol">;</a> <a id="4637" href="03-Exercises.html#2914" data-type="(r : 03-Exercises.is-bijection f) →
(03-Exercises.is-bijection.inverse r products.∘ f) 03-Exercises.∼
products.id" class="Field">η</a> <a id="4639" class="Symbol">=</a> <a id="4641" class="Hole">{!!}</a> <a id="4646" class="Symbol">;</a> <a id="4648" href="03-Exercises.html#2943" data-type="(r : 03-Exercises.is-bijection f) →
(f products.∘ 03-Exercises.is-bijection.inverse r) 03-Exercises.∼
products.id" class="Field">ε</a> <a id="4650" class="Symbol">=</a> <a id="4652" class="Hole">{!!}</a> <a id="4657" class="Symbol">}</a>
</pre>
<h2 id="part-iii---finite-types">Part III - Finite Types</h2>
<p>In the last HoTT Exercises we encountered two definitions of the
finite types. Here we prove that they are isomorphic. Note that
<code>zero</code> was called <code>pt</code> and suc <code>i</code> on
the HoTT exercise sheet.</p>
<pre class="Agda"><a id="4894" class="Keyword">data</a> <a id="Fin"></a><a id="4899" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="4903" class="Symbol">:</a> <a id="4905" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="4907" class="Symbol">→</a> <a id="4909" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a> <a id="4914" class="Keyword">where</a>
 <a id="Fin.zero"></a><a id="4921" href="03-Exercises.html#4921" data-type="03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">zero</a> <a id="4926" class="Symbol">:</a> <a id="4928" class="Symbol">{</a><a id="4929" href="03-Exercises.html#4929" class="Bound">n</a> <a id="4931" class="Symbol">:</a> <a id="4933" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="4934" class="Symbol">}</a> <a id="4936" class="Symbol">→</a> <a id="4938" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="4942" class="Symbol">(</a><a id="4943" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="4947" href="03-Exercises.html#4929" class="Bound">n</a><a id="4948" class="Symbol">)</a>
 <a id="Fin.suc"></a><a id="4951" href="03-Exercises.html#4951" data-type="03-Exercises.Fin n → 03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">suc</a>  <a id="4956" class="Symbol">:</a> <a id="4958" class="Symbol">{</a><a id="4959" href="03-Exercises.html#4959" class="Bound">n</a> <a id="4961" class="Symbol">:</a> <a id="4963" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="4964" class="Symbol">}</a> <a id="4966" class="Symbol">→</a> <a id="4968" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="4972" href="03-Exercises.html#4959" class="Bound">n</a> <a id="4974" class="Symbol">→</a> <a id="4976" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="4980" class="Symbol">(</a><a id="4981" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="4985" href="03-Exercises.html#4959" class="Bound">n</a><a id="4986" class="Symbol">)</a>
</pre>
<h3 id="exercise-4">Exercise 4 (⋆)</h3>
Prove the elimination principle of <code>Fin</code>.
<pre class="Agda"><a id="Fin-elim"></a><a id="5063" href="03-Exercises.html#5063" data-type="(A : 03-Exercises.Fin n → general-notation.Type) →
A 03-Exercises.zero →
((k : 03-Exercises.Fin n) → A k → A (03-Exercises.suc k)) →
(k : 03-Exercises.Fin n) → A k" class="Function">Fin-elim</a> <a id="5072" class="Symbol">:</a> <a id="5074" class="Symbol">(</a><a id="5075" href="03-Exercises.html#5075" class="Bound">A</a> <a id="5077" class="Symbol">:</a> <a id="5079" class="Symbol">{</a><a id="5080" href="03-Exercises.html#5080" class="Bound">n</a> <a id="5082" class="Symbol">:</a> <a id="5084" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5085" class="Symbol">}</a> <a id="5087" class="Symbol">→</a> <a id="5089" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="5093" href="03-Exercises.html#5080" class="Bound">n</a> <a id="5095" class="Symbol">→</a> <a id="5097" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="5101" class="Symbol">)</a>
         <a id="5112" class="Symbol">→</a> <a id="5114" class="Symbol">({</a><a id="5116" href="03-Exercises.html#5116" class="Bound">n</a> <a id="5118" class="Symbol">:</a> <a id="5120" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5121" class="Symbol">}</a> <a id="5123" class="Symbol">→</a> <a id="5125" href="03-Exercises.html#5075" class="Bound">A</a> <a id="5127" class="Symbol">{</a><a id="5128" class="InductiveConstructor">suc</a> <a id="5132" href="03-Exercises.html#5116" class="Bound">n</a><a id="5133" class="Symbol">}</a> <a id="5135" class="InductiveConstructor">zero</a><a id="5139" class="Symbol">)</a>
         <a id="5150" class="Symbol">→</a> <a id="5152" class="Symbol">({</a><a id="5154" href="03-Exercises.html#5154" class="Bound">n</a> <a id="5156" class="Symbol">:</a> <a id="5158" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5159" class="Symbol">}</a> <a id="5161" class="Symbol">(</a><a id="5162" href="03-Exercises.html#5162" class="Bound">k</a> <a id="5164" class="Symbol">:</a> <a id="5166" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="5170" href="03-Exercises.html#5154" class="Bound">n</a><a id="5171" class="Symbol">)</a> <a id="5173" class="Symbol">→</a> <a id="5175" href="03-Exercises.html#5075" class="Bound">A</a> <a id="5177" href="03-Exercises.html#5162" class="Bound">k</a> <a id="5179" class="Symbol">→</a> <a id="5181" href="03-Exercises.html#5075" class="Bound">A</a> <a id="5183" class="Symbol">(</a><a id="5184" class="InductiveConstructor">suc</a> <a id="5188" href="03-Exercises.html#5162" class="Bound">k</a><a id="5189" class="Symbol">))</a>
         <a id="5201" class="Symbol">→</a> <a id="5203" class="Symbol">{</a><a id="5204" href="03-Exercises.html#5204" class="Bound">n</a> <a id="5206" class="Symbol">:</a> <a id="5208" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5209" class="Symbol">}</a> <a id="5211" class="Symbol">(</a><a id="5212" href="03-Exercises.html#5212" class="Bound">k</a> <a id="5214" class="Symbol">:</a> <a id="5216" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="5220" href="03-Exercises.html#5204" class="Bound">n</a><a id="5221" class="Symbol">)</a> <a id="5223" class="Symbol">→</a> <a id="5225" href="03-Exercises.html#5075" class="Bound">A</a> <a id="5227" href="03-Exercises.html#5212" class="Bound">k</a>
<a id="5229" href="03-Exercises.html#5063" data-type="(A : 03-Exercises.Fin n → general-notation.Type) →
A 03-Exercises.zero →
((k : 03-Exercises.Fin n) → A k → A (03-Exercises.suc k)) →
(k : 03-Exercises.Fin n) → A k" class="Function">Fin-elim</a> <a id="5238" href="03-Exercises.html#5238" class="Bound">A</a> <a id="5240" href="03-Exercises.html#5240" class="Bound">a</a> <a id="5242" href="03-Exercises.html#5242" class="Bound">f</a> <a id="5244" class="Symbol">=</a> <a id="5246" href="03-Exercises.html#5257" data-type="(A : 03-Exercises.Fin n → general-notation.Type) →
A 03-Exercises.zero →
((k : 03-Exercises.Fin n) → A k → A (03-Exercises.suc k)) →
(k : 03-Exercises.Fin n) → A k" class="Function">h</a>
 <a id="5249" class="Keyword">where</a>
  <a id="5257" href="03-Exercises.html#5257" data-type="(A : 03-Exercises.Fin n → general-notation.Type) →
A 03-Exercises.zero →
((k : 03-Exercises.Fin n) → A k → A (03-Exercises.suc k)) →
(k : 03-Exercises.Fin n) → A k" class="Function">h</a> <a id="5259" class="Symbol">:</a> <a id="5261" class="Symbol">{</a><a id="5262" href="03-Exercises.html#5262" class="Bound">n</a> <a id="5264" class="Symbol">:</a> <a id="5266" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5267" class="Symbol">}</a> <a id="5269" class="Symbol">(</a><a id="5270" href="03-Exercises.html#5270" class="Bound">k</a> <a id="5272" class="Symbol">:</a> <a id="5274" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="5278" href="03-Exercises.html#5262" class="Bound">n</a><a id="5279" class="Symbol">)</a> <a id="5281" class="Symbol">→</a> <a id="5283" href="03-Exercises.html#5238" class="Bound">A</a> <a id="5285" href="03-Exercises.html#5270" class="Bound">k</a>
  <a id="5289" href="03-Exercises.html#5257" data-type="(A : 03-Exercises.Fin n → general-notation.Type) →
A 03-Exercises.zero →
((k : 03-Exercises.Fin n) → A k → A (03-Exercises.suc k)) →
(k : 03-Exercises.Fin n) → A k" class="Function">h</a> <a id="5291" href="03-Exercises.html#4921" data-type="03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">zero</a>    <a id="5299" class="Symbol">=</a> <a id="5301" class="Hole">{!!}</a>
  <a id="5308" href="03-Exercises.html#5257" data-type="(A : 03-Exercises.Fin n → general-notation.Type) →
A 03-Exercises.zero →
((k : 03-Exercises.Fin n) → A k → A (03-Exercises.suc k)) →
(k : 03-Exercises.Fin n) → A k" class="Function">h</a> <a id="5310" class="Symbol">(</a><a id="5311" href="03-Exercises.html#4951" data-type="03-Exercises.Fin n → 03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">suc</a> <a id="5315" href="03-Exercises.html#5315" class="Bound">k</a><a id="5316" class="Symbol">)</a> <a id="5318" class="Symbol">=</a> <a id="5320" class="Hole">{!!}</a>
</pre>
<p>We give the other definition of the finite types and introduce some
notation.</p>
<pre class="Agda"><a id="Fin&#39;"></a><a id="5417" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5422" class="Symbol">:</a> <a id="5424" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="5426" class="Symbol">→</a> <a id="5428" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a>
<a id="5433" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5438" class="Number">0</a>       <a id="5446" class="Symbol">=</a> <a id="5448" href="empty-type.html#523" data-type="Set" class="Datatype">𝟘</a>
<a id="5450" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5455" class="Symbol">(</a><a id="5456" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="5460" href="03-Exercises.html#5460" class="Bound">n</a><a id="5461" class="Symbol">)</a> <a id="5463" class="Symbol">=</a> <a id="5465" href="unit-type.html#396" data-type="general-notation.Type" class="Record">𝟙</a> <a id="5467" href="binary-sums.html#672" data-type="general-notation.Type → general-notation.Type → Set" class="Datatype Operator">∔</a> <a id="5469" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5474" href="03-Exercises.html#5460" class="Bound">n</a>

<a id="zero&#39;"></a><a id="5477" href="03-Exercises.html#5477" data-type="03-Exercises.Fin&#39; (Fin.suc n)" class="Function">zero&#39;</a> <a id="5483" class="Symbol">:</a> <a id="5485" class="Symbol">{</a><a id="5486" href="03-Exercises.html#5486" class="Bound">n</a> <a id="5488" class="Symbol">:</a> <a id="5490" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5491" class="Symbol">}</a> <a id="5493" class="Symbol">→</a> <a id="5495" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5500" class="Symbol">(</a><a id="5501" class="InductiveConstructor">suc</a> <a id="5505" href="03-Exercises.html#5486" class="Bound">n</a><a id="5506" class="Symbol">)</a>
<a id="5508" href="03-Exercises.html#5477" data-type="03-Exercises.Fin&#39; (Fin.suc n)" class="Function">zero&#39;</a> <a id="5514" class="Symbol">=</a> <a id="5516" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="5520" href="unit-type.html#426" data-type="unit-type.𝟙" class="InductiveConstructor">⋆</a>

<a id="suc&#39;"></a><a id="5523" href="03-Exercises.html#5523" data-type="03-Exercises.Fin&#39; n → 03-Exercises.Fin&#39; (Fin.suc n)" class="Function">suc&#39;</a>  <a id="5529" class="Symbol">:</a> <a id="5531" class="Symbol">{</a><a id="5532" href="03-Exercises.html#5532" class="Bound">n</a> <a id="5534" class="Symbol">:</a> <a id="5536" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5537" class="Symbol">}</a> <a id="5539" class="Symbol">→</a> <a id="5541" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5546" href="03-Exercises.html#5532" class="Bound">n</a> <a id="5548" class="Symbol">→</a> <a id="5550" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5555" class="Symbol">(</a><a id="5556" class="InductiveConstructor">suc</a> <a id="5560" href="03-Exercises.html#5532" class="Bound">n</a><a id="5561" class="Symbol">)</a>
<a id="5563" href="03-Exercises.html#5523" data-type="03-Exercises.Fin&#39; n → 03-Exercises.Fin&#39; (Fin.suc n)" class="Function">suc&#39;</a> <a id="5568" class="Symbol">=</a> <a id="5570" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a>
</pre>
<h3 id="exercise-5">Exercise 5 (⋆⋆⋆)</h3>
<p>Prove that <code>Fin n</code> and <code>Fin' n</code> are isomorphic
for every <code>n</code>.</p>
<pre class="Agda"><a id="Fin-isomorphism"></a><a id="5672" href="03-Exercises.html#5672" data-type="(n : Fin.ℕ) → 03-Exercises.Fin n 03-Exercises.≅ 03-Exercises.Fin&#39; n" class="Function">Fin-isomorphism</a> <a id="5688" class="Symbol">:</a> <a id="5690" class="Symbol">(</a><a id="5691" href="03-Exercises.html#5691" class="Bound">n</a> <a id="5693" class="Symbol">:</a> <a id="5695" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5696" class="Symbol">)</a> <a id="5698" class="Symbol">→</a> <a id="5700" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="5704" href="03-Exercises.html#5691" class="Bound">n</a> <a id="5706" href="03-Exercises.html#2978" data-type="(A B : general-notation.Type) → general-notation.Type" class="Record Operator">≅</a> <a id="5708" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5713" href="03-Exercises.html#5691" class="Bound">n</a>
<a id="5715" href="03-Exercises.html#5672" data-type="(n : Fin.ℕ) → 03-Exercises.Fin n 03-Exercises.≅ 03-Exercises.Fin&#39; n" class="Function">Fin-isomorphism</a> <a id="5731" href="03-Exercises.html#5731" class="Bound">n</a> <a id="5733" class="Symbol">=</a> <a id="5735" class="Keyword">record</a> <a id="5742" class="Symbol">{</a> <a id="5744" href="03-Exercises.html#3044" data-type="A 03-Exercises.≅ B → A → B" class="Field">bijection</a> <a id="5754" class="Symbol">=</a> <a id="5756" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="5758" href="03-Exercises.html#5731" class="Bound">n</a> <a id="5760" class="Symbol">;</a> <a id="5762" href="03-Exercises.html#3066" data-type="(r : A 03-Exercises.≅ B) →
03-Exercises.is-bijection (03-Exercises._≅_.bijection r)" class="Field">bijectivity</a> <a id="5774" class="Symbol">=</a> <a id="5776" href="03-Exercises.html#6622" data-type="(n n₁ : Fin.ℕ) → 03-Exercises.is-bijection (f n n₁)" class="Function">f-is-bijection</a> <a id="5791" href="03-Exercises.html#5731" class="Bound">n</a> <a id="5793" class="Symbol">}</a>
 <a id="5796" class="Keyword">where</a>
  <a id="5804" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="5806" class="Symbol">:</a> <a id="5808" class="Symbol">(</a><a id="5809" href="03-Exercises.html#5809" class="Bound">n</a> <a id="5811" class="Symbol">:</a> <a id="5813" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5814" class="Symbol">)</a> <a id="5816" class="Symbol">→</a> <a id="5818" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="5822" href="03-Exercises.html#5809" class="Bound">n</a> <a id="5824" class="Symbol">→</a> <a id="5826" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5831" href="03-Exercises.html#5809" class="Bound">n</a>
  <a id="5835" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="5837" class="Symbol">(</a><a id="5838" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="5842" href="03-Exercises.html#5842" class="Bound">n</a><a id="5843" class="Symbol">)</a> <a id="5845" href="03-Exercises.html#4921" data-type="03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">zero</a>    <a id="5853" class="Symbol">=</a> <a id="5855" class="Hole">{!!}</a>
  <a id="5862" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="5864" class="Symbol">(</a><a id="5865" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="5869" href="03-Exercises.html#5869" class="Bound">n</a><a id="5870" class="Symbol">)</a> <a id="5872" class="Symbol">(</a><a id="5873" href="03-Exercises.html#4951" data-type="03-Exercises.Fin n → 03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">suc</a> <a id="5877" href="03-Exercises.html#5877" class="Bound">k</a><a id="5878" class="Symbol">)</a> <a id="5880" class="Symbol">=</a> <a id="5882" class="Hole">{!!}</a>

  <a id="5890" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="5892" class="Symbol">:</a> <a id="5894" class="Symbol">(</a><a id="5895" href="03-Exercises.html#5895" class="Bound">n</a> <a id="5897" class="Symbol">:</a> <a id="5899" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5900" class="Symbol">)</a> <a id="5902" class="Symbol">→</a> <a id="5904" href="03-Exercises.html#5417" data-type="Fin.ℕ → general-notation.Type" class="Function">Fin&#39;</a> <a id="5909" href="03-Exercises.html#5895" class="Bound">n</a> <a id="5911" class="Symbol">→</a> <a id="5913" href="03-Exercises.html#4899" data-type="Fin.ℕ → Set" class="Datatype">Fin</a> <a id="5917" href="03-Exercises.html#5895" class="Bound">n</a>
  <a id="5921" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="5923" class="Symbol">(</a><a id="5924" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="5928" href="03-Exercises.html#5928" class="Bound">n</a><a id="5929" class="Symbol">)</a> <a id="5931" class="Symbol">(</a><a id="5932" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="5936" href="unit-type.html#426" data-type="unit-type.𝟙" class="InductiveConstructor">⋆</a><a id="5937" class="Symbol">)</a> <a id="5939" class="Symbol">=</a> <a id="5941" class="Hole">{!!}</a>
  <a id="5948" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="5950" class="Symbol">(</a><a id="5951" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="5955" href="03-Exercises.html#5955" class="Bound">n</a><a id="5956" class="Symbol">)</a> <a id="5958" class="Symbol">(</a><a id="5959" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="5963" href="03-Exercises.html#5963" class="Bound">k</a><a id="5964" class="Symbol">)</a> <a id="5966" class="Symbol">=</a> <a id="5968" class="Hole">{!!}</a>

  <a id="5976" href="03-Exercises.html#5976" data-type="(n n₁ : Fin.ℕ) →
(g n n₁ products.∘ f n n₁) 03-Exercises.∼ products.id" class="Function">gf</a> <a id="5979" class="Symbol">:</a> <a id="5981" class="Symbol">(</a><a id="5982" href="03-Exercises.html#5982" class="Bound">n</a> <a id="5984" class="Symbol">:</a> <a id="5986" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="5987" class="Symbol">)</a> <a id="5989" class="Symbol">→</a> <a id="5991" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="5993" href="03-Exercises.html#5982" class="Bound">n</a> <a id="5995" href="products.html#3388" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="5997" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="5999" href="03-Exercises.html#5982" class="Bound">n</a> <a id="6001" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="6003" href="products.html#1041" data-type="A → A" class="Function">id</a>
  <a id="6008" href="03-Exercises.html#5976" data-type="(n n₁ : Fin.ℕ) →
(g n n₁ products.∘ f n n₁) 03-Exercises.∼ products.id" class="Function">gf</a> <a id="6011" class="Symbol">(</a><a id="6012" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6016" href="03-Exercises.html#6016" class="Bound">n</a><a id="6017" class="Symbol">)</a> <a id="6019" href="03-Exercises.html#4921" data-type="03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">zero</a>    <a id="6027" class="Symbol">=</a> <a id="6029" class="Hole">{!!}</a>
  <a id="6036" href="03-Exercises.html#5976" data-type="(n n₁ : Fin.ℕ) →
(g n n₁ products.∘ f n n₁) 03-Exercises.∼ products.id" class="Function">gf</a> <a id="6039" class="Symbol">(</a><a id="6040" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6044" href="03-Exercises.html#6044" class="Bound">n</a><a id="6045" class="Symbol">)</a> <a id="6047" class="Symbol">(</a><a id="6048" href="03-Exercises.html#4951" data-type="03-Exercises.Fin n → 03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">suc</a> <a id="6052" href="03-Exercises.html#6052" class="Bound">k</a><a id="6053" class="Symbol">)</a> <a id="6055" class="Symbol">=</a> <a id="6057" href="03-Exercises.html#6114" data-type="(n : Fin.ℕ) (n₁ : Fin.ℕ) (k : 03-Exercises.Fin n₁) →
g n (Fin.suc n₁) (f n (Fin.suc n₁) (03-Exercises.suc k))
identity-type.≡ 03-Exercises.suc k" class="Function">γ</a>
   <a id="6062" class="Keyword">where</a>
    <a id="6072" href="03-Exercises.html#6072" class="Function">IH</a> <a id="6075" class="Symbol">:</a> <a id="6077" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6079" href="03-Exercises.html#6044" class="Bound">n</a> <a id="6081" class="Symbol">(</a><a id="6082" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6084" href="03-Exercises.html#6044" class="Bound">n</a> <a id="6086" href="03-Exercises.html#6052" class="Bound">k</a><a id="6087" class="Symbol">)</a> <a id="6089" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6091" href="03-Exercises.html#6052" class="Bound">k</a>
    <a id="6097" href="03-Exercises.html#6072" class="Function">IH</a> <a id="6100" class="Symbol">=</a> <a id="6102" href="03-Exercises.html#5976" data-type="(n n₁ : Fin.ℕ) →
(g n n₁ products.∘ f n n₁) 03-Exercises.∼ products.id" class="Function">gf</a> <a id="6105" href="03-Exercises.html#6044" class="Bound">n</a> <a id="6107" href="03-Exercises.html#6052" class="Bound">k</a>

    <a id="6114" href="03-Exercises.html#6114" data-type="(n : Fin.ℕ) (n₁ : Fin.ℕ) (k : 03-Exercises.Fin n₁) →
g n (Fin.suc n₁) (f n (Fin.suc n₁) (03-Exercises.suc k))
identity-type.≡ 03-Exercises.suc k" class="Function">γ</a> <a id="6116" class="Symbol">=</a> <a id="6118" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6120" class="Symbol">(</a><a id="6121" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6125" href="03-Exercises.html#6044" class="Bound">n</a><a id="6126" class="Symbol">)</a> <a id="6128" class="Symbol">(</a><a id="6129" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6131" class="Symbol">(</a><a id="6132" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6136" href="03-Exercises.html#6044" class="Bound">n</a><a id="6137" class="Symbol">)</a> <a id="6139" class="Symbol">(</a><a id="6140" href="03-Exercises.html#4951" data-type="03-Exercises.Fin n → 03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">suc</a> <a id="6144" href="03-Exercises.html#6052" class="Bound">k</a><a id="6145" class="Symbol">))</a> <a id="6148" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">≡⟨</a> <a id="6151" class="Hole">{!!}</a> <a id="6156" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">⟩</a>
        <a id="6166" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6168" class="Symbol">(</a><a id="6169" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6173" href="03-Exercises.html#6044" class="Bound">n</a><a id="6174" class="Symbol">)</a> <a id="6176" class="Symbol">(</a><a id="6177" href="03-Exercises.html#5523" data-type="03-Exercises.Fin&#39; n → 03-Exercises.Fin&#39; (Fin.suc n)" class="Function">suc&#39;</a> <a id="6182" class="Symbol">(</a><a id="6183" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6185" href="03-Exercises.html#6044" class="Bound">n</a> <a id="6187" href="03-Exercises.html#6052" class="Bound">k</a><a id="6188" class="Symbol">))</a>      <a id="6196" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">≡⟨</a> <a id="6199" class="Hole">{!!}</a> <a id="6204" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">⟩</a>
        <a id="6214" href="03-Exercises.html#4951" data-type="03-Exercises.Fin n → 03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">suc</a> <a id="6218" class="Symbol">(</a><a id="6219" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6221" href="03-Exercises.html#6044" class="Bound">n</a> <a id="6223" class="Symbol">(</a><a id="6224" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6226" href="03-Exercises.html#6044" class="Bound">n</a> <a id="6228" href="03-Exercises.html#6052" class="Bound">k</a><a id="6229" class="Symbol">))</a>             <a id="6244" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">≡⟨</a> <a id="6247" class="Hole">{!!}</a> <a id="6252" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">⟩</a>
        <a id="6262" href="03-Exercises.html#4951" data-type="03-Exercises.Fin n → 03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">suc</a> <a id="6266" href="03-Exercises.html#6052" class="Bound">k</a>                         <a id="6292" href="identity-type.html#4238" data-type="(x : X) → x identity-type.≡ x" class="Function Operator">∎</a>

  <a id="6297" href="03-Exercises.html#6297" data-type="(n n₁ : Fin.ℕ) →
(f n n₁ products.∘ g n n₁) 03-Exercises.∼ products.id" class="Function">fg</a> <a id="6300" class="Symbol">:</a> <a id="6302" class="Symbol">(</a><a id="6303" href="03-Exercises.html#6303" class="Bound">n</a> <a id="6305" class="Symbol">:</a> <a id="6307" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="6308" class="Symbol">)</a> <a id="6310" class="Symbol">→</a> <a id="6312" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6314" href="03-Exercises.html#6303" class="Bound">n</a> <a id="6316" href="products.html#3388" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="6318" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6320" href="03-Exercises.html#6303" class="Bound">n</a> <a id="6322" href="03-Exercises.html#1075" data-type="((x : A) → B x) → ((x : A) → B x) → general-notation.Type" class="Function Operator">∼</a> <a id="6324" href="products.html#1041" data-type="A → A" class="Function">id</a>
  <a id="6329" href="03-Exercises.html#6297" data-type="(n n₁ : Fin.ℕ) →
(f n n₁ products.∘ g n n₁) 03-Exercises.∼ products.id" class="Function">fg</a> <a id="6332" class="Symbol">(</a><a id="6333" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6337" href="03-Exercises.html#6337" class="Bound">n</a><a id="6338" class="Symbol">)</a> <a id="6340" class="Symbol">(</a><a id="6341" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="6345" href="unit-type.html#426" data-type="unit-type.𝟙" class="InductiveConstructor">⋆</a><a id="6346" class="Symbol">)</a> <a id="6348" class="Symbol">=</a> <a id="6350" class="Hole">{!!}</a>
  <a id="6357" href="03-Exercises.html#6297" data-type="(n n₁ : Fin.ℕ) →
(f n n₁ products.∘ g n n₁) 03-Exercises.∼ products.id" class="Function">fg</a> <a id="6360" class="Symbol">(</a><a id="6361" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6365" href="03-Exercises.html#6365" class="Bound">n</a><a id="6366" class="Symbol">)</a> <a id="6368" class="Symbol">(</a><a id="6369" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="6373" href="03-Exercises.html#6373" class="Bound">k</a><a id="6374" class="Symbol">)</a> <a id="6376" class="Symbol">=</a> <a id="6378" href="03-Exercises.html#6435" data-type="(n : Fin.ℕ) (n₁ : Fin.ℕ) (k : 03-Exercises.Fin&#39; n₁) →
f n (Fin.suc n₁) (g n (Fin.suc n₁) (03-Exercises.suc&#39; k))
identity-type.≡ 03-Exercises.suc&#39; k" class="Function">γ</a>
   <a id="6383" class="Keyword">where</a>
    <a id="6393" href="03-Exercises.html#6393" class="Function">IH</a> <a id="6396" class="Symbol">:</a> <a id="6398" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6400" href="03-Exercises.html#6365" class="Bound">n</a> <a id="6402" class="Symbol">(</a><a id="6403" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6405" href="03-Exercises.html#6365" class="Bound">n</a> <a id="6407" href="03-Exercises.html#6373" class="Bound">k</a><a id="6408" class="Symbol">)</a> <a id="6410" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6412" href="03-Exercises.html#6373" class="Bound">k</a>
    <a id="6418" href="03-Exercises.html#6393" class="Function">IH</a> <a id="6421" class="Symbol">=</a> <a id="6423" href="03-Exercises.html#6297" data-type="(n n₁ : Fin.ℕ) →
(f n n₁ products.∘ g n n₁) 03-Exercises.∼ products.id" class="Function">fg</a> <a id="6426" href="03-Exercises.html#6365" class="Bound">n</a> <a id="6428" href="03-Exercises.html#6373" class="Bound">k</a>

    <a id="6435" href="03-Exercises.html#6435" data-type="(n : Fin.ℕ) (n₁ : Fin.ℕ) (k : 03-Exercises.Fin&#39; n₁) →
f n (Fin.suc n₁) (g n (Fin.suc n₁) (03-Exercises.suc&#39; k))
identity-type.≡ 03-Exercises.suc&#39; k" class="Function">γ</a> <a id="6437" class="Symbol">=</a> <a id="6439" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6441" class="Symbol">(</a><a id="6442" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6446" href="03-Exercises.html#6365" class="Bound">n</a><a id="6447" class="Symbol">)</a> <a id="6449" class="Symbol">(</a><a id="6450" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6452" class="Symbol">(</a><a id="6453" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6457" href="03-Exercises.html#6365" class="Bound">n</a><a id="6458" class="Symbol">)</a> <a id="6460" class="Symbol">(</a><a id="6461" href="03-Exercises.html#5523" data-type="03-Exercises.Fin&#39; n → 03-Exercises.Fin&#39; (Fin.suc n)" class="Function">suc&#39;</a> <a id="6466" href="03-Exercises.html#6373" class="Bound">k</a><a id="6467" class="Symbol">))</a> <a id="6470" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">≡⟨</a> <a id="6473" class="Hole">{!!}</a> <a id="6478" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">⟩</a>
        <a id="6488" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6490" class="Symbol">(</a><a id="6491" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6495" href="03-Exercises.html#6365" class="Bound">n</a><a id="6496" class="Symbol">)</a> <a id="6498" class="Symbol">(</a><a id="6499" href="03-Exercises.html#4951" data-type="03-Exercises.Fin n → 03-Exercises.Fin (Fin.suc n)" class="InductiveConstructor">suc</a> <a id="6503" class="Symbol">(</a><a id="6504" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6506" href="03-Exercises.html#6365" class="Bound">n</a> <a id="6508" href="03-Exercises.html#6373" class="Bound">k</a><a id="6509" class="Symbol">))</a>        <a id="6519" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">≡⟨</a> <a id="6522" class="Hole">{!!}</a> <a id="6527" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">⟩</a>
        <a id="6537" href="03-Exercises.html#5523" data-type="03-Exercises.Fin&#39; n → 03-Exercises.Fin&#39; (Fin.suc n)" class="Function">suc&#39;</a> <a id="6542" class="Symbol">(</a><a id="6543" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6545" href="03-Exercises.html#6365" class="Bound">n</a> <a id="6547" class="Symbol">(</a><a id="6548" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6550" href="03-Exercises.html#6365" class="Bound">n</a> <a id="6552" href="03-Exercises.html#6373" class="Bound">k</a><a id="6553" class="Symbol">))</a>             <a id="6568" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">≡⟨</a> <a id="6571" class="Hole">{!!}</a> <a id="6576" href="identity-type.html#4152" data-type="(x : X) →
x identity-type.≡ y → y identity-type.≡ z → x identity-type.≡ z" class="Function Operator">⟩</a>
        <a id="6586" href="03-Exercises.html#5523" data-type="03-Exercises.Fin&#39; n → 03-Exercises.Fin&#39; (Fin.suc n)" class="Function">suc&#39;</a> <a id="6591" href="03-Exercises.html#6373" class="Bound">k</a>                         <a id="6617" href="identity-type.html#4238" data-type="(x : X) → x identity-type.≡ x" class="Function Operator">∎</a>

  <a id="6622" href="03-Exercises.html#6622" data-type="(n n₁ : Fin.ℕ) → 03-Exercises.is-bijection (f n n₁)" class="Function">f-is-bijection</a> <a id="6637" class="Symbol">:</a> <a id="6639" class="Symbol">(</a><a id="6640" href="03-Exercises.html#6640" class="Bound">n</a> <a id="6642" class="Symbol">:</a> <a id="6644" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="6645" class="Symbol">)</a> <a id="6647" class="Symbol">→</a> <a id="6649" href="03-Exercises.html#2813" data-type="(f : A → B) → general-notation.Type" class="Record">is-bijection</a> <a id="6662" class="Symbol">(</a><a id="6663" href="03-Exercises.html#5804" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin n → 03-Exercises.Fin&#39; n" class="Function">f</a> <a id="6665" href="03-Exercises.html#6640" class="Bound">n</a><a id="6666" class="Symbol">)</a>
  <a id="6670" href="03-Exercises.html#6622" data-type="(n n₁ : Fin.ℕ) → 03-Exercises.is-bijection (f n n₁)" class="Function">f-is-bijection</a> <a id="6685" href="03-Exercises.html#6685" class="Bound">n</a> <a id="6687" class="Symbol">=</a> <a id="6689" class="Keyword">record</a> <a id="6696" class="Symbol">{</a> <a id="6698" href="03-Exercises.html#2896" data-type="03-Exercises.is-bijection f → B → A" class="Field">inverse</a> <a id="6706" class="Symbol">=</a> <a id="6708" href="03-Exercises.html#5890" data-type="Fin.ℕ → (n : Fin.ℕ) → 03-Exercises.Fin&#39; n → 03-Exercises.Fin n" class="Function">g</a> <a id="6710" href="03-Exercises.html#6685" class="Bound">n</a> <a id="6712" class="Symbol">;</a> <a id="6714" href="03-Exercises.html#2914" data-type="(r : 03-Exercises.is-bijection f) →
(03-Exercises.is-bijection.inverse r products.∘ f) 03-Exercises.∼
products.id" class="Field">η</a> <a id="6716" class="Symbol">=</a> <a id="6718" href="03-Exercises.html#5976" data-type="(n n₁ : Fin.ℕ) →
(g n n₁ products.∘ f n n₁) 03-Exercises.∼ products.id" class="Function">gf</a> <a id="6721" href="03-Exercises.html#6685" class="Bound">n</a> <a id="6723" class="Symbol">;</a> <a id="6725" href="03-Exercises.html#2943" data-type="(r : 03-Exercises.is-bijection f) →
(f products.∘ 03-Exercises.is-bijection.inverse r) 03-Exercises.∼
products.id" class="Field">ε</a> <a id="6727" class="Symbol">=</a> <a id="6729" href="03-Exercises.html#6297" data-type="(n n₁ : Fin.ℕ) →
(f n n₁ products.∘ g n n₁) 03-Exercises.∼ products.id" class="Function">fg</a> <a id="6732" href="03-Exercises.html#6685" class="Bound">n</a><a id="6733" class="Symbol">}</a>
</pre>
<h2 id="part-iv-minimal-elements-in-the-natural-numbers">Part IV –
minimal elements in the natural numbers</h2>
<p>In this section we establish some definitions which are needed to
state and prove the well-ordering principle of the natural numbers.</p>
<h3 id="exercise-6">Exercise 6 (⋆)</h3>
<p>Give the recursive definition of the less than or equals relation on
the natural numbers.</p>
<pre class="Agda"><a id="_≤₁_"></a><a id="7049" href="03-Exercises.html#7049" data-type="Fin.ℕ → Fin.ℕ → general-notation.Type" class="Function Operator">_≤₁_</a> <a id="7054" class="Symbol">:</a> <a id="7056" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="7058" class="Symbol">→</a> <a id="7060" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="7062" class="Symbol">→</a> <a id="7064" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a>
<a id="7069" class="Number">0</a>     <a id="7075" href="03-Exercises.html#7049" data-type="Fin.ℕ → Fin.ℕ → general-notation.Type" class="Function Operator">≤₁</a> <a id="7078" href="03-Exercises.html#7078" class="Bound">y</a>     <a id="7084" class="Symbol">=</a> <a id="7086" class="Hole">{!!}</a>
<a id="7091" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="7095" href="03-Exercises.html#7095" class="Bound">x</a> <a id="7097" href="03-Exercises.html#7049" data-type="Fin.ℕ → Fin.ℕ → general-notation.Type" class="Function Operator">≤₁</a> <a id="7100" class="Number">0</a>     <a id="7106" class="Symbol">=</a> <a id="7108" class="Hole">{!!}</a>
<a id="7113" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="7117" href="03-Exercises.html#7117" class="Bound">x</a> <a id="7119" href="03-Exercises.html#7049" data-type="Fin.ℕ → Fin.ℕ → general-notation.Type" class="Function Operator">≤₁</a> <a id="7122" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="7126" href="03-Exercises.html#7126" class="Bound">y</a> <a id="7128" class="Symbol">=</a> <a id="7130" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-7">Exercise 7 (⋆)</h3>
<p>Given a type family <code>P</code> over the naturals, a lower bound
<code>n</code> is a natural number such that for all other naturals
<code>m</code>, we have that if <code>P(m)</code> holds,
then<code>n ≤₁ m</code>. Translate this definition into HoTT.</p>
<pre class="Agda"><a id="is-lower-bound"></a><a id="7369" href="03-Exercises.html#7369" data-type="(Fin.ℕ → general-notation.Type) → Fin.ℕ → general-notation.Type" class="Function">is-lower-bound</a> <a id="7384" class="Symbol">:</a> <a id="7386" class="Symbol">(</a><a id="7387" href="03-Exercises.html#7387" class="Bound">P</a> <a id="7389" class="Symbol">:</a> <a id="7391" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="7393" class="Symbol">→</a> <a id="7395" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="7399" class="Symbol">)</a> <a id="7401" class="Symbol">(</a><a id="7402" href="03-Exercises.html#7402" class="Bound">n</a> <a id="7404" class="Symbol">:</a> <a id="7406" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="7407" class="Symbol">)</a> <a id="7409" class="Symbol">→</a> <a id="7411" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a>
<a id="7416" href="03-Exercises.html#7369" data-type="(Fin.ℕ → general-notation.Type) → Fin.ℕ → general-notation.Type" class="Function">is-lower-bound</a> <a id="7431" href="03-Exercises.html#7431" class="Bound">P</a> <a id="7433" href="03-Exercises.html#7433" class="Bound">n</a> <a id="7435" class="Symbol">=</a> <a id="7437" class="Hole">{!!}</a>
</pre>
We define the type of minimal elements of a type family over the
naturals.
<pre class="Agda"><a id="minimal-element"></a><a id="7530" href="03-Exercises.html#7530" data-type="(Fin.ℕ → general-notation.Type) → general-notation.Type" class="Function">minimal-element</a> <a id="7546" class="Symbol">:</a> <a id="7548" class="Symbol">(</a><a id="7549" href="03-Exercises.html#7549" class="Bound">P</a> <a id="7551" class="Symbol">:</a> <a id="7553" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="7555" class="Symbol">→</a> <a id="7557" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="7561" class="Symbol">)</a> <a id="7563" class="Symbol">→</a> <a id="7565" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a>
<a id="7570" href="03-Exercises.html#7530" data-type="(Fin.ℕ → general-notation.Type) → general-notation.Type" class="Function">minimal-element</a> <a id="7586" href="03-Exercises.html#7586" class="Bound">P</a> <a id="7588" class="Symbol">=</a> <a id="7590" href="sums.html#3608" data-type="(A : general-notation.Type) →
(A → general-notation.Type) → general-notation.Type" class="Function">Σ</a> <a id="7592" href="03-Exercises.html#7592" class="Bound">n</a> <a id="7594" href="sums.html#3608" data-type="(A : general-notation.Type) →
(A → general-notation.Type) → general-notation.Type" class="Function">꞉</a> <a id="7596" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="7598" href="sums.html#3608" data-type="(A : general-notation.Type) →
(A → general-notation.Type) → general-notation.Type" class="Function">,</a> <a id="7600" class="Symbol">(</a><a id="7601" href="03-Exercises.html#7586" class="Bound">P</a> <a id="7603" href="03-Exercises.html#7592" class="Bound">n</a><a id="7604" class="Symbol">)</a> <a id="7606" href="binary-products.html#670" data-type="general-notation.Type →
general-notation.Type → general-notation.Type" class="Function Operator">×</a> <a id="7608" class="Symbol">(</a><a id="7609" href="03-Exercises.html#7369" data-type="(Fin.ℕ → general-notation.Type) → Fin.ℕ → general-notation.Type" class="Function">is-lower-bound</a> <a id="7624" href="03-Exercises.html#7586" class="Bound">P</a> <a id="7626" href="03-Exercises.html#7592" class="Bound">n</a><a id="7627" class="Symbol">)</a>
</pre>
<h3 id="exercise-8">Exercise 8 (⋆)</h3>
Prove that all numbers are at least as large as zero.
<pre class="Agda"><a id="leq-zero"></a><a id="7716" href="03-Exercises.html#7716" data-type="(n : Fin.ℕ) → 0 03-Exercises.≤₁ n" class="Function">leq-zero</a> <a id="7725" class="Symbol">:</a> <a id="7727" class="Symbol">(</a><a id="7728" href="03-Exercises.html#7728" class="Bound">n</a> <a id="7730" class="Symbol">:</a> <a id="7732" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="7733" class="Symbol">)</a> <a id="7735" class="Symbol">→</a> <a id="7737" class="Number">0</a> <a id="7739" href="03-Exercises.html#7049" data-type="Fin.ℕ → Fin.ℕ → general-notation.Type" class="Function Operator">≤₁</a> <a id="7742" href="03-Exercises.html#7728" class="Bound">n</a>
<a id="7744" href="03-Exercises.html#7716" data-type="(n : Fin.ℕ) → 0 03-Exercises.≤₁ n" class="Function">leq-zero</a> <a id="7753" href="03-Exercises.html#7753" class="Bound">n</a> <a id="7755" class="Symbol">=</a> <a id="7757" class="Hole">{!!}</a>
</pre>
<h2 id="part-v-the-well-ordering-principle-of-ℕ">Part V – The
well-ordering principle of ℕ</h2>
<p>Classically, the well-ordering principle states that every non-empty
set of natural numbers has a least element.</p>
In HoTT, such subsets can be translated as decidable type family. Recall
the definition of decidability:
<pre class="Agda"><a id="8042" class="Keyword">open</a> <a id="8047" class="Keyword">import</a> <a id="8054" href="decidability.html" class="Module">decidability</a>
  <a id="8069" class="Keyword">using</a> <a id="8075" class="Symbol">(</a><a id="8076" href="decidability.html#2635" data-type="general-notation.Type → general-notation.Type" class="Function">is-decidable</a><a id="8088" class="Symbol">;</a> <a id="8090" href="decidability.html#5334" data-type="(X → general-notation.Type) → general-notation.Type" class="Function">is-decidable-predicate</a><a id="8112" class="Symbol">)</a>
</pre>
The well-ordering principle reads
<pre class="Agda"><a id="Well-ordering-principle"></a><a id="8161" href="03-Exercises.html#8161" data-type="Set₁" class="Function">Well-ordering-principle</a> <a id="8185" class="Symbol">=</a> <a id="8187" class="Symbol">(</a><a id="8188" href="03-Exercises.html#8188" class="Bound">P</a> <a id="8190" class="Symbol">:</a> <a id="8192" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="8194" class="Symbol">→</a> <a id="8196" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="8200" class="Symbol">)</a> <a id="8202" class="Symbol">→</a> <a id="8204" class="Symbol">(</a><a id="8205" href="03-Exercises.html#8205" class="Bound">d</a> <a id="8207" class="Symbol">:</a> <a id="8209" href="decidability.html#5334" data-type="(X → general-notation.Type) → general-notation.Type" class="Function">is-decidable-predicate</a> <a id="8232" href="03-Exercises.html#8188" class="Bound">P</a><a id="8233" class="Symbol">)</a> <a id="8235" class="Symbol">→</a> <a id="8237" class="Symbol">(</a><a id="8238" href="03-Exercises.html#8238" class="Bound">n</a> <a id="8240" class="Symbol">:</a> <a id="8242" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="8243" class="Symbol">)</a> <a id="8245" class="Symbol">→</a> <a id="8247" href="03-Exercises.html#8188" class="Bound">P</a> <a id="8249" href="03-Exercises.html#8238" class="Bound">n</a> <a id="8251" class="Symbol">→</a> <a id="8253" href="03-Exercises.html#7530" data-type="(Fin.ℕ → general-notation.Type) → general-notation.Type" class="Function">minimal-element</a> <a id="8269" href="03-Exercises.html#8188" class="Bound">P</a>
</pre>
<p>We shall prove this statement via induction on <code>n</code>. In
order to make the proof more readable, we first prove two lemmas.</p>
<h3 id="exercise-9">Exercise 9 (🌶)</h3>
<p>What is the statement of <code>is-minimal-element-suc</code> under
the Curry-Howard interpretation? Prove this lemma.</p>
<pre class="Agda"><a id="is-minimal-element-suc"></a><a id="8534" href="03-Exercises.html#8534" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(m : Fin.ℕ) →
P (Fin.suc m) →
03-Exercises.is-lower-bound (λ x → P (Fin.suc x)) m →
empty-type.¬ P 0 → 03-Exercises.is-lower-bound P (Fin.suc m)" class="Function">is-minimal-element-suc</a> <a id="8557" class="Symbol">:</a>
  <a id="8561" class="Symbol">(</a><a id="8562" href="03-Exercises.html#8562" class="Bound">P</a> <a id="8564" class="Symbol">:</a> <a id="8566" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="8568" class="Symbol">→</a> <a id="8570" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="8574" class="Symbol">)</a> <a id="8576" class="Symbol">(</a><a id="8577" href="03-Exercises.html#8577" class="Bound">d</a> <a id="8579" class="Symbol">:</a> <a id="8581" href="decidability.html#5334" data-type="(X → general-notation.Type) → general-notation.Type" class="Function">is-decidable-predicate</a> <a id="8604" href="03-Exercises.html#8562" class="Bound">P</a><a id="8605" class="Symbol">)</a>
  <a id="8609" class="Symbol">(</a><a id="8610" href="03-Exercises.html#8610" class="Bound">m</a> <a id="8612" class="Symbol">:</a> <a id="8614" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="8615" class="Symbol">)</a> <a id="8617" class="Symbol">(</a><a id="8618" href="03-Exercises.html#8618" class="Bound">pm</a> <a id="8621" class="Symbol">:</a> <a id="8623" href="03-Exercises.html#8562" class="Bound">P</a> <a id="8625" class="Symbol">(</a><a id="8626" class="InductiveConstructor">suc</a> <a id="8630" href="03-Exercises.html#8610" class="Bound">m</a><a id="8631" class="Symbol">))</a>
  <a id="8636" class="Symbol">(</a><a id="8637" href="03-Exercises.html#8637" class="Bound">is-lower-bound-m</a> <a id="8654" class="Symbol">:</a> <a id="8656" href="03-Exercises.html#7369" data-type="(Fin.ℕ → general-notation.Type) → Fin.ℕ → general-notation.Type" class="Function">is-lower-bound</a> <a id="8671" class="Symbol">(λ</a> <a id="8674" href="03-Exercises.html#8674" class="Bound">x</a> <a id="8676" class="Symbol">→</a> <a id="8678" href="03-Exercises.html#8562" class="Bound">P</a> <a id="8680" class="Symbol">(</a><a id="8681" class="InductiveConstructor">suc</a> <a id="8685" href="03-Exercises.html#8674" class="Bound">x</a><a id="8686" class="Symbol">))</a> <a id="8689" href="03-Exercises.html#8610" class="Bound">m</a><a id="8690" class="Symbol">)</a> <a id="8692" class="Symbol">→</a>
  <a id="8696" href="empty-type.html#1685" data-type="general-notation.Type → general-notation.Type" class="Function Operator">¬</a> <a id="8698" class="Symbol">(</a><a id="8699" href="03-Exercises.html#8562" class="Bound">P</a> <a id="8701" class="Number">0</a><a id="8702" class="Symbol">)</a> <a id="8704" class="Symbol">→</a> <a id="8706" href="03-Exercises.html#7369" data-type="(Fin.ℕ → general-notation.Type) → Fin.ℕ → general-notation.Type" class="Function">is-lower-bound</a> <a id="8721" href="03-Exercises.html#8562" class="Bound">P</a> <a id="8723" class="Symbol">(</a><a id="8724" class="InductiveConstructor">suc</a> <a id="8728" href="03-Exercises.html#8610" class="Bound">m</a><a id="8729" class="Symbol">)</a>
<a id="8731" href="03-Exercises.html#8534" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(m : Fin.ℕ) →
P (Fin.suc m) →
03-Exercises.is-lower-bound (λ x → P (Fin.suc x)) m →
empty-type.¬ P 0 → 03-Exercises.is-lower-bound P (Fin.suc m)" class="Function">is-minimal-element-suc</a> <a id="8754" href="03-Exercises.html#8754" class="Bound">P</a> <a id="8756" href="03-Exercises.html#8756" class="Bound">d</a> <a id="8758" href="03-Exercises.html#8758" class="Bound">m</a> <a id="8760" href="03-Exercises.html#8760" class="Bound">pm</a> <a id="8763" href="03-Exercises.html#8763" class="Bound">is-lower-bound</a> <a id="8778" href="03-Exercises.html#8778" class="Bound">neg-p0</a> <a id="8785" class="Symbol">=</a> <a id="8787" class="Hole">{!   !}</a>
</pre>
<h3 id="exercise-10">Exercise 10 (🌶)</h3>
<p>What is the statement of <code>well-ordering-principle-suc</code>
under the Curry-Howard interpretation? Prove this lemma.</p>
<pre class="Agda"><a id="well-ordering-principle-suc"></a><a id="8942" href="03-Exercises.html#8942" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) →
P (Fin.suc n) →
decidability.is-decidable (P 0) →
03-Exercises.minimal-element (λ m → P (Fin.suc m)) →
03-Exercises.minimal-element P" class="Function">well-ordering-principle-suc</a> <a id="8970" class="Symbol">:</a>
  <a id="8974" class="Symbol">(</a><a id="8975" href="03-Exercises.html#8975" class="Bound">P</a> <a id="8977" class="Symbol">:</a> <a id="8979" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="8981" class="Symbol">→</a> <a id="8983" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="8987" class="Symbol">)</a> <a id="8989" class="Symbol">(</a><a id="8990" href="03-Exercises.html#8990" class="Bound">d</a> <a id="8992" class="Symbol">:</a> <a id="8994" href="decidability.html#5334" data-type="(X → general-notation.Type) → general-notation.Type" class="Function">is-decidable-predicate</a> <a id="9017" href="03-Exercises.html#8975" class="Bound">P</a><a id="9018" class="Symbol">)</a>
  <a id="9022" class="Symbol">(</a><a id="9023" href="03-Exercises.html#9023" class="Bound">n</a> <a id="9025" class="Symbol">:</a> <a id="9027" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="9028" class="Symbol">)</a> <a id="9030" class="Symbol">(</a><a id="9031" href="03-Exercises.html#9031" class="Bound">p</a> <a id="9033" class="Symbol">:</a> <a id="9035" href="03-Exercises.html#8975" class="Bound">P</a> <a id="9037" class="Symbol">(</a><a id="9038" class="InductiveConstructor">suc</a> <a id="9042" href="03-Exercises.html#9023" class="Bound">n</a><a id="9043" class="Symbol">))</a> <a id="9046" class="Symbol">→</a>
  <a id="9050" href="decidability.html#2635" data-type="general-notation.Type → general-notation.Type" class="Function">is-decidable</a> <a id="9063" class="Symbol">(</a><a id="9064" href="03-Exercises.html#8975" class="Bound">P</a> <a id="9066" class="Number">0</a><a id="9067" class="Symbol">)</a> <a id="9069" class="Symbol">→</a>
  <a id="9073" href="03-Exercises.html#7530" data-type="(Fin.ℕ → general-notation.Type) → general-notation.Type" class="Function">minimal-element</a> <a id="9089" class="Symbol">(λ</a> <a id="9092" href="03-Exercises.html#9092" class="Bound">m</a> <a id="9094" class="Symbol">→</a> <a id="9096" href="03-Exercises.html#8975" class="Bound">P</a> <a id="9098" class="Symbol">(</a><a id="9099" class="InductiveConstructor">suc</a> <a id="9103" href="03-Exercises.html#9092" class="Bound">m</a><a id="9104" class="Symbol">))</a> <a id="9107" class="Symbol">→</a> <a id="9109" href="03-Exercises.html#7530" data-type="(Fin.ℕ → general-notation.Type) → general-notation.Type" class="Function">minimal-element</a> <a id="9125" href="03-Exercises.html#8975" class="Bound">P</a>
<a id="9127" href="03-Exercises.html#8942" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) →
P (Fin.suc n) →
decidability.is-decidable (P 0) →
03-Exercises.minimal-element (λ m → P (Fin.suc m)) →
03-Exercises.minimal-element P" class="Function">well-ordering-principle-suc</a> <a id="9155" href="03-Exercises.html#9155" class="Bound">P</a> <a id="9157" href="03-Exercises.html#9157" class="Bound">d</a> <a id="9159" href="03-Exercises.html#9159" class="Bound">n</a> <a id="9161" href="03-Exercises.html#9161" class="Bound">p</a> <a id="9163" class="Symbol">(</a><a id="9164" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="9168" href="03-Exercises.html#9168" class="Bound">p0</a><a id="9170" class="Symbol">)</a> <a id="9172" class="Symbol">_</a>  <a id="9175" class="Symbol">=</a> <a id="9177" class="Hole">{!!}</a>
<a id="9182" href="03-Exercises.html#8942" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) →
P (Fin.suc n) →
decidability.is-decidable (P 0) →
03-Exercises.minimal-element (λ m → P (Fin.suc m)) →
03-Exercises.minimal-element P" class="Function">well-ordering-principle-suc</a> <a id="9210" href="03-Exercises.html#9210" class="Bound">P</a> <a id="9212" href="03-Exercises.html#9212" class="Bound">d</a> <a id="9214" href="03-Exercises.html#9214" class="Bound">n</a> <a id="9216" href="03-Exercises.html#9216" class="Bound">p</a> <a id="9218" class="Symbol">(</a><a id="9219" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="9223" href="03-Exercises.html#9223" class="Bound">neg-p0</a><a id="9229" class="Symbol">)</a> <a id="9231" class="Symbol">(</a><a id="9232" href="03-Exercises.html#9232" class="Bound">m</a> <a id="9234" href="sums.html#2522" data-type="(pr₁ : A) (pr₂ : B pr₁) → sums.Σ B" class="InductiveConstructor Operator">,</a> <a id="9236" class="Symbol">(</a><a id="9237" href="03-Exercises.html#9237" class="Bound">pm</a> <a id="9240" href="sums.html#2522" data-type="(pr₁ : A) (pr₂ : B pr₁) → sums.Σ B" class="InductiveConstructor Operator">,</a> <a id="9242" href="03-Exercises.html#9242" class="Bound">is-min-m</a><a id="9250" class="Symbol">))</a> <a id="9253" class="Symbol">=</a> <a id="9255" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-11">Exercise 11 (🌶)</h3>
Use the previous two lemmas to prove the well-ordering principle
<pre class="Agda"><a id="well-ordering-principle"></a><a id="9359" href="03-Exercises.html#9359" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) → P n → 03-Exercises.minimal-element P" class="Function">well-ordering-principle</a> <a id="9383" class="Symbol">:</a> <a id="9385" class="Symbol">(</a><a id="9386" href="03-Exercises.html#9386" class="Bound">P</a> <a id="9388" class="Symbol">:</a> <a id="9390" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="9392" class="Symbol">→</a> <a id="9394" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="9398" class="Symbol">)</a> <a id="9400" class="Symbol">→</a> <a id="9402" class="Symbol">(</a><a id="9403" href="03-Exercises.html#9403" class="Bound">d</a> <a id="9405" class="Symbol">:</a> <a id="9407" href="decidability.html#5334" data-type="(X → general-notation.Type) → general-notation.Type" class="Function">is-decidable-predicate</a> <a id="9430" href="03-Exercises.html#9386" class="Bound">P</a><a id="9431" class="Symbol">)</a> <a id="9433" class="Symbol">→</a> <a id="9435" class="Symbol">(</a><a id="9436" href="03-Exercises.html#9436" class="Bound">n</a> <a id="9438" class="Symbol">:</a> <a id="9440" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="9441" class="Symbol">)</a> <a id="9443" class="Symbol">→</a> <a id="9445" href="03-Exercises.html#9386" class="Bound">P</a> <a id="9447" href="03-Exercises.html#9436" class="Bound">n</a> <a id="9449" class="Symbol">→</a> <a id="9451" href="03-Exercises.html#7530" data-type="(Fin.ℕ → general-notation.Type) → general-notation.Type" class="Function">minimal-element</a> <a id="9467" href="03-Exercises.html#9386" class="Bound">P</a>
<a id="9469" href="03-Exercises.html#9359" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) → P n → 03-Exercises.minimal-element P" class="Function">well-ordering-principle</a> <a id="9493" href="03-Exercises.html#9493" class="Bound">P</a> <a id="9495" href="03-Exercises.html#9495" class="Bound">d</a> <a id="9497" class="Number">0</a> <a id="9499" href="03-Exercises.html#9499" class="Bound">p</a> <a id="9501" class="Symbol">=</a> <a id="9503" class="Hole">{!!}</a>
<a id="9508" href="03-Exercises.html#9359" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) → P n → 03-Exercises.minimal-element P" class="Function">well-ordering-principle</a> <a id="9532" href="03-Exercises.html#9532" class="Bound">P</a> <a id="9534" href="03-Exercises.html#9534" class="Bound">d</a> <a id="9536" class="Symbol">(</a><a id="9537" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="9541" href="03-Exercises.html#9541" class="Bound">n</a><a id="9542" class="Symbol">)</a> <a id="9544" href="03-Exercises.html#9544" class="Bound">p</a> <a id="9546" class="Symbol">=</a> <a id="9548" href="03-Exercises.html#8942" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) →
P (Fin.suc n) →
decidability.is-decidable (P 0) →
03-Exercises.minimal-element (λ m → P (Fin.suc m)) →
03-Exercises.minimal-element P" class="Function">well-ordering-principle-suc</a> <a id="9576" href="03-Exercises.html#9532" class="Bound">P</a> <a id="9578" href="03-Exercises.html#9534" class="Bound">d</a> <a id="9580" href="03-Exercises.html#9541" class="Bound">n</a> <a id="9582" href="03-Exercises.html#9544" class="Bound">p</a> <a id="9584" class="Symbol">(</a><a id="9585" href="03-Exercises.html#9534" class="Bound">d</a> <a id="9587" class="Number">0</a><a id="9588" class="Symbol">)</a> <a id="9590" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-12">Exercise 12 (🌶)</h3>
<p>Prove that the well-ordering principle returns 0 if <code>P 0</code>
holds.</p>
<pre class="Agda"><a id="is-zero-well-ordering-principle-suc"></a><a id="9695" href="03-Exercises.html#9695" data-type="(P : Fin.ℕ → general-notation.Type)
(d : decidability.is-decidable-predicate P) (n : Fin.ℕ)
(p : P (Fin.suc n)) (d0 : decidability.is-decidable (P 0))
(x : 03-Exercises.minimal-element (λ m → P (Fin.suc m))) →
P 0 →
sums.pr₁ (03-Exercises.well-ordering-principle-suc P d n p d0 x)
identity-type.≡ 0" class="Function">is-zero-well-ordering-principle-suc</a> <a id="9731" class="Symbol">:</a>
  <a id="9735" class="Symbol">(</a><a id="9736" href="03-Exercises.html#9736" class="Bound">P</a> <a id="9738" class="Symbol">:</a> <a id="9740" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="9742" class="Symbol">→</a> <a id="9744" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="9748" class="Symbol">)</a> <a id="9750" class="Symbol">(</a><a id="9751" href="03-Exercises.html#9751" class="Bound">d</a> <a id="9753" class="Symbol">:</a> <a id="9755" href="decidability.html#5334" data-type="(X → general-notation.Type) → general-notation.Type" class="Function">is-decidable-predicate</a> <a id="9778" href="03-Exercises.html#9736" class="Bound">P</a><a id="9779" class="Symbol">)</a>
  <a id="9783" class="Symbol">(</a><a id="9784" href="03-Exercises.html#9784" class="Bound">n</a> <a id="9786" class="Symbol">:</a> <a id="9788" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="9789" class="Symbol">)</a> <a id="9791" class="Symbol">(</a><a id="9792" href="03-Exercises.html#9792" class="Bound">p</a> <a id="9794" class="Symbol">:</a> <a id="9796" href="03-Exercises.html#9736" class="Bound">P</a> <a id="9798" class="Symbol">(</a><a id="9799" class="InductiveConstructor">suc</a> <a id="9803" href="03-Exercises.html#9784" class="Bound">n</a><a id="9804" class="Symbol">))</a> <a id="9807" class="Symbol">(</a><a id="9808" href="03-Exercises.html#9808" class="Bound">d0</a> <a id="9811" class="Symbol">:</a> <a id="9813" href="decidability.html#2635" data-type="general-notation.Type → general-notation.Type" class="Function">is-decidable</a> <a id="9826" class="Symbol">(</a><a id="9827" href="03-Exercises.html#9736" class="Bound">P</a> <a id="9829" class="Number">0</a><a id="9830" class="Symbol">))</a> <a id="9833" class="Symbol">→</a>
  <a id="9837" class="Symbol">(</a><a id="9838" href="03-Exercises.html#9838" class="Bound">x</a> <a id="9840" class="Symbol">:</a> <a id="9842" href="03-Exercises.html#7530" data-type="(Fin.ℕ → general-notation.Type) → general-notation.Type" class="Function">minimal-element</a> <a id="9858" class="Symbol">(λ</a> <a id="9861" href="03-Exercises.html#9861" class="Bound">m</a> <a id="9863" class="Symbol">→</a> <a id="9865" href="03-Exercises.html#9736" class="Bound">P</a> <a id="9867" class="Symbol">(</a><a id="9868" class="InductiveConstructor">suc</a> <a id="9872" href="03-Exercises.html#9861" class="Bound">m</a><a id="9873" class="Symbol">)))</a> <a id="9877" class="Symbol">(</a><a id="9878" href="03-Exercises.html#9878" class="Bound">p0</a> <a id="9881" class="Symbol">:</a> <a id="9883" href="03-Exercises.html#9736" class="Bound">P</a> <a id="9885" class="Number">0</a><a id="9886" class="Symbol">)</a> <a id="9888" class="Symbol">→</a>
  <a id="9892" class="Symbol">(</a><a id="9893" href="sums.html#2535" data-type="sums.Σ B → A" class="Field">pr₁</a> <a id="9897" class="Symbol">(</a><a id="9898" href="03-Exercises.html#8942" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) →
P (Fin.suc n) →
decidability.is-decidable (P 0) →
03-Exercises.minimal-element (λ m → P (Fin.suc m)) →
03-Exercises.minimal-element P" class="Function">well-ordering-principle-suc</a> <a id="9926" href="03-Exercises.html#9736" class="Bound">P</a> <a id="9928" href="03-Exercises.html#9751" class="Bound">d</a> <a id="9930" href="03-Exercises.html#9784" class="Bound">n</a> <a id="9932" href="03-Exercises.html#9792" class="Bound">p</a> <a id="9934" href="03-Exercises.html#9808" class="Bound">d0</a> <a id="9937" href="03-Exercises.html#9838" class="Bound">x</a><a id="9938" class="Symbol">))</a> <a id="9941" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="9943" class="Number">0</a>
<a id="9945" href="03-Exercises.html#9695" data-type="(P : Fin.ℕ → general-notation.Type)
(d : decidability.is-decidable-predicate P) (n : Fin.ℕ)
(p : P (Fin.suc n)) (d0 : decidability.is-decidable (P 0))
(x : 03-Exercises.minimal-element (λ m → P (Fin.suc m))) →
P 0 →
sums.pr₁ (03-Exercises.well-ordering-principle-suc P d n p d0 x)
identity-type.≡ 0" class="Function">is-zero-well-ordering-principle-suc</a> <a id="9981" href="03-Exercises.html#9981" class="Bound">P</a> <a id="9983" href="03-Exercises.html#9983" class="Bound">d</a> <a id="9985" href="03-Exercises.html#9985" class="Bound">n</a> <a id="9987" href="03-Exercises.html#9987" class="Bound">p</a> <a id="9989" class="Symbol">(</a><a id="9990" href="binary-sums.html#703" data-type="A → A binary-sums.∔ B" class="InductiveConstructor">inl</a> <a id="9994" href="03-Exercises.html#9994" class="Bound">p0</a><a id="9996" class="Symbol">)</a> <a id="9998" href="03-Exercises.html#9998" class="Bound">x</a> <a id="10000" href="03-Exercises.html#10000" class="Bound">q0</a> <a id="10003" class="Symbol">=</a> <a id="10005" class="Hole">{!!}</a>
<a id="10010" href="03-Exercises.html#9695" data-type="(P : Fin.ℕ → general-notation.Type)
(d : decidability.is-decidable-predicate P) (n : Fin.ℕ)
(p : P (Fin.suc n)) (d0 : decidability.is-decidable (P 0))
(x : 03-Exercises.minimal-element (λ m → P (Fin.suc m))) →
P 0 →
sums.pr₁ (03-Exercises.well-ordering-principle-suc P d n p d0 x)
identity-type.≡ 0" class="Function">is-zero-well-ordering-principle-suc</a> <a id="10046" href="03-Exercises.html#10046" class="Bound">P</a> <a id="10048" href="03-Exercises.html#10048" class="Bound">d</a> <a id="10050" href="03-Exercises.html#10050" class="Bound">n</a> <a id="10052" href="03-Exercises.html#10052" class="Bound">p</a> <a id="10054" class="Symbol">(</a><a id="10055" href="binary-sums.html#720" data-type="B → A binary-sums.∔ B" class="InductiveConstructor">inr</a> <a id="10059" href="03-Exercises.html#10059" class="Bound">np0</a><a id="10062" class="Symbol">)</a> <a id="10064" href="03-Exercises.html#10064" class="Bound">x</a> <a id="10066" href="03-Exercises.html#10066" class="Bound">q0</a> <a id="10069" class="Symbol">=</a> <a id="10071" class="Hole">{!!}</a>

<a id="is-zero-well-ordering-principle"></a><a id="10077" href="03-Exercises.html#10077" data-type="(P : Fin.ℕ → general-notation.Type)
(d : decidability.is-decidable-predicate P) (n : Fin.ℕ)
(pn : P n) →
P 0 →
sums.pr₁ (03-Exercises.well-ordering-principle P d n pn)
identity-type.≡ 0" class="Function">is-zero-well-ordering-principle</a> <a id="10109" class="Symbol">:</a>
  <a id="10113" class="Symbol">(</a><a id="10114" href="03-Exercises.html#10114" class="Bound">P</a> <a id="10116" class="Symbol">:</a> <a id="10118" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="10120" class="Symbol">→</a> <a id="10122" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="10126" class="Symbol">)</a> <a id="10128" class="Symbol">(</a><a id="10129" href="03-Exercises.html#10129" class="Bound">d</a> <a id="10131" class="Symbol">:</a> <a id="10133" href="decidability.html#5334" data-type="(X → general-notation.Type) → general-notation.Type" class="Function">is-decidable-predicate</a> <a id="10156" href="03-Exercises.html#10114" class="Bound">P</a><a id="10157" class="Symbol">)</a> <a id="10159" class="Symbol">→</a>
  <a id="10163" class="Symbol">(</a><a id="10164" href="03-Exercises.html#10164" class="Bound">n</a> <a id="10166" class="Symbol">:</a> <a id="10168" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="10169" class="Symbol">)</a> <a id="10171" class="Symbol">→</a> <a id="10173" class="Symbol">(</a><a id="10174" href="03-Exercises.html#10174" class="Bound">pn</a> <a id="10177" class="Symbol">:</a> <a id="10179" href="03-Exercises.html#10114" class="Bound">P</a> <a id="10181" href="03-Exercises.html#10164" class="Bound">n</a><a id="10182" class="Symbol">)</a> <a id="10184" class="Symbol">→</a>
  <a id="10188" href="03-Exercises.html#10114" class="Bound">P</a> <a id="10190" class="Number">0</a> <a id="10192" class="Symbol">→</a>
  <a id="10196" href="sums.html#2535" data-type="sums.Σ B → A" class="Field">pr₁</a> <a id="10200" class="Symbol">(</a><a id="10201" href="03-Exercises.html#9359" data-type="(P : Fin.ℕ → general-notation.Type) →
decidability.is-decidable-predicate P →
(n : Fin.ℕ) → P n → 03-Exercises.minimal-element P" class="Function">well-ordering-principle</a> <a id="10225" href="03-Exercises.html#10114" class="Bound">P</a> <a id="10227" href="03-Exercises.html#10129" class="Bound">d</a> <a id="10229" href="03-Exercises.html#10164" class="Bound">n</a> <a id="10231" href="03-Exercises.html#10174" class="Bound">pn</a><a id="10233" class="Symbol">)</a> <a id="10235" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="10237" class="Number">0</a>
<a id="10239" href="03-Exercises.html#10077" data-type="(P : Fin.ℕ → general-notation.Type)
(d : decidability.is-decidable-predicate P) (n : Fin.ℕ)
(pn : P n) →
P 0 →
sums.pr₁ (03-Exercises.well-ordering-principle P d n pn)
identity-type.≡ 0" class="Function">is-zero-well-ordering-principle</a> <a id="10271" href="03-Exercises.html#10271" class="Bound">P</a> <a id="10273" href="03-Exercises.html#10273" class="Bound">d</a> <a id="10275" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a> <a id="10280" href="03-Exercises.html#10280" class="Bound">p</a> <a id="10282" href="03-Exercises.html#10282" class="Bound">p0</a> <a id="10285" class="Symbol">=</a> <a id="10287" class="Hole">{!   !}</a>
<a id="10295" href="03-Exercises.html#10077" data-type="(P : Fin.ℕ → general-notation.Type)
(d : decidability.is-decidable-predicate P) (n : Fin.ℕ)
(pn : P n) →
P 0 →
sums.pr₁ (03-Exercises.well-ordering-principle P d n pn)
identity-type.≡ 0" class="Function">is-zero-well-ordering-principle</a> <a id="10327" href="03-Exercises.html#10327" class="Bound">P</a> <a id="10329" href="03-Exercises.html#10329" class="Bound">d</a> <a id="10331" class="Symbol">(</a><a id="10332" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="10336" href="03-Exercises.html#10336" class="Bound">m</a><a id="10337" class="Symbol">)</a> <a id="10339" href="03-Exercises.html#10339" class="Bound">pm</a> <a id="10342" class="Symbol">=</a>
  <a id="10346" href="03-Exercises.html#9695" data-type="(P : Fin.ℕ → general-notation.Type)
(d : decidability.is-decidable-predicate P) (n : Fin.ℕ)
(p : P (Fin.suc n)) (d0 : decidability.is-decidable (P 0))
(x : 03-Exercises.minimal-element (λ m → P (Fin.suc m))) →
P 0 →
sums.pr₁ (03-Exercises.well-ordering-principle-suc P d n p d0 x)
identity-type.≡ 0" class="Function">is-zero-well-ordering-principle-suc</a> <a id="10382" href="03-Exercises.html#10327" class="Bound">P</a> <a id="10384" href="03-Exercises.html#10329" class="Bound">d</a> <a id="10386" href="03-Exercises.html#10336" class="Bound">m</a> <a id="10388" href="03-Exercises.html#10339" class="Bound">pm</a> <a id="10391" class="Symbol">(</a><a id="10392" href="03-Exercises.html#10329" class="Bound">d</a> <a id="10394" class="Number">0</a><a id="10395" class="Symbol">)</a> <a id="10397" class="Hole">{!!}</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em;
    border: 1px solid black; }
  table th {
    border-bottom: 2px solid black; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
