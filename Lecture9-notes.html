<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<h1 id="lecture-9">Lecture 9</h1>
<p>Contents:</p>
<ul>
<li>More about homogeneous composition (<code>hcomp</code>)</li>
<li>Cubical univalence (Glue types)</li>
<li>The structure identity principle (SIP)</li>
</ul>
<pre class="Agda"><a id="156" class="Symbol">{-#</a> <a id="160" class="Keyword">OPTIONS</a> <a id="168" class="Pragma">--cubical</a> <a id="178" class="Symbol">#-}</a>

<a id="183" class="Keyword">module</a> <a id="190" href="Lecture9-notes.html" class="Module">Lecture9-notes</a> <a id="205" class="Keyword">where</a>

<a id="212" class="Keyword">open</a> <a id="217" class="Keyword">import</a> <a id="224" href="cubical-prelude.html" class="Module">cubical-prelude</a>
<a id="240" class="Keyword">open</a> <a id="245" class="Keyword">import</a> <a id="252" href="Lecture7-notes.html" class="Module">Lecture7-notes</a>
<a id="267" class="Keyword">open</a> <a id="272" class="Keyword">import</a> <a id="279" href="Lecture8-notes.html" class="Module">Lecture8-notes</a> <a id="294" class="Keyword">hiding</a> <a id="301" class="Symbol">(</a><a id="302" href="Lecture8-notes.html#11588" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function">compPath</a><a id="310" class="Symbol">)</a>

<a id="313" class="Keyword">private</a>
  <a id="323" class="Keyword">variable</a>
    <a id="336" href="Lecture9-notes.html#336" class="Generalizable">A</a> <a id="338" href="Lecture9-notes.html#338" class="Generalizable">B</a> <a id="340" class="Symbol">:</a> <a id="342" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="347" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a>
</pre>
<h2 id="more-about-homogeneous-composition-hcomp">More about homogeneous
composition (<code>hcomp</code>)</h2>
<p>Recall from Lecture 8: in order to compose two paths we write:</p>
<pre class="Agda"><a id="compPath"></a><a id="475" href="Lecture9-notes.html#475" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function">compPath</a> <a id="484" class="Symbol">:</a> <a id="486" class="Symbol">{</a><a id="487" href="Lecture9-notes.html#487" class="Bound">x</a> <a id="489" href="Lecture9-notes.html#489" class="Bound">y</a> <a id="491" href="Lecture9-notes.html#491" class="Bound">z</a> <a id="493" class="Symbol">:</a> <a id="495" href="Lecture9-notes.html#336" class="Generalizable">A</a><a id="496" class="Symbol">}</a> <a id="498" class="Symbol">→</a> <a id="500" href="Lecture9-notes.html#487" class="Bound">x</a> <a id="502" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="504" href="Lecture9-notes.html#489" class="Bound">y</a> <a id="506" class="Symbol">→</a> <a id="508" href="Lecture9-notes.html#489" class="Bound">y</a> <a id="510" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="512" href="Lecture9-notes.html#491" class="Bound">z</a> <a id="514" class="Symbol">→</a> <a id="516" href="Lecture9-notes.html#487" class="Bound">x</a> <a id="518" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="520" href="Lecture9-notes.html#491" class="Bound">z</a>
<a id="522" href="Lecture9-notes.html#475" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function">compPath</a> <a id="531" class="Symbol">{</a><a id="532" class="Argument">x</a> <a id="534" class="Symbol">=</a> <a id="536" href="Lecture9-notes.html#536" class="Bound">x</a><a id="537" class="Symbol">}</a> <a id="539" href="Lecture9-notes.html#539" class="Bound">p</a> <a id="541" href="Lecture9-notes.html#541" class="Bound">q</a> <a id="543" href="Lecture9-notes.html#543" class="Bound">i</a> <a id="545" class="Symbol">=</a> <a id="547" href="cubical-prelude.html#665" class="Primitive">hcomp</a> <a id="553" class="Symbol">(λ</a> <a id="556" href="Lecture9-notes.html#556" class="Bound">j</a> <a id="558" class="Symbol">→</a> <a id="560" class="Symbol">λ</a> <a id="562" class="Symbol">{</a> <a id="564" class="Symbol">(</a><a id="565" href="Lecture9-notes.html#543" class="Bound">i</a> <a id="567" class="Symbol">=</a> <a id="569" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="571" class="Symbol">)</a> <a id="573" class="Symbol">→</a> <a id="575" href="Lecture9-notes.html#536" class="Bound">x</a>
                                        <a id="617" class="Symbol">;</a> <a id="619" class="Symbol">(</a><a id="620" href="Lecture9-notes.html#543" class="Bound">i</a> <a id="622" class="Symbol">=</a> <a id="624" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="626" class="Symbol">)</a> <a id="628" class="Symbol">→</a> <a id="630" href="Lecture9-notes.html#541" class="Bound">q</a> <a id="632" href="Lecture9-notes.html#556" class="Bound">j</a> <a id="634" class="Symbol">})</a>
                               <a id="668" class="Symbol">(</a><a id="669" href="Lecture9-notes.html#539" class="Bound">p</a> <a id="671" href="Lecture9-notes.html#543" class="Bound">i</a><a id="672" class="Symbol">)</a>
</pre>
<p>This is best understood with the following drawing:</p>
<pre class="text"><code>    x             z
    ^             ^
    ¦             ¦
  x ¦             ¦ q j
    ¦             ¦
    x ----------&gt; y
          p i</code></pre>
<p>In the drawing the direction <code>i</code> goes left-to-right and
<code>j</code> goes bottom-to-top. As we are constructing a path from
<code>x</code> to <code>z</code> along <code>i</code> we have
<code>i : I</code> in the context already and we put <code>p i</code> as
bottom. The direction <code>j</code> that we are doing the composition
in is abstracted in the first argument to <code>hcomp</code>.</p>
<p>As we can see here the <code>hcomp</code> operation has a very
natural geometric motivation. The following YouTube video might be very
helpful to clarify this: https://www.youtube.com/watch?v=MVtlD22Y8SQ</p>
<p>Side remark: this operation is related to lifting conditions for Kan
cubical sets, i.e. it’s a form of open box filling analogous to horn
filling in Kan complexes.</p>
<p>A more natural form of composition of paths in Cubical Agda is
ternary composition:</p>
<pre class="text"><code>         x             w
         ^             ^
         ¦             ¦
 p (~ j) ¦             ¦ r j
         ¦             ¦
         y ----------&gt; z
               q i</code></pre>
<p>This is written <code>p ∙∙ q ∙∙ r</code> in the agda/cubical library
and implemented by:</p>
<pre class="Agda"><a id="_∙∙_∙∙_"></a><a id="1907" href="Lecture9-notes.html#1907" data-type="x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function Operator">_∙∙_∙∙_</a> <a id="1915" class="Symbol">:</a> <a id="1917" class="Symbol">{</a><a id="1918" href="Lecture9-notes.html#1918" class="Bound">x</a> <a id="1920" href="Lecture9-notes.html#1920" class="Bound">y</a> <a id="1922" href="Lecture9-notes.html#1922" class="Bound">z</a> <a id="1924" href="Lecture9-notes.html#1924" class="Bound">w</a> <a id="1926" class="Symbol">:</a> <a id="1928" href="Lecture9-notes.html#336" class="Generalizable">A</a><a id="1929" class="Symbol">}</a> <a id="1931" class="Symbol">→</a> <a id="1933" href="Lecture9-notes.html#1918" class="Bound">x</a> <a id="1935" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="1937" href="Lecture9-notes.html#1920" class="Bound">y</a> <a id="1939" class="Symbol">→</a> <a id="1941" href="Lecture9-notes.html#1920" class="Bound">y</a> <a id="1943" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="1945" href="Lecture9-notes.html#1922" class="Bound">z</a> <a id="1947" class="Symbol">→</a> <a id="1949" href="Lecture9-notes.html#1922" class="Bound">z</a> <a id="1951" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="1953" href="Lecture9-notes.html#1924" class="Bound">w</a> <a id="1955" class="Symbol">→</a> <a id="1957" href="Lecture9-notes.html#1918" class="Bound">x</a> <a id="1959" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="1961" href="Lecture9-notes.html#1924" class="Bound">w</a>
<a id="1963" class="Symbol">(</a><a id="1964" href="Lecture9-notes.html#1964" class="Bound">p</a> <a id="1966" href="Lecture9-notes.html#1907" data-type="x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function Operator">∙∙</a> <a id="1969" href="Lecture9-notes.html#1969" class="Bound">q</a> <a id="1971" href="Lecture9-notes.html#1907" data-type="x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function Operator">∙∙</a> <a id="1974" href="Lecture9-notes.html#1974" class="Bound">r</a><a id="1975" class="Symbol">)</a> <a id="1977" href="Lecture9-notes.html#1977" class="Bound">i</a> <a id="1979" class="Symbol">=</a> <a id="1981" href="cubical-prelude.html#665" class="Primitive">hcomp</a> <a id="1987" class="Symbol">(λ</a> <a id="1990" href="Lecture9-notes.html#1990" class="Bound">j</a> <a id="1992" class="Symbol">→</a> <a id="1994" class="Symbol">λ</a> <a id="1996" class="Symbol">{</a> <a id="1998" class="Symbol">(</a><a id="1999" href="Lecture9-notes.html#1977" class="Bound">i</a> <a id="2001" class="Symbol">=</a> <a id="2003" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="2005" class="Symbol">)</a> <a id="2007" class="Symbol">→</a> <a id="2009" href="Lecture9-notes.html#1964" class="Bound">p</a> <a id="2011" class="Symbol">(</a><a id="2012" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="2014" href="Lecture9-notes.html#1990" class="Bound">j</a><a id="2015" class="Symbol">)</a>
                                 <a id="2050" class="Symbol">;</a> <a id="2052" class="Symbol">(</a><a id="2053" href="Lecture9-notes.html#1977" class="Bound">i</a> <a id="2055" class="Symbol">=</a> <a id="2057" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="2059" class="Symbol">)</a> <a id="2061" class="Symbol">→</a> <a id="2063" href="Lecture9-notes.html#1974" class="Bound">r</a> <a id="2065" href="Lecture9-notes.html#1990" class="Bound">j</a> <a id="2067" class="Symbol">})</a>
                        <a id="2094" class="Symbol">(</a><a id="2095" href="Lecture9-notes.html#1969" class="Bound">q</a> <a id="2097" href="Lecture9-notes.html#1977" class="Bound">i</a><a id="2098" class="Symbol">)</a>
</pre>
<p>Using this we can define <code>compPath</code> much slicker:</p>
<pre class="text"><code>_∙_ : {x y z : A} → x ≡ y → y ≡ z → x ≡ z
p ∙ q = refl ∙∙ p ∙∙ q</code></pre>
<p>In order to understand the second argument to <code>hcomp</code> we
need to talk about partial elements and cubical subtypes. These allow us
to write partially specified n-dimensional cubes (i.e. cubes where some
faces are missing as in the input to <code>hcomp</code>).</p>
<h3 id="partial-elements">Partial elements</h3>
<p>Given an element of the interval <code>r : I</code> there is a
predicate <code>IsOne</code> which represents the constraint
<code>r = i1</code>. This comes with a proof that <code>i1</code> is in
fact equal to <code>i1</code> called <code>1=1 : IsOne i1</code>. We use
Greek letters like <code>φ</code> or <code>ψ</code> when such an
<code>r</code> should be thought of as being in the domain of
<code>IsOne</code>.</p>
<p>Using this we introduce a type of partial elements called
<code>Partial φ A</code>, this is a special version of
<code>IsOne φ → A</code> with a more extensional judgmental equality
(two elements of <code>Partial φ A</code> are considered equal if they
represent the same subcube, so the faces of the cubes can for example be
given in different order and the two elements will still be considered
the same). The idea is that <code>Partial φ A</code> is the type of
cubes in <code>A</code> that are only defined when <code>IsOne φ</code>.
There is also a dependent version of this called
<code>PartialP φ A</code> which allows <code>A</code> to be defined only
when <code>IsOne φ</code>.</p>
<pre class="text"><code>Partial : ∀ {ℓ} → I → Set ℓ → SSet ℓ

PartialP : ∀ {ℓ} → (φ : I) → Partial φ (Set ℓ) → SSet ℓ</code></pre>
<p>Here <code>SSet</code> is the universe of <em>strict</em> sets.</p>
<p>Cubical Agda has a new form of pattern matching that can be used to
introduce partial elements:</p>
<pre class="Agda"><a id="partialBool"></a><a id="3661" href="Lecture9-notes.html#3661" data-type="(i : I) → Partial (primIMax i (primINeg i)) Bool" class="Function">partialBool</a> <a id="3673" class="Symbol">:</a> <a id="3675" class="Symbol">(</a><a id="3676" href="Lecture9-notes.html#3676" class="Bound">i</a> <a id="3678" class="Symbol">:</a> <a id="3680" href="Agda.Primitive.Cubical.html#108" data-type="SSet lzero" class="Datatype">I</a><a id="3681" class="Symbol">)</a> <a id="3683" class="Symbol">→</a> <a id="3685" href="Agda.Primitive.Cubical.html#1072" data-type="(φ : I) (A : Set a) → SSet a" class="Primitive">Partial</a> <a id="3693" class="Symbol">(</a><a id="3694" href="Lecture9-notes.html#3676" class="Bound">i</a> <a id="3696" href="cubical-prelude.html#498" class="Primitive Operator">∨</a> <a id="3698" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="3700" href="Lecture9-notes.html#3676" class="Bound">i</a><a id="3701" class="Symbol">)</a> <a id="3703" href="cubical-prelude.html#9512" data-type="Set" class="Datatype">Bool</a>
<a id="3708" href="Lecture9-notes.html#3661" data-type="(i : I) → Partial (primIMax i (primINeg i)) Bool" class="Function">partialBool</a> <a id="3720" href="Lecture9-notes.html#3720" class="Bound">i</a> <a id="3722" class="Symbol">(</a><a id="3723" href="Lecture9-notes.html#3720" class="Bound">i</a> <a id="3725" class="Symbol">=</a> <a id="3727" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="3729" class="Symbol">)</a> <a id="3731" class="Symbol">=</a> <a id="3733" href="cubical-prelude.html#9531" data-type="Bool" class="InductiveConstructor">true</a>
<a id="3738" href="Lecture9-notes.html#3661" data-type="(i : I) → Partial (primIMax i (primINeg i)) Bool" class="Function">partialBool</a> <a id="3750" href="Lecture9-notes.html#3750" class="Bound">i</a> <a id="3752" class="Symbol">(</a><a id="3753" href="Lecture9-notes.html#3750" class="Bound">i</a> <a id="3755" class="Symbol">=</a> <a id="3757" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="3759" class="Symbol">)</a> <a id="3761" class="Symbol">=</a> <a id="3763" href="cubical-prelude.html#9536" data-type="Bool" class="InductiveConstructor">false</a>
</pre>
<p>The term <code>partialBool i</code> should be thought of a boolean
with different values when <code>(i = i0)</code> and
<code>(i = i1)</code>. Note that this is different from pattern matching
on the interval which is not allowed, so we couldn’t have written:</p>
<pre class="text"><code>partialBool : (i : I) → Bool
partialBool i0 = true
partialBool i1 = false</code></pre>
<p>Terms of type <code>Partial φ A</code> can also be introduced using a
pattern matching lambda and this is what we have been using when we
wrote <code>hcomp</code>’s above.</p>
<pre class="Agda"><a id="partialBool&#39;"></a><a id="4248" href="Lecture9-notes.html#4248" data-type="(i : I) → Partial (primIMax i (primINeg i)) Bool" class="Function">partialBool&#39;</a> <a id="4261" class="Symbol">:</a> <a id="4263" class="Symbol">(</a><a id="4264" href="Lecture9-notes.html#4264" class="Bound">i</a> <a id="4266" class="Symbol">:</a> <a id="4268" href="Agda.Primitive.Cubical.html#108" data-type="SSet lzero" class="Datatype">I</a><a id="4269" class="Symbol">)</a> <a id="4271" class="Symbol">→</a> <a id="4273" href="Agda.Primitive.Cubical.html#1072" data-type="(φ : I) (A : Set a) → SSet a" class="Primitive">Partial</a> <a id="4281" class="Symbol">(</a><a id="4282" href="Lecture9-notes.html#4264" class="Bound">i</a> <a id="4284" href="cubical-prelude.html#498" class="Primitive Operator">∨</a> <a id="4286" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="4288" href="Lecture9-notes.html#4264" class="Bound">i</a><a id="4289" class="Symbol">)</a> <a id="4291" href="cubical-prelude.html#9512" data-type="Set" class="Datatype">Bool</a>
<a id="4296" href="Lecture9-notes.html#4248" data-type="(i : I) → Partial (primIMax i (primINeg i)) Bool" class="Function">partialBool&#39;</a> <a id="4309" href="Lecture9-notes.html#4309" class="Bound">i</a> <a id="4311" class="Symbol">=</a> <a id="4313" class="Symbol">λ</a> <a id="4315" class="Symbol">{</a> <a id="4317" class="Symbol">(</a><a id="4318" href="Lecture9-notes.html#4309" class="Bound">i</a> <a id="4320" class="Symbol">=</a> <a id="4322" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="4324" class="Symbol">)</a> <a id="4326" class="Symbol">→</a> <a id="4328" href="cubical-prelude.html#9531" data-type="Bool" class="InductiveConstructor">true</a>
                   <a id="4352" class="Symbol">;</a> <a id="4354" class="Symbol">(</a><a id="4355" href="Lecture9-notes.html#4309" class="Bound">i</a> <a id="4357" class="Symbol">=</a> <a id="4359" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="4361" class="Symbol">)</a> <a id="4363" class="Symbol">→</a> <a id="4365" href="cubical-prelude.html#9536" data-type="Bool" class="InductiveConstructor">false</a> <a id="4371" class="Symbol">}</a>
</pre>
<p>When the cases overlap they must agree (note that the order of the
cases doesn’t have to match the interval formula exactly):</p>
<pre class="Agda"><a id="partialBool&#39;&#39;"></a><a id="4513" href="Lecture9-notes.html#4513" data-type="(i j : I) →
Partial (primIMax (primINeg i) (primIMax i (primIMin i j))) Bool" class="Function">partialBool&#39;&#39;</a> <a id="4527" class="Symbol">:</a> <a id="4529" class="Symbol">(</a><a id="4530" href="Lecture9-notes.html#4530" class="Bound">i</a> <a id="4532" href="Lecture9-notes.html#4532" class="Bound">j</a> <a id="4534" class="Symbol">:</a> <a id="4536" href="Agda.Primitive.Cubical.html#108" data-type="SSet lzero" class="Datatype">I</a><a id="4537" class="Symbol">)</a> <a id="4539" class="Symbol">→</a> <a id="4541" href="Agda.Primitive.Cubical.html#1072" data-type="(φ : I) (A : Set a) → SSet a" class="Primitive">Partial</a> <a id="4549" class="Symbol">(</a><a id="4550" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="4552" href="Lecture9-notes.html#4530" class="Bound">i</a> <a id="4554" href="cubical-prelude.html#498" class="Primitive Operator">∨</a> <a id="4556" href="Lecture9-notes.html#4530" class="Bound">i</a> <a id="4558" href="cubical-prelude.html#498" class="Primitive Operator">∨</a> <a id="4560" class="Symbol">(</a><a id="4561" href="Lecture9-notes.html#4530" class="Bound">i</a> <a id="4563" href="cubical-prelude.html#449" class="Primitive Operator">∧</a> <a id="4565" href="Lecture9-notes.html#4532" class="Bound">j</a><a id="4566" class="Symbol">))</a> <a id="4569" href="cubical-prelude.html#9512" data-type="Set" class="Datatype">Bool</a>
<a id="4574" href="Lecture9-notes.html#4513" data-type="(i j : I) →
Partial (primIMax (primINeg i) (primIMax i (primIMin i j))) Bool" class="Function">partialBool&#39;&#39;</a> <a id="4588" href="Lecture9-notes.html#4588" class="Bound">i</a> <a id="4590" href="Lecture9-notes.html#4590" class="Bound">j</a> <a id="4592" class="Symbol">=</a> <a id="4594" class="Symbol">λ</a> <a id="4596" class="Symbol">{</a> <a id="4598" class="Symbol">(</a><a id="4599" href="Lecture9-notes.html#4588" class="Bound">i</a> <a id="4601" class="Symbol">=</a> <a id="4603" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="4605" class="Symbol">)</a>          <a id="4616" class="Symbol">→</a> <a id="4618" href="cubical-prelude.html#9531" data-type="Bool" class="InductiveConstructor">true</a>
                      <a id="4645" class="Symbol">;</a> <a id="4647" class="Symbol">(</a><a id="4648" href="Lecture9-notes.html#4588" class="Bound">i</a> <a id="4650" class="Symbol">=</a> <a id="4652" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="4654" class="Symbol">)</a> <a id="4656" class="Symbol">(</a><a id="4657" href="Lecture9-notes.html#4590" class="Bound">j</a> <a id="4659" class="Symbol">=</a> <a id="4661" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="4663" class="Symbol">)</a> <a id="4665" class="Symbol">→</a> <a id="4667" href="cubical-prelude.html#9531" data-type="Bool" class="InductiveConstructor">true</a>
                      <a id="4694" class="Symbol">;</a> <a id="4696" class="Symbol">(</a><a id="4697" href="Lecture9-notes.html#4588" class="Bound">i</a> <a id="4699" class="Symbol">=</a> <a id="4701" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="4703" class="Symbol">)</a>          <a id="4714" class="Symbol">→</a> <a id="4716" href="cubical-prelude.html#9536" data-type="Bool" class="InductiveConstructor">false</a> <a id="4722" class="Symbol">}</a>
</pre>
<p>Furthermore <code>IsOne i0</code> is actually absurd.</p>
<pre class="Agda"><a id="4781" href="Lecture9-notes.html#4781" class="Function">_</a> <a id="4783" class="Symbol">:</a> <a id="4785" class="Symbol">{</a><a id="4786" href="Lecture9-notes.html#4786" class="Bound">A</a> <a id="4788" class="Symbol">:</a> <a id="4790" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="4794" class="Symbol">}</a> <a id="4796" class="Symbol">→</a> <a id="4798" href="Agda.Primitive.Cubical.html#1072" data-type="(φ : I) (A : Set a) → SSet a" class="Primitive">Partial</a> <a id="4806" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a> <a id="4809" href="Lecture9-notes.html#4786" class="Bound">A</a>
<a id="4811" class="Symbol">_</a> <a id="4813" class="Symbol">=</a> <a id="4815" class="Symbol">λ</a> <a id="4817" class="Symbol">{</a> <a id="4819" class="Symbol">()</a> <a id="4822" class="Symbol">}</a>
</pre>
<p>With this cubical infrastructure we can now describe the type of the
<code>hcomp</code> operation.</p>
<pre class="text"><code>hcomp : {A : Type ℓ} {φ : I} (u : I → Partial φ A) (u0 : A) → A</code></pre>
<p>When calling <code>hcomp {φ = φ} u u0</code> Agda makes sure that
<code>u0</code> agrees with <code>u i0</code> on <code>φ</code>. The
result is then an element of <code>A</code> which agrees with
<code>u i1</code> on <code>φ</code>. The idea being that <code>u0</code>
is the base and <code>u</code> specifies the sides of an open box while
<code>hcomp u u0</code> is the lid of the box. In fact, we can use yet
another cubical construction to specify these side conditions in the
type of <code>hcomp</code>. For this we need to talk about cubical
subtypes.</p>
<h3 id="cubical-subtypes-and-filling">Cubical subtypes and filling</h3>
<p>Cubical Agda also has cubical subtypes as in the CCHM type
theory:</p>
<pre class="text"><code>_[_↦_] : (A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ
A [ φ ↦ u ] = Sub A φ u</code></pre>
<p>A term <code>v : A [ φ ↦ u ]</code> should be thought of as a term of
type <code>A</code> which is definitionally equal to <code>u : A</code>
when <code>IsOne φ</code> is satisfied. Any term <code>u : A</code> can
be seen as a term of <code>A [ φ ↦ u ]</code> which agrees with itself
on <code>φ</code>:</p>
<pre class="text"><code>inS : {A : Type ℓ} {φ : I} (u : A) → A [ φ ↦ (λ _ → u) ]</code></pre>
<p>One can also forget that a partial element agrees with <code>u</code>
on <code>φ</code>:</p>
<pre class="text"><code>outS : {A : Type ℓ} {φ : I} {u : Partial φ A} → A [ φ ↦ u ] → A</code></pre>
<p>They satisfy the following equalities:</p>
<pre class="text"><code>outS (inS a) ≐ a

inS {φ = φ} (outS {φ = φ} a) ≐ a

outS {φ = i1} {u} _ ≐ u 1=1</code></pre>
<p>Note that given <code>a : A [ φ ↦ u ]</code> and
<code>α : IsOne φ</code>, it is not the case that
<code>outS a ≐ u α</code>; however, underneath the pattern binding
<code>(φ = i1)</code>, one has <code>outS a ≐ u 1=1</code>.</p>
<p>With this we can now give <code>hcomp</code> the following more
specific type:</p>
<pre class="Agda"><a id="hcomp&#39;"></a><a id="6455" href="Lecture9-notes.html#6455" data-type="(u : I → Partial φ A) → A [ φ ↦ u i0 ] → A [ φ ↦ u i1 ]" class="Function">hcomp&#39;</a> <a id="6462" class="Symbol">:</a> <a id="6464" class="Symbol">{</a><a id="6465" href="Lecture9-notes.html#6465" class="Bound">A</a> <a id="6467" class="Symbol">:</a> <a id="6469" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="6474" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="6475" class="Symbol">}</a> <a id="6477" class="Symbol">{</a><a id="6478" href="Lecture9-notes.html#6478" class="Bound">φ</a> <a id="6480" class="Symbol">:</a> <a id="6482" href="Agda.Primitive.Cubical.html#108" data-type="SSet lzero" class="Datatype">I</a><a id="6483" class="Symbol">}</a> <a id="6485" class="Symbol">(</a><a id="6486" href="Lecture9-notes.html#6486" class="Bound">u</a> <a id="6488" class="Symbol">:</a> <a id="6490" href="Agda.Primitive.Cubical.html#108" data-type="SSet lzero" class="Datatype">I</a> <a id="6492" class="Symbol">→</a> <a id="6494" href="Agda.Primitive.Cubical.html#1072" data-type="(φ : I) (A : Set a) → SSet a" class="Primitive">Partial</a> <a id="6502" href="Lecture9-notes.html#6478" class="Bound">φ</a> <a id="6504" href="Lecture9-notes.html#6465" class="Bound">A</a><a id="6505" class="Symbol">)</a> <a id="6507" class="Symbol">(</a><a id="6508" href="Lecture9-notes.html#6508" class="Bound">u0</a> <a id="6511" class="Symbol">:</a> <a id="6513" href="Lecture9-notes.html#6465" class="Bound">A</a> <a id="6515" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">[</a> <a id="6517" href="Lecture9-notes.html#6478" class="Bound">φ</a> <a id="6519" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">↦</a> <a id="6521" href="Lecture9-notes.html#6486" class="Bound">u</a> <a id="6523" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a> <a id="6526" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">]</a><a id="6527" class="Symbol">)</a> <a id="6529" class="Symbol">→</a> <a id="6531" href="Lecture9-notes.html#6465" class="Bound">A</a> <a id="6533" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">[</a> <a id="6535" href="Lecture9-notes.html#6478" class="Bound">φ</a> <a id="6537" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">↦</a> <a id="6539" href="Lecture9-notes.html#6486" class="Bound">u</a> <a id="6541" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a> <a id="6544" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">]</a>
<a id="6546" href="Lecture9-notes.html#6455" data-type="(u : I → Partial φ A) → A [ φ ↦ u i0 ] → A [ φ ↦ u i1 ]" class="Function">hcomp&#39;</a> <a id="6553" href="Lecture9-notes.html#6553" class="Bound">u</a> <a id="6555" href="Lecture9-notes.html#6555" class="Bound">u0</a> <a id="6558" class="Symbol">=</a> <a id="6560" href="Agda.Builtin.Cubical.Sub.html#223" data-type="(x : A) → Sub A φ (λ _ → x)" class="Postulate">inS</a> <a id="6564" class="Symbol">(</a><a id="6565" href="cubical-prelude.html#665" class="Primitive">hcomp</a> <a id="6571" href="Lecture9-notes.html#6553" class="Bound">u</a> <a id="6573" class="Symbol">(</a><a id="6574" href="Agda.Builtin.Cubical.Sub.html#407" data-type="Sub A φ u → A" class="Primitive">outS</a> <a id="6579" href="Lecture9-notes.html#6555" class="Bound">u0</a><a id="6581" class="Symbol">))</a>
</pre>
<p>This more specific type is of course more informative, but it quickly
gets quite annoying to write <code>inS</code>/<code>outS</code>
everywhere. So the builtin <code>hcomp</code> operation comes with the
slightly less informative type and the side conditions are then implicit
and checked internally.</p>
<p>Another very useful operation is open box <em>filling</em>. This
produces an element corresponding to the interior of an open box:</p>
<pre class="Agda"><a id="hfill&#39;"></a><a id="6992" href="Lecture9-notes.html#6992" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) (i : I) →
A [ primIMax φ (primIMax (primINeg i) i) ↦
(λ { (φ = i1) → u i _
   ; (i = i0) → primSubOut u0
   ; (i = i1) → primHComp u (primSubOut u0)
   })
]" class="Function">hfill&#39;</a> <a id="6999" class="Symbol">:</a> <a id="7001" class="Symbol">{</a><a id="7002" href="Lecture9-notes.html#7002" class="Bound">A</a> <a id="7004" class="Symbol">:</a> <a id="7006" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="7011" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="7012" class="Symbol">}</a>
         <a id="7023" class="Symbol">{</a><a id="7024" href="Lecture9-notes.html#7024" class="Bound">φ</a> <a id="7026" class="Symbol">:</a> <a id="7028" href="Agda.Primitive.Cubical.html#108" data-type="SSet lzero" class="Datatype">I</a><a id="7029" class="Symbol">}</a>
         <a id="7040" class="Symbol">(</a><a id="7041" href="Lecture9-notes.html#7041" class="Bound">u</a> <a id="7043" class="Symbol">:</a> <a id="7045" class="Symbol">∀</a> <a id="7047" href="Lecture9-notes.html#7047" class="Bound">i</a> <a id="7049" class="Symbol">→</a> <a id="7051" href="Agda.Primitive.Cubical.html#1072" data-type="(φ : I) (A : Set a) → SSet a" class="Primitive">Partial</a> <a id="7059" href="Lecture9-notes.html#7024" class="Bound">φ</a> <a id="7061" href="Lecture9-notes.html#7002" class="Bound">A</a><a id="7062" class="Symbol">)</a>
         <a id="7073" class="Symbol">(</a><a id="7074" href="Lecture9-notes.html#7074" class="Bound">u0</a> <a id="7077" class="Symbol">:</a> <a id="7079" href="Lecture9-notes.html#7002" class="Bound">A</a> <a id="7081" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">[</a> <a id="7083" href="Lecture9-notes.html#7024" class="Bound">φ</a> <a id="7085" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">↦</a> <a id="7087" href="Lecture9-notes.html#7041" class="Bound">u</a> <a id="7089" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a> <a id="7092" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">]</a><a id="7093" class="Symbol">)</a>
         <a id="7104" class="Symbol">(</a><a id="7105" href="Lecture9-notes.html#7105" class="Bound">i</a> <a id="7107" class="Symbol">:</a> <a id="7109" href="Agda.Primitive.Cubical.html#108" data-type="SSet lzero" class="Datatype">I</a><a id="7110" class="Symbol">)</a> <a id="7112" class="Symbol">→</a>
         <a id="7123" href="Lecture9-notes.html#7002" class="Bound">A</a> <a id="7125" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">[</a> <a id="7127" href="Lecture9-notes.html#7024" class="Bound">φ</a> <a id="7129" href="cubical-prelude.html#498" class="Primitive Operator">∨</a> <a id="7131" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="7133" href="Lecture9-notes.html#7105" class="Bound">i</a> <a id="7135" href="cubical-prelude.html#498" class="Primitive Operator">∨</a> <a id="7137" href="Lecture9-notes.html#7105" class="Bound">i</a> <a id="7139" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">↦</a>
            <a id="7153" class="Symbol">(λ</a> <a id="7156" class="Symbol">{</a> <a id="7158" class="Symbol">(</a><a id="7159" href="Lecture9-notes.html#7024" class="Bound">φ</a> <a id="7161" class="Symbol">=</a> <a id="7163" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="7165" class="Symbol">)</a> <a id="7167" class="Symbol">→</a> <a id="7169" href="Lecture9-notes.html#7041" class="Bound">u</a> <a id="7171" href="Lecture9-notes.html#7105" class="Bound">i</a> <a id="7173" href="cubical-prelude.html#740" class="Postulate">1=1</a>
               <a id="7192" class="Symbol">;</a> <a id="7194" class="Symbol">(</a><a id="7195" href="Lecture9-notes.html#7105" class="Bound">i</a> <a id="7197" class="Symbol">=</a> <a id="7199" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="7201" class="Symbol">)</a> <a id="7203" class="Symbol">→</a> <a id="7205" href="Agda.Builtin.Cubical.Sub.html#407" data-type="Sub A φ u → A" class="Primitive">outS</a> <a id="7210" href="Lecture9-notes.html#7074" class="Bound">u0</a>
               <a id="7228" class="Symbol">;</a> <a id="7230" class="Symbol">(</a><a id="7231" href="Lecture9-notes.html#7105" class="Bound">i</a> <a id="7233" class="Symbol">=</a> <a id="7235" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="7237" class="Symbol">)</a> <a id="7239" class="Symbol">→</a> <a id="7241" href="cubical-prelude.html#665" class="Primitive">hcomp</a> <a id="7247" href="Lecture9-notes.html#7041" class="Bound">u</a> <a id="7249" class="Symbol">(</a><a id="7250" href="Agda.Builtin.Cubical.Sub.html#407" data-type="Sub A φ u → A" class="Primitive">outS</a> <a id="7255" href="Lecture9-notes.html#7074" class="Bound">u0</a><a id="7257" class="Symbol">)</a> <a id="7259" class="Symbol">})</a> <a id="7262" href="cubical-prelude.html#3175" data-type="(A : Set ℓ) (φ : I) → Partial φ A → SSet ℓ" class="Function Operator">]</a>
<a id="7264" href="Lecture9-notes.html#6992" data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) (i : I) →
A [ primIMax φ (primIMax (primINeg i) i) ↦
(λ { (φ = i1) → u i _
   ; (i = i0) → primSubOut u0
   ; (i = i1) → primHComp u (primSubOut u0)
   })
]" class="Function">hfill&#39;</a> <a id="7271" class="Symbol">{</a><a id="7272" class="Argument">φ</a> <a id="7274" class="Symbol">=</a> <a id="7276" href="Lecture9-notes.html#7276" class="Bound">φ</a><a id="7277" class="Symbol">}</a> <a id="7279" href="Lecture9-notes.html#7279" class="Bound">u</a> <a id="7281" href="Lecture9-notes.html#7281" class="Bound">u0</a> <a id="7284" href="Lecture9-notes.html#7284" class="Bound">i</a> <a id="7286" class="Symbol">=</a> <a id="7288" href="Agda.Builtin.Cubical.Sub.html#223" data-type="(x : A) → Sub A φ (λ _ → x)" class="Postulate">inS</a> <a id="7292" class="Symbol">(</a><a id="7293" href="cubical-prelude.html#665" class="Primitive">hcomp</a> <a id="7299" class="Symbol">(λ</a> <a id="7302" href="Lecture9-notes.html#7302" class="Bound">j</a> <a id="7304" class="Symbol">→</a> <a id="7306" class="Symbol">λ</a> <a id="7308" class="Symbol">{</a> <a id="7310" class="Symbol">(</a><a id="7311" href="Lecture9-notes.html#7276" class="Bound">φ</a> <a id="7313" class="Symbol">=</a> <a id="7315" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="7317" class="Symbol">)</a> <a id="7319" class="Symbol">→</a> <a id="7321" href="Lecture9-notes.html#7279" class="Bound">u</a> <a id="7323" class="Symbol">(</a><a id="7324" href="Lecture9-notes.html#7284" class="Bound">i</a> <a id="7326" href="cubical-prelude.html#449" class="Primitive Operator">∧</a> <a id="7328" href="Lecture9-notes.html#7302" class="Bound">j</a><a id="7329" class="Symbol">)</a> <a id="7331" href="cubical-prelude.html#740" class="Postulate">1=1</a>
                                            <a id="7379" class="Symbol">;</a> <a id="7381" class="Symbol">(</a><a id="7382" href="Lecture9-notes.html#7284" class="Bound">i</a> <a id="7384" class="Symbol">=</a> <a id="7386" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="7388" class="Symbol">)</a> <a id="7390" class="Symbol">→</a> <a id="7392" href="Agda.Builtin.Cubical.Sub.html#407" data-type="Sub A φ u → A" class="Primitive">outS</a> <a id="7397" href="Lecture9-notes.html#7281" class="Bound">u0</a> <a id="7400" class="Symbol">})</a>
                                   <a id="7438" class="Symbol">(</a><a id="7439" href="Agda.Builtin.Cubical.Sub.html#407" data-type="Sub A φ u → A" class="Primitive">outS</a> <a id="7444" href="Lecture9-notes.html#7281" class="Bound">u0</a><a id="7446" class="Symbol">))</a>
</pre>
<p>This has a slightly less informative type in the cubical-prelude:</p>
<pre class="text"><code>hfill : {A : Type ℓ}
        {φ : I}
        (u : ∀ i → Partial φ A)
        (u0 : A [ φ ↦ u i0 ])
        (i : I) →
        A
hfill {φ = φ} u u0 i =
  hcomp (λ j → λ { (φ = i1) → u (i ∧ j) 1=1
                 ; (i = i0) → outS u0 })
        (outS u0)</code></pre>
<p>Having defined this operation we can prove various groupoid laws for
<code>_≡_</code> very cubically as <code>_∙_</code> is defined using
<code>hcomp</code>.</p>
<pre class="Agda"><a id="compPathRefl"></a><a id="7921" href="Lecture9-notes.html#7921" data-type="(p : x ≡ y) → (p ∙ refl) ≡ p" class="Function">compPathRefl</a> <a id="7934" class="Symbol">:</a> <a id="7936" class="Symbol">{</a><a id="7937" href="Lecture9-notes.html#7937" class="Bound">A</a> <a id="7939" class="Symbol">:</a> <a id="7941" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="7946" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="7947" class="Symbol">}</a> <a id="7949" class="Symbol">{</a><a id="7950" href="Lecture9-notes.html#7950" class="Bound">x</a> <a id="7952" href="Lecture9-notes.html#7952" class="Bound">y</a> <a id="7954" class="Symbol">:</a> <a id="7956" href="Lecture9-notes.html#7937" class="Bound">A</a><a id="7957" class="Symbol">}</a> <a id="7959" class="Symbol">(</a><a id="7960" href="Lecture9-notes.html#7960" class="Bound">p</a> <a id="7962" class="Symbol">:</a> <a id="7964" href="Lecture9-notes.html#7950" class="Bound">x</a> <a id="7966" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="7968" href="Lecture9-notes.html#7952" class="Bound">y</a><a id="7969" class="Symbol">)</a> <a id="7971" class="Symbol">→</a> <a id="7973" href="Lecture9-notes.html#7960" class="Bound">p</a> <a id="7975" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="7977" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a> <a id="7982" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="7984" href="Lecture9-notes.html#7960" class="Bound">p</a>
<a id="7986" href="Lecture9-notes.html#7921" data-type="(p : x ≡ y) → (p ∙ refl) ≡ p" class="Function">compPathRefl</a> <a id="7999" class="Symbol">{</a><a id="8000" class="Argument">x</a> <a id="8002" class="Symbol">=</a> <a id="8004" href="Lecture9-notes.html#8004" class="Bound">x</a><a id="8005" class="Symbol">}</a> <a id="8007" class="Symbol">{</a><a id="8008" class="Argument">y</a> <a id="8010" class="Symbol">=</a> <a id="8012" href="Lecture9-notes.html#8012" class="Bound">y</a><a id="8013" class="Symbol">}</a> <a id="8015" href="Lecture9-notes.html#8015" class="Bound">p</a> <a id="8017" href="Lecture9-notes.html#8017" class="Bound">j</a> <a id="8019" href="Lecture9-notes.html#8019" class="Bound">i</a> <a id="8021" class="Symbol">=</a> <a id="8023" href="cubical-prelude.html#3303" data-type="(u : I → Partial φ A) → A [ φ ↦ u i0 ] → I → A" class="Function">hfill</a> <a id="8029" class="Symbol">(λ</a> <a id="8032" href="Lecture9-notes.html#8032" class="Bound">_</a> <a id="8034" class="Symbol">→</a> <a id="8036" class="Symbol">λ</a> <a id="8038" class="Symbol">{</a> <a id="8040" class="Symbol">(</a><a id="8041" href="Lecture9-notes.html#8019" class="Bound">i</a> <a id="8043" class="Symbol">=</a> <a id="8045" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="8047" class="Symbol">)</a> <a id="8049" class="Symbol">→</a> <a id="8051" href="Lecture9-notes.html#8004" class="Bound">x</a>
                                                    <a id="8105" class="Symbol">;</a> <a id="8107" class="Symbol">(</a><a id="8108" href="Lecture9-notes.html#8019" class="Bound">i</a> <a id="8110" class="Symbol">=</a> <a id="8112" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="8114" class="Symbol">)</a> <a id="8116" class="Symbol">→</a> <a id="8118" href="Lecture9-notes.html#8012" class="Bound">y</a> <a id="8120" class="Symbol">})</a>
                                           <a id="8166" class="Symbol">(</a><a id="8167" href="Agda.Builtin.Cubical.Sub.html#223" data-type="(x : A) → Sub A φ (λ _ → x)" class="Postulate">inS</a> <a id="8171" class="Symbol">(</a><a id="8172" href="Lecture9-notes.html#8015" class="Bound">p</a> <a id="8174" href="Lecture9-notes.html#8019" class="Bound">i</a><a id="8175" class="Symbol">))</a>
                                           <a id="8221" class="Symbol">(</a><a id="8222" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="8224" href="Lecture9-notes.html#8017" class="Bound">j</a><a id="8225" class="Symbol">)</a>
</pre>
<p>For more examples see Cubical.Foundations.GroupoidLaws in
agda/cubical.</p>
<h2 id="cubical-univalence-glue-types-sip">Cubical univalence (Glue
types) + SIP</h2>
<p>A key concept in HoTT/UF is univalence. As we have seen earlier in
the course this is assumed as an axiom in Book HoTT. In Cubical Agda it
is instead provable and has computational content. This means that
transporting with paths constructed using univalence reduces as opposed
to Book HoTT where they would be stuck. This simplifies many proofs and
make it possible to actually do concrete computations using
univalence.</p>
<p>The part of univalence which is most useful for our applications is
to be able to turn equivalences (written <code>_≃_</code> and defined as
a Σ-type of a function and a proof that it has contractible fibers) into
paths:</p>
<pre class="Agda"><a id="ua"></a><a id="8990" href="Lecture9-notes.html#8990" data-type="A ≃ B → A ≡ B" class="Function">ua</a> <a id="8993" class="Symbol">:</a> <a id="8995" class="Symbol">{</a><a id="8996" href="Lecture9-notes.html#8996" class="Bound">A</a> <a id="8998" href="Lecture9-notes.html#8998" class="Bound">B</a> <a id="9000" class="Symbol">:</a> <a id="9002" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="9007" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="9008" class="Symbol">}</a> <a id="9010" class="Symbol">→</a> <a id="9012" href="Lecture9-notes.html#8996" class="Bound">A</a> <a id="9014" href="Agda.Builtin.Cubical.Glue.html#1051" data-type="Set ℓ → Set ℓ&#39; → Set (ℓ ⊔ ℓ&#39;)" class="Function Operator">≃</a> <a id="9016" href="Lecture9-notes.html#8998" class="Bound">B</a> <a id="9018" class="Symbol">→</a> <a id="9020" href="Lecture9-notes.html#8996" class="Bound">A</a> <a id="9022" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="9024" href="Lecture9-notes.html#8998" class="Bound">B</a>
<a id="9026" href="Lecture9-notes.html#8990" data-type="A ≃ B → A ≡ B" class="Function">ua</a> <a id="9029" class="Symbol">{</a><a id="9030" class="Argument">A</a> <a id="9032" class="Symbol">=</a> <a id="9034" href="Lecture9-notes.html#9034" class="Bound">A</a><a id="9035" class="Symbol">}</a> <a id="9037" class="Symbol">{</a><a id="9038" class="Argument">B</a> <a id="9040" class="Symbol">=</a> <a id="9042" href="Lecture9-notes.html#9042" class="Bound">B</a><a id="9043" class="Symbol">}</a> <a id="9045" href="Lecture9-notes.html#9045" class="Bound">e</a> <a id="9047" href="Lecture9-notes.html#9047" class="Bound">i</a> <a id="9049" class="Symbol">=</a> <a id="9051" href="cubical-prelude.html#7592" data-type="(A : Set ℓ) → Partial φ (Sigma (Set ℓ&#39;) (λ T → T ≃ A)) → Set ℓ&#39;" class="Function">Glue</a> <a id="9056" href="Lecture9-notes.html#9042" class="Bound">B</a> <a id="9058" class="Symbol">(λ</a> <a id="9061" class="Symbol">{</a> <a id="9063" class="Symbol">(</a><a id="9064" href="Lecture9-notes.html#9047" class="Bound">i</a> <a id="9066" class="Symbol">=</a> <a id="9068" href="Agda.Primitive.Cubical.html#150" data-type="I" class="InductiveConstructor">i0</a><a id="9070" class="Symbol">)</a> <a id="9072" class="Symbol">→</a> <a id="9074" class="Symbol">(</a><a id="9075" href="Lecture9-notes.html#9034" class="Bound">A</a> <a id="9077" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="9079" href="Lecture9-notes.html#9045" class="Bound">e</a><a id="9080" class="Symbol">)</a>
                                   <a id="9117" class="Symbol">;</a> <a id="9119" class="Symbol">(</a><a id="9120" href="Lecture9-notes.html#9047" class="Bound">i</a> <a id="9122" class="Symbol">=</a> <a id="9124" href="Agda.Primitive.Cubical.html#178" data-type="I" class="InductiveConstructor">i1</a><a id="9126" class="Symbol">)</a> <a id="9128" class="Symbol">→</a> <a id="9130" class="Symbol">(</a><a id="9131" href="Lecture9-notes.html#9042" class="Bound">B</a> <a id="9133" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="9135" href="cubical-prelude.html#7747" data-type="(A : Set ℓ) → A ≃ A" class="Function">idEquiv</a> <a id="9143" href="Lecture9-notes.html#9042" class="Bound">B</a><a id="9144" class="Symbol">)</a> <a id="9146" class="Symbol">})</a>
</pre>
<p>This term is defined using “Glue types” which were introduced in the
CCHM paper. We won’t have time to go into too much details about them
today, but for practical applications one can usually forget about them
and use <code>ua</code> as a black box. The key idea though is that they
are similar to <code>hcomp</code>’s, but instead of attaching (higher
dimensional) paths to a base we attach equivalences to a type. One of
the original applications of Glue types was to give computational
meaning to transporting in a line of types constructed by
<code>hcomp</code> in the universe <code>Type</code>.</p>
<p>For us today the important point is that transporting along the path
constructed using <code>ua</code> applies the function underlying the
equivalence. This is easily proved using <code>transportRefl</code>:</p>
<pre class="Agda"><a id="uaβ"></a><a id="9908" href="Lecture9-notes.html#9908" data-type="(e : A ≃ B) (x : A) → transport (ua e) x ≡ fst e x" class="Function">uaβ</a> <a id="9912" class="Symbol">:</a> <a id="9914" class="Symbol">(</a><a id="9915" href="Lecture9-notes.html#9915" class="Bound">e</a> <a id="9917" class="Symbol">:</a> <a id="9919" href="Lecture9-notes.html#336" class="Generalizable">A</a> <a id="9921" href="Agda.Builtin.Cubical.Glue.html#1051" data-type="Set ℓ → Set ℓ&#39; → Set (ℓ ⊔ ℓ&#39;)" class="Function Operator">≃</a> <a id="9923" href="Lecture9-notes.html#338" class="Generalizable">B</a><a id="9924" class="Symbol">)</a> <a id="9926" class="Symbol">(</a><a id="9927" href="Lecture9-notes.html#9927" class="Bound">x</a> <a id="9929" class="Symbol">:</a> <a id="9931" href="Lecture9-notes.html#336" class="Generalizable">A</a><a id="9932" class="Symbol">)</a> <a id="9934" class="Symbol">→</a> <a id="9936" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="9946" class="Symbol">(</a><a id="9947" href="Lecture9-notes.html#8990" data-type="A ≃ B → A ≡ B" class="Function">ua</a> <a id="9950" href="Lecture9-notes.html#9915" class="Bound">e</a><a id="9951" class="Symbol">)</a> <a id="9953" href="Lecture9-notes.html#9927" class="Bound">x</a> <a id="9955" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="9957" href="cubical-prelude.html#3676" class="Field">pr₁</a> <a id="9961" href="Lecture9-notes.html#9915" class="Bound">e</a> <a id="9963" href="Lecture9-notes.html#9927" class="Bound">x</a>
<a id="9965" href="Lecture9-notes.html#9908" data-type="(e : A ≃ B) (x : A) → transport (ua e) x ≡ fst e x" class="Function">uaβ</a> <a id="9969" href="Lecture9-notes.html#9969" class="Bound">e</a> <a id="9971" href="Lecture9-notes.html#9971" class="Bound">x</a> <a id="9973" class="Symbol">=</a> <a id="9975" href="Lecture8-notes.html#9976" data-type="(x : A) → transport refl x ≡ x" class="Function">transportRefl</a> <a id="9989" class="Symbol">(</a><a id="9990" href="Agda.Builtin.Cubical.Glue.html#1143" data-type="A ≃ B → A → B" class="Function">equivFun</a> <a id="9999" href="Lecture9-notes.html#9969" class="Bound">e</a> <a id="10001" href="Lecture9-notes.html#9971" class="Bound">x</a><a id="10002" class="Symbol">)</a>
</pre>
<p>Note that for concrete types this typically holds definitionally, but
for an arbitrary equivalence <code>e</code> between abstract types
<code>A</code> and <code>B</code> we have to prove it.</p>
<pre class="Agda"><a id="uaβℕ"></a><a id="10177" href="Lecture9-notes.html#10177" data-type="(e : ℕ ≃ ℕ) (x : ℕ) → transport (ua e) x ≡ fst e x" class="Function">uaβℕ</a> <a id="10182" class="Symbol">:</a> <a id="10184" class="Symbol">(</a><a id="10185" href="Lecture9-notes.html#10185" class="Bound">e</a> <a id="10187" class="Symbol">:</a> <a id="10189" href="introduction.html#1034" data-type="Set" class="Datatype">ℕ</a> <a id="10191" href="Agda.Builtin.Cubical.Glue.html#1051" data-type="Set ℓ → Set ℓ&#39; → Set (ℓ ⊔ ℓ&#39;)" class="Function Operator">≃</a> <a id="10193" href="introduction.html#1034" data-type="Set" class="Datatype">ℕ</a><a id="10194" class="Symbol">)</a> <a id="10196" class="Symbol">(</a><a id="10197" href="Lecture9-notes.html#10197" class="Bound">x</a> <a id="10199" class="Symbol">:</a> <a id="10201" href="introduction.html#1034" data-type="Set" class="Datatype">ℕ</a><a id="10202" class="Symbol">)</a> <a id="10204" class="Symbol">→</a> <a id="10206" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="10216" class="Symbol">(</a><a id="10217" href="Lecture9-notes.html#8990" data-type="A ≃ B → A ≡ B" class="Function">ua</a> <a id="10220" href="Lecture9-notes.html#10185" class="Bound">e</a><a id="10221" class="Symbol">)</a> <a id="10223" href="Lecture9-notes.html#10197" class="Bound">x</a> <a id="10225" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="10227" href="cubical-prelude.html#3676" class="Field">pr₁</a> <a id="10231" href="Lecture9-notes.html#10185" class="Bound">e</a> <a id="10233" href="Lecture9-notes.html#10197" class="Bound">x</a>
<a id="10235" href="Lecture9-notes.html#10177" data-type="(e : ℕ ≃ ℕ) (x : ℕ) → transport (ua e) x ≡ fst e x" class="Function">uaβℕ</a> <a id="10240" href="Lecture9-notes.html#10240" class="Bound">e</a> <a id="10242" href="Lecture9-notes.html#10242" class="Bound">x</a> <a id="10244" class="Symbol">=</a> <a id="10246" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>The fact that we have both <code>ua</code> and <code>uaβ</code>
suffices to be able to prove the standard formulation of univalence. For
details see Cubical.Foundations.Univalence in the agda/cubical
library.</p>
<p>The standard way of constructing equivalences is to start with an
isomorphism and then improve it into an equivalence. The lemma in the
agda/cubical library that does this is</p>
<pre class="text"><code>isoToEquiv : {A B : Type ℓ} → Iso A B → A ≃ B</code></pre>
<p>Composing this with <code>ua</code> lets us directly turn
isomorphisms into paths:</p>
<pre class="text"><code>isoToPath : {A B : Type ℓ} → Iso A B → A ≡ B
isoToPath e = ua (isoToEquiv e)</code></pre>
<p>Time for an example!</p>
<pre class="Agda"><a id="not"></a><a id="10872" href="Lecture9-notes.html#10872" data-type="Bool → Bool" class="Function">not</a> <a id="10876" class="Symbol">:</a> <a id="10878" href="cubical-prelude.html#9512" data-type="Set" class="Datatype">Bool</a> <a id="10883" class="Symbol">→</a> <a id="10885" href="cubical-prelude.html#9512" data-type="Set" class="Datatype">Bool</a>
<a id="10890" href="Lecture9-notes.html#10872" data-type="Bool → Bool" class="Function">not</a> <a id="10894" href="cubical-prelude.html#9536" data-type="Bool" class="InductiveConstructor">false</a> <a id="10900" class="Symbol">=</a> <a id="10902" href="cubical-prelude.html#9531" data-type="Bool" class="InductiveConstructor">true</a>
<a id="10907" href="Lecture9-notes.html#10872" data-type="Bool → Bool" class="Function">not</a> <a id="10911" href="cubical-prelude.html#9531" data-type="Bool" class="InductiveConstructor">true</a>  <a id="10917" class="Symbol">=</a> <a id="10919" href="cubical-prelude.html#9536" data-type="Bool" class="InductiveConstructor">false</a>

<a id="notPath"></a><a id="10926" href="Lecture9-notes.html#10926" data-type="Bool ≡ Bool" class="Function">notPath</a> <a id="10934" class="Symbol">:</a> <a id="10936" href="cubical-prelude.html#9512" data-type="Set" class="Datatype">Bool</a> <a id="10941" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="10943" href="cubical-prelude.html#9512" data-type="Set" class="Datatype">Bool</a>
<a id="10948" href="Lecture9-notes.html#10926" data-type="Bool ≡ Bool" class="Function">notPath</a> <a id="10956" class="Symbol">=</a> <a id="10958" href="cubical-prelude.html#7917" data-type="Iso A B → A ≡ B" class="Function">isoToPath</a> <a id="10968" class="Symbol">(</a><a id="10969" href="cubical-prelude.html#5514" data-type="(fun : A → B) (inv : B → A) (rightInv : section fun inv)
(leftInv : retract fun inv) →
Iso A B" class="InductiveConstructor">iso</a> <a id="10973" href="Lecture9-notes.html#10872" data-type="Bool → Bool" class="Function">not</a> <a id="10977" href="Lecture9-notes.html#10872" data-type="Bool → Bool" class="Function">not</a> <a id="10981" href="Lecture9-notes.html#11000" data-type="(b : Bool) → not (not b) ≡ b" class="Function">rem</a> <a id="10985" href="Lecture9-notes.html#11000" data-type="(b : Bool) → not (not b) ≡ b" class="Function">rem</a><a id="10988" class="Symbol">)</a>
  <a id="10992" class="Keyword">where</a>
  <a id="11000" href="Lecture9-notes.html#11000" data-type="(b : Bool) → not (not b) ≡ b" class="Function">rem</a> <a id="11004" class="Symbol">:</a> <a id="11006" class="Symbol">(</a><a id="11007" href="Lecture9-notes.html#11007" class="Bound">b</a> <a id="11009" class="Symbol">:</a> <a id="11011" href="cubical-prelude.html#9512" data-type="Set" class="Datatype">Bool</a><a id="11015" class="Symbol">)</a> <a id="11017" class="Symbol">→</a> <a id="11019" href="Lecture9-notes.html#10872" data-type="Bool → Bool" class="Function">not</a> <a id="11023" class="Symbol">(</a><a id="11024" href="Lecture9-notes.html#10872" data-type="Bool → Bool" class="Function">not</a> <a id="11028" href="Lecture9-notes.html#11007" class="Bound">b</a><a id="11029" class="Symbol">)</a> <a id="11031" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11033" href="Lecture9-notes.html#11007" class="Bound">b</a>
  <a id="11037" href="Lecture9-notes.html#11000" data-type="(b : Bool) → not (not b) ≡ b" class="Function">rem</a> <a id="11041" href="cubical-prelude.html#9536" data-type="Bool" class="InductiveConstructor">false</a> <a id="11047" class="Symbol">=</a> <a id="11049" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
  <a id="11056" href="Lecture9-notes.html#11000" data-type="(b : Bool) → not (not b) ≡ b" class="Function">rem</a> <a id="11060" href="cubical-prelude.html#9531" data-type="Bool" class="InductiveConstructor">true</a>  <a id="11066" class="Symbol">=</a> <a id="11068" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>

<a id="11074" href="Lecture9-notes.html#11074" class="Function">_</a> <a id="11076" class="Symbol">:</a> <a id="11078" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="11088" href="Lecture9-notes.html#10926" data-type="Bool ≡ Bool" class="Function">notPath</a> <a id="11096" href="cubical-prelude.html#9531" data-type="Bool" class="InductiveConstructor">true</a> <a id="11101" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11103" href="cubical-prelude.html#9536" data-type="Bool" class="InductiveConstructor">false</a>
<a id="11109" class="Symbol">_</a> <a id="11111" class="Symbol">=</a> <a id="11113" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>Another example, integers:</p>
<pre class="Agda"><a id="11159" href="Lecture9-notes.html#11159" class="Function">_</a> <a id="11161" class="Symbol">:</a> <a id="11163" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="11173" href="cubical-prelude.html#9090" data-type="ℤ ≡ ℤ" class="Function">sucPath</a> <a id="11181" class="Symbol">(</a><a id="11182" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="11186" class="Number">0</a><a id="11187" class="Symbol">)</a> <a id="11189" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11191" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="11195" class="Number">1</a>
<a id="11197" class="Symbol">_</a> <a id="11199" class="Symbol">=</a> <a id="11201" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>

<a id="11207" href="Lecture9-notes.html#11207" class="Function">_</a> <a id="11209" class="Symbol">:</a> <a id="11211" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="11221" class="Symbol">(</a><a id="11222" href="cubical-prelude.html#9090" data-type="ℤ ≡ ℤ" class="Function">sucPath</a> <a id="11230" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11232" href="cubical-prelude.html#9090" data-type="ℤ ≡ ℤ" class="Function">sucPath</a><a id="11239" class="Symbol">)</a> <a id="11241" class="Symbol">(</a><a id="11242" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="11246" class="Number">0</a><a id="11247" class="Symbol">)</a> <a id="11249" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11251" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="11255" class="Number">2</a>
<a id="11257" class="Symbol">_</a> <a id="11259" class="Symbol">=</a> <a id="11261" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>

<a id="11267" href="Lecture9-notes.html#11267" class="Function">_</a> <a id="11269" class="Symbol">:</a> <a id="11271" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="11281" class="Symbol">(</a><a id="11282" href="Lecture7-notes.html#6920" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11286" href="cubical-prelude.html#9090" data-type="ℤ ≡ ℤ" class="Function">sucPath</a><a id="11293" class="Symbol">)</a> <a id="11295" class="Symbol">(</a><a id="11296" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="11300" class="Number">0</a><a id="11301" class="Symbol">)</a> <a id="11303" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11305" href="cubical-prelude.html#8514" data-type="ℕ → ℤ" class="InductiveConstructor">negsuc</a> <a id="11312" class="Number">0</a>
<a id="11314" class="Symbol">_</a> <a id="11316" class="Symbol">=</a> <a id="11318" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>Note that we have already used this in the <code>winding</code>
function in Lecture 7.</p>
<p>One can do more fun things with <code>sucPath</code>. For example by
composing it with itself <code>n</code> times and then transporting we
get a new addition function <code>_+ℤ'_</code>. It is direct to prove
<code>isEquiv (λ n → n +ℤ' m)</code> as <code>_+ℤ'_</code> is defined by
<code>transport</code>.</p>
<pre class="Agda"><a id="addPath"></a><a id="11655" href="Lecture9-notes.html#11655" data-type="ℕ → ℤ ≡ ℤ" class="Function">addPath</a> <a id="11663" class="Symbol">:</a> <a id="11665" href="introduction.html#1034" data-type="Set" class="Datatype">ℕ</a> <a id="11667" class="Symbol">→</a> <a id="11669" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a> <a id="11671" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11673" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a>
<a id="11675" href="Lecture9-notes.html#11655" data-type="ℕ → ℤ ≡ ℤ" class="Function">addPath</a> <a id="11683" href="introduction.html#1050" data-type="ℕ" class="InductiveConstructor">zero</a> <a id="11688" class="Symbol">=</a> <a id="11690" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="11695" href="Lecture9-notes.html#11655" data-type="ℕ → ℤ ≡ ℤ" class="Function">addPath</a> <a id="11703" class="Symbol">(</a><a id="11704" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="11708" href="Lecture9-notes.html#11708" class="Bound">n</a><a id="11709" class="Symbol">)</a> <a id="11711" class="Symbol">=</a> <a id="11713" href="Lecture9-notes.html#11655" data-type="ℕ → ℤ ≡ ℤ" class="Function">addPath</a> <a id="11721" href="Lecture9-notes.html#11708" class="Bound">n</a> <a id="11723" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11725" href="cubical-prelude.html#9090" data-type="ℤ ≡ ℤ" class="Function">sucPath</a>

<a id="predPath"></a><a id="11734" href="Lecture9-notes.html#11734" data-type="ℤ ≡ ℤ" class="Function">predPath</a> <a id="11743" class="Symbol">:</a> <a id="11745" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a> <a id="11747" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11749" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a>
<a id="11751" href="Lecture9-notes.html#11734" data-type="ℤ ≡ ℤ" class="Function">predPath</a> <a id="11760" class="Symbol">=</a> <a id="11762" href="cubical-prelude.html#7917" data-type="Iso A B → A ≡ B" class="Function">isoToPath</a> <a id="11772" class="Symbol">(</a><a id="11773" href="cubical-prelude.html#5514" data-type="(fun : A → B) (inv : B → A) (rightInv : section fun inv)
(leftInv : retract fun inv) →
Iso A B" class="InductiveConstructor">iso</a> <a id="11777" href="cubical-prelude.html#8652" data-type="ℤ → ℤ" class="Function">predℤ</a> <a id="11783" href="cubical-prelude.html#8536" data-type="ℤ → ℤ" class="Function">sucℤ</a> <a id="11788" href="cubical-prelude.html#8922" data-type="(i : ℤ) → predℤ (sucℤ i) ≡ i" class="Function">predSuc</a> <a id="11796" href="cubical-prelude.html#8766" data-type="(i : ℤ) → sucℤ (predℤ i) ≡ i" class="Function">sucPred</a><a id="11803" class="Symbol">)</a>

<a id="subPath"></a><a id="11806" href="Lecture9-notes.html#11806" data-type="ℕ → ℤ ≡ ℤ" class="Function">subPath</a> <a id="11814" class="Symbol">:</a> <a id="11816" href="introduction.html#1034" data-type="Set" class="Datatype">ℕ</a> <a id="11818" class="Symbol">→</a> <a id="11820" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a> <a id="11822" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="11824" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a>
<a id="11826" href="Lecture9-notes.html#11806" data-type="ℕ → ℤ ≡ ℤ" class="Function">subPath</a> <a id="11834" href="introduction.html#1050" data-type="ℕ" class="InductiveConstructor">zero</a> <a id="11839" class="Symbol">=</a> <a id="11841" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="11846" href="Lecture9-notes.html#11806" data-type="ℕ → ℤ ≡ ℤ" class="Function">subPath</a> <a id="11854" class="Symbol">(</a><a id="11855" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="11859" href="Lecture9-notes.html#11859" class="Bound">n</a><a id="11860" class="Symbol">)</a> <a id="11862" class="Symbol">=</a> <a id="11864" href="Lecture9-notes.html#11806" data-type="ℕ → ℤ ≡ ℤ" class="Function">subPath</a> <a id="11872" href="Lecture9-notes.html#11859" class="Bound">n</a> <a id="11874" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11876" href="Lecture9-notes.html#11734" data-type="ℤ ≡ ℤ" class="Function">predPath</a>

<a id="_+ℤ&#39;_"></a><a id="11886" href="Lecture9-notes.html#11886" data-type="ℤ → ℤ → ℤ" class="Function Operator">_+ℤ&#39;_</a> <a id="11892" class="Symbol">:</a> <a id="11894" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a> <a id="11896" class="Symbol">→</a> <a id="11898" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a> <a id="11900" class="Symbol">→</a> <a id="11902" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a>
<a id="11904" href="Lecture9-notes.html#11904" class="Bound">m</a> <a id="11906" href="Lecture9-notes.html#11886" data-type="ℤ → ℤ → ℤ" class="Function Operator">+ℤ&#39;</a> <a id="11910" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="11914" href="Lecture9-notes.html#11914" class="Bound">n</a>    <a id="11919" class="Symbol">=</a> <a id="11921" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="11931" class="Symbol">(</a><a id="11932" href="Lecture9-notes.html#11655" data-type="ℕ → ℤ ≡ ℤ" class="Function">addPath</a> <a id="11940" href="Lecture9-notes.html#11914" class="Bound">n</a><a id="11941" class="Symbol">)</a> <a id="11943" href="Lecture9-notes.html#11904" class="Bound">m</a>
<a id="11945" href="Lecture9-notes.html#11945" class="Bound">m</a> <a id="11947" href="Lecture9-notes.html#11886" data-type="ℤ → ℤ → ℤ" class="Function Operator">+ℤ&#39;</a> <a id="11951" href="cubical-prelude.html#8514" data-type="ℕ → ℤ" class="InductiveConstructor">negsuc</a> <a id="11958" href="Lecture9-notes.html#11958" class="Bound">n</a> <a id="11960" class="Symbol">=</a> <a id="11962" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="11972" class="Symbol">(</a><a id="11973" href="Lecture9-notes.html#11806" data-type="ℕ → ℤ ≡ ℤ" class="Function">subPath</a> <a id="11981" class="Symbol">(</a><a id="11982" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="11986" href="Lecture9-notes.html#11958" class="Bound">n</a><a id="11987" class="Symbol">))</a> <a id="11990" href="Lecture9-notes.html#11945" class="Bound">m</a>

<a id="11993" class="Comment">-- This agrees with regular addition defined by pattern-matching</a>
<a id="+ℤ&#39;≡+ℤ"></a><a id="12058" href="Lecture9-notes.html#12058" data-type="_+ℤ&#39;_ ≡ _+ℤ_" class="Function">+ℤ&#39;≡+ℤ</a> <a id="12065" class="Symbol">:</a> <a id="12067" href="Lecture9-notes.html#11886" data-type="ℤ → ℤ → ℤ" class="Function Operator">_+ℤ&#39;_</a> <a id="12073" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="12075" href="cubical-prelude.html#9160" data-type="ℤ → ℤ → ℤ" class="Function Operator">_+ℤ_</a>
<a id="12080" href="Lecture9-notes.html#12058" data-type="_+ℤ&#39;_ ≡ _+ℤ_" class="Function">+ℤ&#39;≡+ℤ</a> <a id="12087" href="Lecture9-notes.html#12087" class="Bound">i</a> <a id="12089" href="Lecture9-notes.html#12089" class="Bound">m</a> <a id="12091" class="Symbol">(</a><a id="12092" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="12096" href="introduction.html#1050" data-type="ℕ" class="InductiveConstructor">zero</a><a id="12100" class="Symbol">)</a> <a id="12102" class="Symbol">=</a> <a id="12104" href="Lecture9-notes.html#12089" class="Bound">m</a>
<a id="12106" href="Lecture9-notes.html#12058" data-type="_+ℤ&#39;_ ≡ _+ℤ_" class="Function">+ℤ&#39;≡+ℤ</a> <a id="12113" href="Lecture9-notes.html#12113" class="Bound">i</a> <a id="12115" href="Lecture9-notes.html#12115" class="Bound">m</a> <a id="12117" class="Symbol">(</a><a id="12118" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="12122" class="Symbol">(</a><a id="12123" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="12127" href="Lecture9-notes.html#12127" class="Bound">n</a><a id="12128" class="Symbol">))</a> <a id="12131" class="Symbol">=</a> <a id="12133" href="cubical-prelude.html#8536" data-type="ℤ → ℤ" class="Function">sucℤ</a> <a id="12138" class="Symbol">(</a><a id="12139" href="Lecture9-notes.html#12058" data-type="_+ℤ&#39;_ ≡ _+ℤ_" class="Function">+ℤ&#39;≡+ℤ</a> <a id="12146" href="Lecture9-notes.html#12113" class="Bound">i</a> <a id="12148" href="Lecture9-notes.html#12115" class="Bound">m</a> <a id="12150" class="Symbol">(</a><a id="12151" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="12155" href="Lecture9-notes.html#12127" class="Bound">n</a><a id="12156" class="Symbol">))</a>
<a id="12159" href="Lecture9-notes.html#12058" data-type="_+ℤ&#39;_ ≡ _+ℤ_" class="Function">+ℤ&#39;≡+ℤ</a> <a id="12166" href="Lecture9-notes.html#12166" class="Bound">i</a> <a id="12168" href="Lecture9-notes.html#12168" class="Bound">m</a> <a id="12170" class="Symbol">(</a><a id="12171" href="cubical-prelude.html#8514" data-type="ℕ → ℤ" class="InductiveConstructor">negsuc</a> <a id="12178" href="introduction.html#1050" data-type="ℕ" class="InductiveConstructor">zero</a><a id="12182" class="Symbol">)</a> <a id="12184" class="Symbol">=</a> <a id="12186" href="cubical-prelude.html#8652" data-type="ℤ → ℤ" class="Function">predℤ</a> <a id="12192" href="Lecture9-notes.html#12168" class="Bound">m</a>
<a id="12194" href="Lecture9-notes.html#12058" data-type="_+ℤ&#39;_ ≡ _+ℤ_" class="Function">+ℤ&#39;≡+ℤ</a> <a id="12201" href="Lecture9-notes.html#12201" class="Bound">i</a> <a id="12203" href="Lecture9-notes.html#12203" class="Bound">m</a> <a id="12205" class="Symbol">(</a><a id="12206" href="cubical-prelude.html#8514" data-type="ℕ → ℤ" class="InductiveConstructor">negsuc</a> <a id="12213" class="Symbol">(</a><a id="12214" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="12218" href="Lecture9-notes.html#12218" class="Bound">n</a><a id="12219" class="Symbol">))</a> <a id="12222" class="Symbol">=</a> <a id="12224" href="cubical-prelude.html#8652" data-type="ℤ → ℤ" class="Function">predℤ</a> <a id="12230" class="Symbol">(</a><a id="12231" href="Lecture9-notes.html#12058" data-type="_+ℤ&#39;_ ≡ _+ℤ_" class="Function">+ℤ&#39;≡+ℤ</a> <a id="12238" href="Lecture9-notes.html#12201" class="Bound">i</a> <a id="12240" href="Lecture9-notes.html#12203" class="Bound">m</a> <a id="12242" class="Symbol">(</a><a id="12243" href="cubical-prelude.html#8514" data-type="ℕ → ℤ" class="InductiveConstructor">negsuc</a> <a id="12250" href="Lecture9-notes.html#12218" class="Bound">n</a><a id="12251" class="Symbol">))</a>

<a id="12255" class="Comment">-- We can prove that transport is an equivalence easily</a>
<a id="isEquivTransport"></a><a id="12311" href="Lecture9-notes.html#12311" data-type="(p : A ≡ B) → isEquiv (transport p)" class="Function">isEquivTransport</a> <a id="12328" class="Symbol">:</a> <a id="12330" class="Symbol">{</a><a id="12331" href="Lecture9-notes.html#12331" class="Bound">A</a> <a id="12333" href="Lecture9-notes.html#12333" class="Bound">B</a> <a id="12335" class="Symbol">:</a> <a id="12337" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="12342" href="cubical-prelude.html#2241" data-type="Level" class="Generalizable">ℓ</a><a id="12343" class="Symbol">}</a> <a id="12345" class="Symbol">(</a><a id="12346" href="Lecture9-notes.html#12346" class="Bound">p</a> <a id="12348" class="Symbol">:</a> <a id="12350" href="Lecture9-notes.html#12331" class="Bound">A</a> <a id="12352" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="12354" href="Lecture9-notes.html#12333" class="Bound">B</a><a id="12355" class="Symbol">)</a> <a id="12357" class="Symbol">→</a> <a id="12359" href="Agda.Builtin.Cubical.Glue.html#868" data-type="(f : A → B) → Set (ℓ ⊔ ℓ&#39;)" class="Record">isEquiv</a> <a id="12367" class="Symbol">(</a><a id="12368" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="12378" href="Lecture9-notes.html#12346" class="Bound">p</a><a id="12379" class="Symbol">)</a>
<a id="12381" href="Lecture9-notes.html#12311" data-type="(p : A ≡ B) → isEquiv (transport p)" class="Function">isEquivTransport</a> <a id="12398" href="Lecture9-notes.html#12398" class="Bound">p</a> <a id="12400" class="Symbol">=</a>
  <a id="12404" href="Lecture8-notes.html#8148" data-type="A ≡ B → A → B" class="Function">transport</a> <a id="12414" class="Symbol">(λ</a> <a id="12417" href="Lecture9-notes.html#12417" class="Bound">i</a> <a id="12419" class="Symbol">→</a> <a id="12421" href="Agda.Builtin.Cubical.Glue.html#868" data-type="(f : A → B) → Set (ℓ ⊔ ℓ&#39;)" class="Record">isEquiv</a> <a id="12429" class="Symbol">(</a><a id="12430" href="cubical-prelude.html#702" class="Primitive">transp</a> <a id="12437" class="Symbol">(λ</a> <a id="12440" href="Lecture9-notes.html#12440" class="Bound">j</a> <a id="12442" class="Symbol">→</a> <a id="12444" href="Lecture9-notes.html#12398" class="Bound">p</a> <a id="12446" class="Symbol">(</a><a id="12447" href="Lecture9-notes.html#12417" class="Bound">i</a> <a id="12449" href="cubical-prelude.html#449" class="Primitive Operator">∧</a> <a id="12451" href="Lecture9-notes.html#12440" class="Bound">j</a><a id="12452" class="Symbol">))</a> <a id="12455" class="Symbol">(</a><a id="12456" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="12458" href="Lecture9-notes.html#12417" class="Bound">i</a><a id="12459" class="Symbol">)))</a> <a id="12463" class="Symbol">(</a><a id="12464" href="cubical-prelude.html#7747" data-type="(A : Set ℓ) → A ≃ A" class="Function">idEquiv</a> <a id="12472" class="Symbol">_</a> <a id="12474" class="Symbol">.</a><a id="12475" href="cubical-prelude.html#3689" class="Field">pr₂</a><a id="12478" class="Symbol">)</a>

<a id="12481" class="Comment">-- So +ℤ&#39; with a fixed element is an equivalence</a>
<a id="isEquivAddℤ&#39;"></a><a id="12530" href="Lecture9-notes.html#12530" data-type="(m : ℤ) → isEquiv (λ n → n +ℤ&#39; m)" class="Function">isEquivAddℤ&#39;</a> <a id="12543" class="Symbol">:</a> <a id="12545" class="Symbol">(</a><a id="12546" href="Lecture9-notes.html#12546" class="Bound">m</a> <a id="12548" class="Symbol">:</a> <a id="12550" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a><a id="12551" class="Symbol">)</a> <a id="12553" class="Symbol">→</a> <a id="12555" href="Agda.Builtin.Cubical.Glue.html#868" data-type="(f : A → B) → Set (ℓ ⊔ ℓ&#39;)" class="Record">isEquiv</a> <a id="12563" class="Symbol">(λ</a> <a id="12566" href="Lecture9-notes.html#12566" class="Bound">n</a> <a id="12568" class="Symbol">→</a> <a id="12570" href="Lecture9-notes.html#12566" class="Bound">n</a> <a id="12572" href="Lecture9-notes.html#11886" data-type="ℤ → ℤ → ℤ" class="Function Operator">+ℤ&#39;</a> <a id="12576" href="Lecture9-notes.html#12546" class="Bound">m</a><a id="12577" class="Symbol">)</a>
<a id="12579" href="Lecture9-notes.html#12530" data-type="(m : ℤ) → isEquiv (λ n → n +ℤ&#39; m)" class="Function">isEquivAddℤ&#39;</a> <a id="12592" class="Symbol">(</a><a id="12593" href="cubical-prelude.html#8491" data-type="ℕ → ℤ" class="InductiveConstructor">pos</a> <a id="12597" href="Lecture9-notes.html#12597" class="Bound">n</a><a id="12598" class="Symbol">)</a>    <a id="12603" class="Symbol">=</a> <a id="12605" href="Lecture9-notes.html#12311" data-type="(p : A ≡ B) → isEquiv (transport p)" class="Function">isEquivTransport</a> <a id="12622" class="Symbol">(</a><a id="12623" href="Lecture9-notes.html#11655" data-type="ℕ → ℤ ≡ ℤ" class="Function">addPath</a> <a id="12631" href="Lecture9-notes.html#12597" class="Bound">n</a><a id="12632" class="Symbol">)</a>
<a id="12634" href="Lecture9-notes.html#12530" data-type="(m : ℤ) → isEquiv (λ n → n +ℤ&#39; m)" class="Function">isEquivAddℤ&#39;</a> <a id="12647" class="Symbol">(</a><a id="12648" href="cubical-prelude.html#8514" data-type="ℕ → ℤ" class="InductiveConstructor">negsuc</a> <a id="12655" href="Lecture9-notes.html#12655" class="Bound">n</a><a id="12656" class="Symbol">)</a> <a id="12658" class="Symbol">=</a> <a id="12660" href="Lecture9-notes.html#12311" data-type="(p : A ≡ B) → isEquiv (transport p)" class="Function">isEquivTransport</a> <a id="12677" class="Symbol">(</a><a id="12678" href="Lecture9-notes.html#11806" data-type="ℕ → ℤ ≡ ℤ" class="Function">subPath</a> <a id="12686" class="Symbol">(</a><a id="12687" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="12691" href="Lecture9-notes.html#12655" class="Bound">n</a><a id="12692" class="Symbol">))</a>

<a id="isEquivAddℤ"></a><a id="12696" href="Lecture9-notes.html#12696" data-type="(m : ℤ) → isEquiv (λ n → n +ℤ m)" class="Function">isEquivAddℤ</a> <a id="12708" class="Symbol">:</a> <a id="12710" class="Symbol">(</a><a id="12711" href="Lecture9-notes.html#12711" class="Bound">m</a> <a id="12713" class="Symbol">:</a> <a id="12715" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a><a id="12716" class="Symbol">)</a> <a id="12718" class="Symbol">→</a> <a id="12720" href="Agda.Builtin.Cubical.Glue.html#868" data-type="(f : A → B) → Set (ℓ ⊔ ℓ&#39;)" class="Record">isEquiv</a> <a id="12728" class="Symbol">(λ</a> <a id="12731" href="Lecture9-notes.html#12731" class="Bound">n</a> <a id="12733" class="Symbol">→</a> <a id="12735" href="Lecture9-notes.html#12731" class="Bound">n</a> <a id="12737" href="cubical-prelude.html#9160" data-type="ℤ → ℤ → ℤ" class="Function Operator">+ℤ</a> <a id="12740" href="Lecture9-notes.html#12711" class="Bound">m</a><a id="12741" class="Symbol">)</a>
<a id="12743" href="Lecture9-notes.html#12696" data-type="(m : ℤ) → isEquiv (λ n → n +ℤ m)" class="Function">isEquivAddℤ</a> <a id="12755" class="Symbol">=</a> <a id="12757" href="Lecture8-notes.html#8471" data-type="(B : A → Set ℓ&#39;) → x ≡ y → B x → B y" class="Function">subst</a> <a id="12763" class="Symbol">(λ</a> <a id="12766" href="Lecture9-notes.html#12766" class="Bound">add</a> <a id="12770" class="Symbol">→</a> <a id="12772" class="Symbol">(</a><a id="12773" href="Lecture9-notes.html#12773" class="Bound">m</a> <a id="12775" class="Symbol">:</a> <a id="12777" href="cubical-prelude.html#8473" data-type="Set" class="Datatype">ℤ</a><a id="12778" class="Symbol">)</a> <a id="12780" class="Symbol">→</a> <a id="12782" href="Agda.Builtin.Cubical.Glue.html#868" data-type="(f : A → B) → Set (ℓ ⊔ ℓ&#39;)" class="Record">isEquiv</a> <a id="12790" class="Symbol">(λ</a> <a id="12793" href="Lecture9-notes.html#12793" class="Bound">n</a> <a id="12795" class="Symbol">→</a> <a id="12797" href="Lecture9-notes.html#12766" class="Bound">add</a> <a id="12801" href="Lecture9-notes.html#12793" class="Bound">n</a> <a id="12803" href="Lecture9-notes.html#12773" class="Bound">m</a><a id="12804" class="Symbol">))</a> <a id="12807" href="Lecture9-notes.html#12058" data-type="_+ℤ&#39;_ ≡ _+ℤ_" class="Function">+ℤ&#39;≡+ℤ</a> <a id="12814" href="Lecture9-notes.html#12530" data-type="(m : ℤ) → isEquiv (λ n → n +ℤ&#39; m)" class="Function">isEquivAddℤ&#39;</a>
</pre>
<h3 id="the-structure-identity-principle">The structure identity
principle</h3>
<p>Combining <code>subst</code> and <code>ua</code> lets us transport
any structure on <code>A</code> to get a structure on an equivalent type
<code>B</code>:</p>
<pre class="Agda"><a id="substEquiv"></a><a id="12991" href="Lecture9-notes.html#12991" data-type="(S : Set → Set) → A ≃ B → S A → S B" class="Function">substEquiv</a> <a id="13002" class="Symbol">:</a> <a id="13004" class="Symbol">(</a><a id="13005" href="Lecture9-notes.html#13005" class="Bound">S</a> <a id="13007" class="Symbol">:</a> <a id="13009" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="13014" class="Symbol">→</a> <a id="13016" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="13020" class="Symbol">)</a> <a id="13022" class="Symbol">(</a><a id="13023" href="Lecture9-notes.html#13023" class="Bound">e</a> <a id="13025" class="Symbol">:</a> <a id="13027" href="Lecture9-notes.html#336" class="Generalizable">A</a> <a id="13029" href="Agda.Builtin.Cubical.Glue.html#1051" data-type="Set ℓ → Set ℓ&#39; → Set (ℓ ⊔ ℓ&#39;)" class="Function Operator">≃</a> <a id="13031" href="Lecture9-notes.html#338" class="Generalizable">B</a><a id="13032" class="Symbol">)</a> <a id="13034" class="Symbol">→</a> <a id="13036" href="Lecture9-notes.html#13005" class="Bound">S</a> <a id="13038" href="Lecture9-notes.html#336" class="Generalizable">A</a> <a id="13040" class="Symbol">→</a> <a id="13042" href="Lecture9-notes.html#13005" class="Bound">S</a> <a id="13044" href="Lecture9-notes.html#338" class="Generalizable">B</a>
<a id="13046" href="Lecture9-notes.html#12991" data-type="(S : Set → Set) → A ≃ B → S A → S B" class="Function">substEquiv</a> <a id="13057" href="Lecture9-notes.html#13057" class="Bound">S</a> <a id="13059" href="Lecture9-notes.html#13059" class="Bound">e</a> <a id="13061" class="Symbol">=</a> <a id="13063" href="Lecture8-notes.html#8471" data-type="(B : A → Set ℓ&#39;) → x ≡ y → B x → B y" class="Function">subst</a> <a id="13069" href="Lecture9-notes.html#13057" class="Bound">S</a> <a id="13071" class="Symbol">(</a><a id="13072" href="Lecture9-notes.html#8990" data-type="A ≃ B → A ≡ B" class="Function">ua</a> <a id="13075" href="Lecture9-notes.html#13059" class="Bound">e</a><a id="13076" class="Symbol">)</a>
</pre>
<p>In fact this induces an equivalence:</p>
<pre class="Agda"><a id="substEquiv≃"></a><a id="13129" href="Lecture9-notes.html#13129" data-type="(S : Set → Set) → A ≃ B → S A ≃ S B" class="Function">substEquiv≃</a> <a id="13141" class="Symbol">:</a> <a id="13143" class="Symbol">(</a><a id="13144" href="Lecture9-notes.html#13144" class="Bound">S</a> <a id="13146" class="Symbol">:</a> <a id="13148" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="13153" class="Symbol">→</a> <a id="13155" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a><a id="13159" class="Symbol">)</a> <a id="13161" class="Symbol">(</a><a id="13162" href="Lecture9-notes.html#13162" class="Bound">e</a> <a id="13164" class="Symbol">:</a> <a id="13166" href="Lecture9-notes.html#336" class="Generalizable">A</a> <a id="13168" href="Agda.Builtin.Cubical.Glue.html#1051" data-type="Set ℓ → Set ℓ&#39; → Set (ℓ ⊔ ℓ&#39;)" class="Function Operator">≃</a> <a id="13170" href="Lecture9-notes.html#338" class="Generalizable">B</a><a id="13171" class="Symbol">)</a> <a id="13173" class="Symbol">→</a> <a id="13175" href="Lecture9-notes.html#13144" class="Bound">S</a> <a id="13177" href="Lecture9-notes.html#336" class="Generalizable">A</a> <a id="13179" href="Agda.Builtin.Cubical.Glue.html#1051" data-type="Set ℓ → Set ℓ&#39; → Set (ℓ ⊔ ℓ&#39;)" class="Function Operator">≃</a> <a id="13181" href="Lecture9-notes.html#13144" class="Bound">S</a> <a id="13183" href="Lecture9-notes.html#338" class="Generalizable">B</a>
<a id="13185" href="Lecture9-notes.html#13129" data-type="(S : Set → Set) → A ≃ B → S A ≃ S B" class="Function">substEquiv≃</a> <a id="13197" href="Lecture9-notes.html#13197" class="Bound">S</a> <a id="13199" href="Lecture9-notes.html#13199" class="Bound">e</a> <a id="13201" class="Symbol">=</a> <a id="13203" class="Symbol">(</a><a id="13204" href="Lecture9-notes.html#12991" data-type="(S : Set → Set) → A ≃ B → S A → S B" class="Function">substEquiv</a> <a id="13215" href="Lecture9-notes.html#13197" class="Bound">S</a> <a id="13217" href="Lecture9-notes.html#13199" class="Bound">e</a><a id="13218" class="Symbol">)</a> <a id="13220" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="13222" class="Symbol">(</a><a id="13223" href="Lecture9-notes.html#12311" data-type="(p : A ≡ B) → isEquiv (transport p)" class="Function">isEquivTransport</a> <a id="13240" class="Symbol">(</a><a id="13241" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="13244" href="Lecture9-notes.html#13197" class="Bound">S</a> <a id="13246" class="Symbol">(</a><a id="13247" href="Lecture9-notes.html#8990" data-type="A ≃ B → A ≡ B" class="Function">ua</a> <a id="13250" href="Lecture9-notes.html#13199" class="Bound">e</a><a id="13251" class="Symbol">)))</a>
</pre>
<p>What this says is that any structure on types must be invariant under
equivalence. We can for example take <code>IsMonoid</code> for
<code>S</code> and get that any two monoid structures on equivalent
types <code>A</code> and <code>B</code> are themselves equivalent. This
is a simple version of the <em>structure identity principle</em> (SIP).
There are various more high powered and generalized versions which also
work for <em>structured</em> types (e.g. monoids, groups, etc.) together
with their corresponding notions of <em>structured</em> equivalences
(e.g. monoid and group isomorphism, etc.). We will look more at this
later, but for now let’s look at a nice example where we can use
<code>substEquiv</code> to transport functions and their properties
between equivalent types.</p>
<p>When programming and proving properties of programs there are usually
various tradeoffs between different data representations. Very often one
version is suitable for proofs while the other is more suitable for
efficient programming. The standard example of them is unary and binary
numbers. One way to define binary numbers in Agda is as:</p>
<pre class="text"><code>data Pos : Type where
  pos1  : Pos
  x0    : Pos → Pos
  x1    : Pos → Pos

data Bin : Type where
  bin0    : Bin
  binPos  : Pos → Bin</code></pre>
<p>With some work one can prove that this is equivalent to unary numbers
(see the cubical-prelude for details):</p>
<pre class="Agda"><a id="ℕ≃Bin"></a><a id="14581" href="Lecture9-notes.html#14581" data-type="ℕ ≃ Bin" class="Function">ℕ≃Bin</a> <a id="14587" class="Symbol">:</a> <a id="14589" href="introduction.html#1034" data-type="Set" class="Datatype">ℕ</a> <a id="14591" href="Agda.Builtin.Cubical.Glue.html#1051" data-type="Set ℓ → Set ℓ&#39; → Set (ℓ ⊔ ℓ&#39;)" class="Function Operator">≃</a> <a id="14593" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a>
<a id="14597" href="Lecture9-notes.html#14581" data-type="ℕ ≃ Bin" class="Function">ℕ≃Bin</a>  <a id="14604" class="Symbol">=</a> <a id="14606" href="cubical-prelude.html#7452" data-type="Iso A B → A ≃ B" class="Function">isoToEquiv</a> <a id="14617" class="Symbol">(</a><a id="14618" href="cubical-prelude.html#5514" data-type="(fun : A → B) (inv : B → A) (rightInv : section fun inv)
(leftInv : retract fun inv) →
Iso A B" class="InductiveConstructor">iso</a> <a id="14622" href="cubical-prelude.html#13299" data-type="ℕ → Bin" class="Function">ℕ→Bin</a> <a id="14628" href="cubical-prelude.html#13378" data-type="Bin → ℕ" class="Function">Bin→ℕ</a> <a id="14634" href="cubical-prelude.html#13740" data-type="(n : Bin) → ℕ→Bin (Bin→ℕ n) ≡ n" class="Function">Bin→ℕ→Bin</a> <a id="14644" href="cubical-prelude.html#13448" data-type="(n : ℕ) → Bin→ℕ (ℕ→Bin n) ≡ n" class="Function">ℕ→Bin→ℕ</a><a id="14651" class="Symbol">)</a>
</pre>
<p>We can now use <code>substEquiv</code> to transport addition on
<code>ℕ</code> together with the fact that it’s associative over to
<code>Bin</code>:</p>
<pre class="Agda"><a id="SemiGroup"></a><a id="14784" href="Lecture9-notes.html#14784" data-type="Set → Set" class="Function">SemiGroup</a> <a id="14794" class="Symbol">:</a> <a id="14796" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a> <a id="14801" class="Symbol">→</a> <a id="14803" href="Agda.Primitive.html#326" data-type="Set₁" class="Primitive">Type</a>
<a id="14808" href="Lecture9-notes.html#14784" data-type="Set → Set" class="Function">SemiGroup</a> <a id="14818" href="Lecture9-notes.html#14818" class="Bound">X</a> <a id="14820" class="Symbol">=</a> <a id="14822" href="cubical-prelude.html#3695" data-type="(A : Set l1) → (A → Set l2) → Set (l1 ⊔ l2)" class="Function">Σ</a> <a id="14824" href="Lecture9-notes.html#14824" class="Bound Operator">_+_</a> <a id="14828" href="cubical-prelude.html#3695" data-type="(A : Set l1) → (A → Set l2) → Set (l1 ⊔ l2)" class="Function">꞉</a> <a id="14830" class="Symbol">(</a><a id="14831" href="Lecture9-notes.html#14818" class="Bound">X</a> <a id="14833" class="Symbol">→</a> <a id="14835" href="Lecture9-notes.html#14818" class="Bound">X</a> <a id="14837" class="Symbol">→</a> <a id="14839" href="Lecture9-notes.html#14818" class="Bound">X</a><a id="14840" class="Symbol">)</a> <a id="14842" href="cubical-prelude.html#3695" data-type="(A : Set l1) → (A → Set l2) → Set (l1 ⊔ l2)" class="Function">,</a> <a id="14844" class="Symbol">((</a><a id="14846" href="Lecture9-notes.html#14846" class="Bound">x</a> <a id="14848" href="Lecture9-notes.html#14848" class="Bound">y</a> <a id="14850" href="Lecture9-notes.html#14850" class="Bound">z</a> <a id="14852" class="Symbol">:</a> <a id="14854" href="Lecture9-notes.html#14818" class="Bound">X</a><a id="14855" class="Symbol">)</a> <a id="14857" class="Symbol">→</a> <a id="14859" href="Lecture9-notes.html#14846" class="Bound">x</a> <a id="14861" href="Lecture9-notes.html#14824" class="Bound Operator">+</a> <a id="14863" class="Symbol">(</a><a id="14864" href="Lecture9-notes.html#14848" class="Bound">y</a> <a id="14866" href="Lecture9-notes.html#14824" class="Bound Operator">+</a> <a id="14868" href="Lecture9-notes.html#14850" class="Bound">z</a><a id="14869" class="Symbol">)</a> <a id="14871" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="14873" class="Symbol">(</a><a id="14874" href="Lecture9-notes.html#14846" class="Bound">x</a> <a id="14876" href="Lecture9-notes.html#14824" class="Bound Operator">+</a> <a id="14878" href="Lecture9-notes.html#14848" class="Bound">y</a><a id="14879" class="Symbol">)</a> <a id="14881" href="Lecture9-notes.html#14824" class="Bound Operator">+</a> <a id="14883" href="Lecture9-notes.html#14850" class="Bound">z</a><a id="14884" class="Symbol">)</a>

<a id="SemiGroupBin"></a><a id="14887" href="Lecture9-notes.html#14887" data-type="SemiGroup Bin" class="Function">SemiGroupBin</a> <a id="14900" class="Symbol">:</a> <a id="14902" href="Lecture9-notes.html#14784" data-type="Set → Set" class="Function">SemiGroup</a> <a id="14912" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a>
<a id="14916" href="Lecture9-notes.html#14887" data-type="SemiGroup Bin" class="Function">SemiGroupBin</a> <a id="14929" class="Symbol">=</a> <a id="14931" href="Lecture9-notes.html#12991" data-type="(S : Set → Set) → A ≃ B → S A → S B" class="Function">substEquiv</a> <a id="14942" href="Lecture9-notes.html#14784" data-type="Set → Set" class="Function">SemiGroup</a> <a id="14952" href="Lecture9-notes.html#14581" data-type="ℕ ≃ Bin" class="Function">ℕ≃Bin</a> <a id="14958" class="Symbol">(</a><a id="14959" href="introduction.html#1782" data-type="ℕ → ℕ → ℕ" class="Function Operator">_+_</a> <a id="14963" href="Agda.Builtin.Sigma.html#236" data-type="(fst : A) (snd : B fst) → Σ A B" class="InductiveConstructor Operator">,</a> <a id="14965" href="cubical-prelude.html#10488" data-type="(m n o : ℕ) → (m + n + o) ≡ ((m + n) + o)" class="Function">+-assoc</a><a id="14972" class="Symbol">)</a>

<a id="_+Bin_"></a><a id="14975" href="Lecture9-notes.html#14975" data-type="Bin → Bin → Bin" class="Function Operator">_+Bin_</a> <a id="14982" class="Symbol">:</a> <a id="14984" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a> <a id="14988" class="Symbol">→</a> <a id="14990" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a> <a id="14994" class="Symbol">→</a> <a id="14996" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a>
<a id="15000" href="Lecture9-notes.html#14975" data-type="Bin → Bin → Bin" class="Function Operator">_+Bin_</a>  <a id="15008" class="Symbol">=</a> <a id="15010" href="cubical-prelude.html#3676" class="Field">pr₁</a> <a id="15014" href="Lecture9-notes.html#14887" data-type="SemiGroup Bin" class="Function">SemiGroupBin</a>

<a id="+Bin-assoc"></a><a id="15028" href="Lecture9-notes.html#15028" data-type="(m n o : Bin) → (m +Bin (n +Bin o)) ≡ ((m +Bin n) +Bin o)" class="Function">+Bin-assoc</a> <a id="15039" class="Symbol">:</a> <a id="15041" class="Symbol">(</a><a id="15042" href="Lecture9-notes.html#15042" class="Bound">m</a> <a id="15044" href="Lecture9-notes.html#15044" class="Bound">n</a> <a id="15046" href="Lecture9-notes.html#15046" class="Bound">o</a> <a id="15048" class="Symbol">:</a> <a id="15050" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a><a id="15053" class="Symbol">)</a> <a id="15055" class="Symbol">→</a> <a id="15057" href="Lecture9-notes.html#15042" class="Bound">m</a> <a id="15059" href="Lecture9-notes.html#14975" data-type="Bin → Bin → Bin" class="Function Operator">+Bin</a> <a id="15064" class="Symbol">(</a><a id="15065" href="Lecture9-notes.html#15044" class="Bound">n</a> <a id="15067" href="Lecture9-notes.html#14975" data-type="Bin → Bin → Bin" class="Function Operator">+Bin</a> <a id="15072" href="Lecture9-notes.html#15046" class="Bound">o</a><a id="15073" class="Symbol">)</a> <a id="15075" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="15077" class="Symbol">(</a><a id="15078" href="Lecture9-notes.html#15042" class="Bound">m</a> <a id="15080" href="Lecture9-notes.html#14975" data-type="Bin → Bin → Bin" class="Function Operator">+Bin</a> <a id="15085" href="Lecture9-notes.html#15044" class="Bound">n</a><a id="15086" class="Symbol">)</a> <a id="15088" href="Lecture9-notes.html#14975" data-type="Bin → Bin → Bin" class="Function Operator">+Bin</a> <a id="15093" href="Lecture9-notes.html#15046" class="Bound">o</a>
<a id="15095" href="Lecture9-notes.html#15028" data-type="(m n o : Bin) → (m +Bin (n +Bin o)) ≡ ((m +Bin n) +Bin o)" class="Function">+Bin-assoc</a> <a id="15106" class="Symbol">=</a> <a id="15108" href="cubical-prelude.html#3689" class="Field">pr₂</a> <a id="15112" href="Lecture9-notes.html#14887" data-type="SemiGroup Bin" class="Function">SemiGroupBin</a>
</pre>
<p>This is nice as it helps us avoid having to repeat work on
<code>Bin</code> that we have already done on <code>ℕ</code>. This is
however not always what we want as <code>_+Bin_</code> is not very
efficient as an addition function on binary numbers. In fact, it will
translate its input to unary numbers, add using unary addition, and then
translate back. This is of course very naive and what we instead want to
do is to use efficient addition on binary numbers, but get the
associativity proof for free.</p>
<p>This can be achieved by first defining our fast addition
<code>_+B_ : Bin → Bin → Bin</code> and then prove that the map
<code>ℕ→Bin : ℕ → Bin</code> maps <code>x + y : ℕ</code> to
<code>ℕ→Bin x +B ℕ→Bin y : Bin</code>.</p>
<pre class="Agda"><a id="15784" class="Keyword">mutual</a>
  <a id="_+P_"></a><a id="15793" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">_+P_</a> <a id="15798" class="Symbol">:</a> <a id="15800" href="cubical-prelude.html#11064" data-type="Set" class="Datatype">Pos</a> <a id="15804" class="Symbol">→</a> <a id="15806" href="cubical-prelude.html#11064" data-type="Set" class="Datatype">Pos</a> <a id="15810" class="Symbol">→</a> <a id="15812" href="cubical-prelude.html#11064" data-type="Set" class="Datatype">Pos</a>
  <a id="15818" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="15824" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15827" href="Lecture9-notes.html#15827" class="Bound">y</a>     <a id="15833" class="Symbol">=</a> <a id="15835" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="15842" href="Lecture9-notes.html#15827" class="Bound">y</a>
  <a id="15846" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="15849" href="Lecture9-notes.html#15849" class="Bound">x</a>  <a id="15852" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15855" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="15861" class="Symbol">=</a> <a id="15863" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="15866" href="Lecture9-notes.html#15849" class="Bound">x</a>
  <a id="15870" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="15873" href="Lecture9-notes.html#15873" class="Bound">x</a>  <a id="15876" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15879" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="15882" href="Lecture9-notes.html#15882" class="Bound">y</a>  <a id="15885" class="Symbol">=</a> <a id="15887" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="15890" class="Symbol">(</a><a id="15891" href="Lecture9-notes.html#15873" class="Bound">x</a> <a id="15893" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15896" href="Lecture9-notes.html#15882" class="Bound">y</a><a id="15897" class="Symbol">)</a>
  <a id="15901" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="15904" href="Lecture9-notes.html#15904" class="Bound">x</a>  <a id="15907" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15910" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="15913" href="Lecture9-notes.html#15913" class="Bound">y</a>  <a id="15916" class="Symbol">=</a> <a id="15918" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="15921" class="Symbol">(</a><a id="15922" href="Lecture9-notes.html#15904" class="Bound">x</a> <a id="15924" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15927" href="Lecture9-notes.html#15913" class="Bound">y</a><a id="15928" class="Symbol">)</a>
  <a id="15932" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="15935" href="Lecture9-notes.html#15935" class="Bound">x</a>  <a id="15938" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15941" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="15947" class="Symbol">=</a> <a id="15949" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="15952" class="Symbol">(</a><a id="15953" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="15960" href="Lecture9-notes.html#15935" class="Bound">x</a><a id="15961" class="Symbol">)</a>
  <a id="15965" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="15968" href="Lecture9-notes.html#15968" class="Bound">x</a>  <a id="15971" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15974" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="15977" href="Lecture9-notes.html#15977" class="Bound">y</a>  <a id="15980" class="Symbol">=</a> <a id="15982" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="15985" class="Symbol">(</a><a id="15986" href="Lecture9-notes.html#15968" class="Bound">x</a> <a id="15988" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="15991" href="Lecture9-notes.html#15977" class="Bound">y</a><a id="15992" class="Symbol">)</a>
  <a id="15996" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="15999" href="Lecture9-notes.html#15999" class="Bound">x</a>  <a id="16002" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="16005" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16008" href="Lecture9-notes.html#16008" class="Bound">y</a>  <a id="16011" class="Symbol">=</a> <a id="16013" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16016" class="Symbol">(</a><a id="16017" href="Lecture9-notes.html#15999" class="Bound">x</a> <a id="16019" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16023" href="Lecture9-notes.html#16008" class="Bound">y</a><a id="16024" class="Symbol">)</a>

  <a id="_+B_"></a><a id="16029" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">_+B_</a> <a id="16034" class="Symbol">:</a> <a id="16036" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a> <a id="16040" class="Symbol">→</a> <a id="16042" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a> <a id="16046" class="Symbol">→</a> <a id="16048" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a>
  <a id="16054" href="cubical-prelude.html#13262" data-type="Bin" class="InductiveConstructor">bin0</a>      <a id="16064" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="16067" href="Lecture9-notes.html#16067" class="Bound">y</a>         <a id="16077" class="Symbol">=</a> <a id="16079" href="Lecture9-notes.html#16067" class="Bound">y</a>
  <a id="16083" href="Lecture9-notes.html#16083" class="CatchallClause Bound">x</a><a id="16084" class="CatchallClause">         </a><a id="16093" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="CatchallClause Function Operator">+B</a><a id="16095" class="CatchallClause"> </a><a id="16096" href="cubical-prelude.html#13262" data-type="Bin" class="CatchallClause InductiveConstructor">bin0</a>      <a id="16106" class="Symbol">=</a> <a id="16108" href="Lecture9-notes.html#16083" class="Bound">x</a>
  <a id="16112" href="cubical-prelude.html#13278" data-type="Pos → Bin" class="InductiveConstructor">binPos</a> <a id="16119" href="Lecture9-notes.html#16119" class="Bound">x</a>  <a id="16122" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="16125" href="cubical-prelude.html#13278" data-type="Pos → Bin" class="InductiveConstructor">binPos</a> <a id="16132" href="Lecture9-notes.html#16132" class="Bound">y</a>  <a id="16135" class="Symbol">=</a> <a id="16137" href="cubical-prelude.html#13278" data-type="Pos → Bin" class="InductiveConstructor">binPos</a> <a id="16144" class="Symbol">(</a><a id="16145" href="Lecture9-notes.html#16119" class="Bound">x</a> <a id="16147" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="16150" href="Lecture9-notes.html#16132" class="Bound">y</a><a id="16151" class="Symbol">)</a>

  <a id="16156" class="Comment">-- Add with carry</a>
  <a id="_+PC_"></a><a id="16176" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">_+PC_</a> <a id="16182" class="Symbol">:</a> <a id="16184" href="cubical-prelude.html#11064" data-type="Set" class="Datatype">Pos</a> <a id="16188" class="Symbol">→</a> <a id="16190" href="cubical-prelude.html#11064" data-type="Set" class="Datatype">Pos</a> <a id="16194" class="Symbol">→</a> <a id="16196" href="cubical-prelude.html#11064" data-type="Set" class="Datatype">Pos</a>
  <a id="16202" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="16208" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16212" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="16218" class="Symbol">=</a> <a id="16220" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16223" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>
  <a id="16230" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="16236" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16240" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16243" href="Lecture9-notes.html#16243" class="Bound">y</a>  <a id="16246" class="Symbol">=</a> <a id="16248" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16251" class="Symbol">(</a><a id="16252" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="16259" href="Lecture9-notes.html#16243" class="Bound">y</a><a id="16260" class="Symbol">)</a>
  <a id="16264" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="16270" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16274" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16277" href="Lecture9-notes.html#16277" class="Bound">y</a>  <a id="16280" class="Symbol">=</a> <a id="16282" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16285" class="Symbol">(</a><a id="16286" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="16293" href="Lecture9-notes.html#16277" class="Bound">y</a><a id="16294" class="Symbol">)</a>
  <a id="16298" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16301" href="Lecture9-notes.html#16301" class="Bound">x</a>  <a id="16304" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16308" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="16314" class="Symbol">=</a> <a id="16316" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16319" class="Symbol">(</a><a id="16320" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="16327" href="Lecture9-notes.html#16301" class="Bound">x</a><a id="16328" class="Symbol">)</a>
  <a id="16332" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16335" href="Lecture9-notes.html#16335" class="Bound">x</a>  <a id="16338" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16342" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16345" href="Lecture9-notes.html#16345" class="Bound">y</a>  <a id="16348" class="Symbol">=</a> <a id="16350" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16353" class="Symbol">(</a><a id="16354" href="Lecture9-notes.html#16335" class="Bound">x</a> <a id="16356" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="16359" href="Lecture9-notes.html#16345" class="Bound">y</a><a id="16360" class="Symbol">)</a>
  <a id="16364" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16367" href="Lecture9-notes.html#16367" class="Bound">x</a>  <a id="16370" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16374" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16377" href="Lecture9-notes.html#16377" class="Bound">y</a>  <a id="16380" class="Symbol">=</a> <a id="16382" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16385" class="Symbol">(</a><a id="16386" href="Lecture9-notes.html#16367" class="Bound">x</a> <a id="16388" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16392" href="Lecture9-notes.html#16377" class="Bound">y</a><a id="16393" class="Symbol">)</a>
  <a id="16397" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16400" href="Lecture9-notes.html#16400" class="Bound">x</a>  <a id="16403" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16407" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>  <a id="16413" class="Symbol">=</a> <a id="16415" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16418" class="Symbol">(</a><a id="16419" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="16426" href="Lecture9-notes.html#16400" class="Bound">x</a><a id="16427" class="Symbol">)</a>
  <a id="16431" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16434" href="Lecture9-notes.html#16434" class="Bound">x</a>  <a id="16437" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16441" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16444" href="Lecture9-notes.html#16444" class="Bound">y</a>  <a id="16447" class="Symbol">=</a> <a id="16449" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16452" class="Symbol">(</a><a id="16453" href="Lecture9-notes.html#16434" class="Bound">x</a> <a id="16455" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16459" href="Lecture9-notes.html#16444" class="Bound">y</a><a id="16460" class="Symbol">)</a>
  <a id="16464" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16467" href="Lecture9-notes.html#16467" class="Bound">x</a>  <a id="16470" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16474" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16477" href="Lecture9-notes.html#16477" class="Bound">y</a>  <a id="16480" class="Symbol">=</a> <a id="16482" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16485" class="Symbol">(</a><a id="16486" href="Lecture9-notes.html#16467" class="Bound">x</a> <a id="16488" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16492" href="Lecture9-notes.html#16477" class="Bound">y</a><a id="16493" class="Symbol">)</a>

<a id="16496" class="Comment">-- Correctness:</a>
<a id="+PC-suc"></a><a id="16512" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16520" class="Symbol">:</a> <a id="16522" class="Symbol">(</a><a id="16523" href="Lecture9-notes.html#16523" class="Bound">x</a> <a id="16525" href="Lecture9-notes.html#16525" class="Bound">y</a> <a id="16527" class="Symbol">:</a> <a id="16529" href="cubical-prelude.html#11064" data-type="Set" class="Datatype">Pos</a><a id="16532" class="Symbol">)</a> <a id="16534" class="Symbol">→</a> <a id="16536" href="Lecture9-notes.html#16523" class="Bound">x</a> <a id="16538" href="Lecture9-notes.html#16176" data-type="Pos → Pos → Pos" class="Function Operator">+PC</a> <a id="16542" href="Lecture9-notes.html#16525" class="Bound">y</a> <a id="16544" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="16546" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="16553" class="Symbol">(</a><a id="16554" href="Lecture9-notes.html#16523" class="Bound">x</a> <a id="16556" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="16559" href="Lecture9-notes.html#16525" class="Bound">y</a><a id="16560" class="Symbol">)</a>
<a id="16562" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16570" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a> <a id="16575" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>     <a id="16584" class="Symbol">=</a> <a id="16586" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="16591" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16599" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a> <a id="16604" class="Symbol">(</a><a id="16605" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16608" href="Lecture9-notes.html#16608" class="Bound">y</a><a id="16609" class="Symbol">)</a>   <a id="16613" class="Symbol">=</a> <a id="16615" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="16620" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16628" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a> <a id="16633" class="Symbol">(</a><a id="16634" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16637" href="Lecture9-notes.html#16637" class="Bound">y</a><a id="16638" class="Symbol">)</a>   <a id="16642" class="Symbol">=</a> <a id="16644" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="16649" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16657" class="Symbol">(</a><a id="16658" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16661" href="Lecture9-notes.html#16661" class="Bound">x</a><a id="16662" class="Symbol">)</a> <a id="16664" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>   <a id="16671" class="Symbol">=</a> <a id="16673" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="16678" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16686" class="Symbol">(</a><a id="16687" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16690" href="Lecture9-notes.html#16690" class="Bound">x</a><a id="16691" class="Symbol">)</a> <a id="16693" class="Symbol">(</a><a id="16694" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16697" href="Lecture9-notes.html#16697" class="Bound">y</a><a id="16698" class="Symbol">)</a> <a id="16700" class="Symbol">=</a> <a id="16702" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="16707" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16715" class="Symbol">(</a><a id="16716" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16719" href="Lecture9-notes.html#16719" class="Bound">x</a><a id="16720" class="Symbol">)</a> <a id="16722" class="Symbol">(</a><a id="16723" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16726" href="Lecture9-notes.html#16726" class="Bound">y</a><a id="16727" class="Symbol">)</a> <a id="16729" class="Symbol">=</a> <a id="16731" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="16734" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16737" class="Symbol">(</a><a id="16738" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16746" href="Lecture9-notes.html#16719" class="Bound">x</a> <a id="16748" href="Lecture9-notes.html#16726" class="Bound">y</a><a id="16749" class="Symbol">)</a>
<a id="16751" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16759" class="Symbol">(</a><a id="16760" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16763" href="Lecture9-notes.html#16763" class="Bound">x</a><a id="16764" class="Symbol">)</a> <a id="16766" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>   <a id="16773" class="Symbol">=</a> <a id="16775" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="16780" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16788" class="Symbol">(</a><a id="16789" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16792" href="Lecture9-notes.html#16792" class="Bound">x</a><a id="16793" class="Symbol">)</a> <a id="16795" class="Symbol">(</a><a id="16796" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16799" href="Lecture9-notes.html#16799" class="Bound">y</a><a id="16800" class="Symbol">)</a> <a id="16802" class="Symbol">=</a> <a id="16804" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="16807" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16810" class="Symbol">(</a><a id="16811" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16819" href="Lecture9-notes.html#16792" class="Bound">x</a> <a id="16821" href="Lecture9-notes.html#16799" class="Bound">y</a><a id="16822" class="Symbol">)</a>
<a id="16824" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="16832" class="Symbol">(</a><a id="16833" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16836" href="Lecture9-notes.html#16836" class="Bound">x</a><a id="16837" class="Symbol">)</a> <a id="16839" class="Symbol">(</a><a id="16840" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16843" href="Lecture9-notes.html#16843" class="Bound">y</a><a id="16844" class="Symbol">)</a> <a id="16846" class="Symbol">=</a> <a id="16848" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>

<a id="sucPos-+P"></a><a id="16854" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="16864" class="Symbol">:</a> <a id="16866" class="Symbol">(</a><a id="16867" href="Lecture9-notes.html#16867" class="Bound">x</a> <a id="16869" href="Lecture9-notes.html#16869" class="Bound">y</a> <a id="16871" class="Symbol">:</a> <a id="16873" href="cubical-prelude.html#11064" data-type="Set" class="Datatype">Pos</a><a id="16876" class="Symbol">)</a> <a id="16878" class="Symbol">→</a> <a id="16880" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="16887" class="Symbol">(</a><a id="16888" href="Lecture9-notes.html#16867" class="Bound">x</a> <a id="16890" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="16893" href="Lecture9-notes.html#16869" class="Bound">y</a><a id="16894" class="Symbol">)</a> <a id="16896" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="16898" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="16905" href="Lecture9-notes.html#16867" class="Bound">x</a> <a id="16907" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="16910" href="Lecture9-notes.html#16869" class="Bound">y</a>
<a id="16912" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="16922" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a> <a id="16927" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>     <a id="16936" class="Symbol">=</a> <a id="16938" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="16943" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="16953" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a> <a id="16958" class="Symbol">(</a><a id="16959" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="16962" href="Lecture9-notes.html#16962" class="Bound">y</a><a id="16963" class="Symbol">)</a>   <a id="16967" class="Symbol">=</a> <a id="16969" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="16974" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="16984" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a> <a id="16989" class="Symbol">(</a><a id="16990" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="16993" href="Lecture9-notes.html#16993" class="Bound">y</a><a id="16994" class="Symbol">)</a>   <a id="16998" class="Symbol">=</a> <a id="17000" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="17005" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17015" class="Symbol">(</a><a id="17016" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="17019" href="Lecture9-notes.html#17019" class="Bound">x</a><a id="17020" class="Symbol">)</a> <a id="17022" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>   <a id="17029" class="Symbol">=</a> <a id="17031" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="17036" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17046" class="Symbol">(</a><a id="17047" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="17050" href="Lecture9-notes.html#17050" class="Bound">x</a><a id="17051" class="Symbol">)</a> <a id="17053" class="Symbol">(</a><a id="17054" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="17057" href="Lecture9-notes.html#17057" class="Bound">y</a><a id="17058" class="Symbol">)</a> <a id="17060" class="Symbol">=</a> <a id="17062" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="17067" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17077" class="Symbol">(</a><a id="17078" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="17081" href="Lecture9-notes.html#17081" class="Bound">x</a><a id="17082" class="Symbol">)</a> <a id="17084" class="Symbol">(</a><a id="17085" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="17088" href="Lecture9-notes.html#17088" class="Bound">y</a><a id="17089" class="Symbol">)</a> <a id="17091" class="Symbol">=</a> <a id="17093" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="17096" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="17099" class="Symbol">(</a><a id="17100" href="Lecture7-notes.html#6920" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="17104" class="Symbol">(</a><a id="17105" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a> <a id="17113" href="Lecture9-notes.html#17081" class="Bound">x</a> <a id="17115" href="Lecture9-notes.html#17088" class="Bound">y</a><a id="17116" class="Symbol">))</a>
<a id="17119" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17129" class="Symbol">(</a><a id="17130" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="17133" href="Lecture9-notes.html#17133" class="Bound">x</a><a id="17134" class="Symbol">)</a> <a id="17136" href="cubical-prelude.html#11083" data-type="Pos" class="InductiveConstructor">pos1</a>   <a id="17143" class="Symbol">=</a> <a id="17145" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="17150" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17160" class="Symbol">(</a><a id="17161" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="17164" href="Lecture9-notes.html#17164" class="Bound">x</a><a id="17165" class="Symbol">)</a> <a id="17167" class="Symbol">(</a><a id="17168" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="17171" href="Lecture9-notes.html#17171" class="Bound">y</a><a id="17172" class="Symbol">)</a> <a id="17174" class="Symbol">=</a> <a id="17176" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="17179" href="cubical-prelude.html#11097" data-type="Pos → Pos" class="InductiveConstructor">x0</a> <a id="17182" class="Symbol">(</a><a id="17183" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17193" href="Lecture9-notes.html#17164" class="Bound">x</a> <a id="17195" href="Lecture9-notes.html#17171" class="Bound">y</a><a id="17196" class="Symbol">)</a>
<a id="17198" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17208" class="Symbol">(</a><a id="17209" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="17212" href="Lecture9-notes.html#17212" class="Bound">x</a><a id="17213" class="Symbol">)</a> <a id="17215" class="Symbol">(</a><a id="17216" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="17219" href="Lecture9-notes.html#17219" class="Bound">y</a><a id="17220" class="Symbol">)</a> <a id="17222" class="Symbol">=</a> <a id="17224" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="17227" href="cubical-prelude.html#11117" data-type="Pos → Pos" class="InductiveConstructor">x1</a> <a id="17230" class="Symbol">(</a><a id="17231" href="Lecture9-notes.html#16512" data-type="(x y : Pos) → (x +PC y) ≡ sucPos (x +P y)" class="Function">+PC-suc</a>  <a id="17240" href="Lecture9-notes.html#17212" class="Bound">x</a> <a id="17242" href="Lecture9-notes.html#17219" class="Bound">y</a> <a id="17244" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="17246" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17256" href="Lecture9-notes.html#17212" class="Bound">x</a> <a id="17258" href="Lecture9-notes.html#17219" class="Bound">y</a><a id="17259" class="Symbol">)</a>

<a id="ℕ→Pos-+P"></a><a id="17262" href="Lecture9-notes.html#17262" data-type="(x y : ℕ) →
ℕ→Pos (suc x + suc y) ≡ (ℕ→Pos (suc x) +P ℕ→Pos (suc y))" class="Function">ℕ→Pos-+P</a> <a id="17271" class="Symbol">:</a> <a id="17273" class="Symbol">(</a><a id="17274" href="Lecture9-notes.html#17274" class="Bound">x</a> <a id="17276" href="Lecture9-notes.html#17276" class="Bound">y</a> <a id="17278" class="Symbol">:</a> <a id="17280" href="introduction.html#1034" data-type="Set" class="Datatype">ℕ</a><a id="17281" class="Symbol">)</a> <a id="17283" class="Symbol">→</a> <a id="17285" href="cubical-prelude.html#12332" data-type="ℕ → Pos" class="Function">ℕ→Pos</a> <a id="17291" class="Symbol">(</a><a id="17292" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17296" href="Lecture9-notes.html#17274" class="Bound">x</a> <a id="17298" href="introduction.html#1782" data-type="ℕ → ℕ → ℕ" class="Function Operator">+</a> <a id="17300" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17304" href="Lecture9-notes.html#17276" class="Bound">y</a><a id="17305" class="Symbol">)</a> <a id="17307" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="17309" href="cubical-prelude.html#12332" data-type="ℕ → Pos" class="Function">ℕ→Pos</a> <a id="17315" class="Symbol">(</a><a id="17316" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17320" href="Lecture9-notes.html#17274" class="Bound">x</a><a id="17321" class="Symbol">)</a> <a id="17323" href="Lecture9-notes.html#15793" data-type="Pos → Pos → Pos" class="Function Operator">+P</a> <a id="17326" href="cubical-prelude.html#12332" data-type="ℕ → Pos" class="Function">ℕ→Pos</a> <a id="17332" class="Symbol">(</a><a id="17333" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17337" href="Lecture9-notes.html#17276" class="Bound">y</a><a id="17338" class="Symbol">)</a>
<a id="17340" href="Lecture9-notes.html#17262" data-type="(x y : ℕ) →
ℕ→Pos (suc x + suc y) ≡ (ℕ→Pos (suc x) +P ℕ→Pos (suc y))" class="Function">ℕ→Pos-+P</a> <a id="17349" href="introduction.html#1050" data-type="ℕ" class="InductiveConstructor">zero</a> <a id="17354" class="Symbol">_</a>    <a id="17359" class="Symbol">=</a> <a id="17361" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="17366" href="Lecture9-notes.html#17262" data-type="(x y : ℕ) →
ℕ→Pos (suc x + suc y) ≡ (ℕ→Pos (suc x) +P ℕ→Pos (suc y))" class="Function">ℕ→Pos-+P</a> <a id="17375" class="Symbol">(</a><a id="17376" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17380" href="Lecture9-notes.html#17380" class="Bound">x</a><a id="17381" class="Symbol">)</a> <a id="17383" href="Lecture9-notes.html#17383" class="Bound">y</a> <a id="17385" class="Symbol">=</a> <a id="17387" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="17390" href="cubical-prelude.html#11136" data-type="Pos → Pos" class="Function">sucPos</a> <a id="17397" class="Symbol">(</a><a id="17398" href="Lecture9-notes.html#17262" data-type="(x y : ℕ) →
ℕ→Pos (suc x + suc y) ≡ (ℕ→Pos (suc x) +P ℕ→Pos (suc y))" class="Function">ℕ→Pos-+P</a> <a id="17407" href="Lecture9-notes.html#17380" class="Bound">x</a> <a id="17409" href="Lecture9-notes.html#17383" class="Bound">y</a><a id="17410" class="Symbol">)</a> <a id="17412" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="17414" href="Lecture9-notes.html#16854" data-type="(x y : Pos) → sucPos (x +P y) ≡ (sucPos x +P y)" class="Function">sucPos-+P</a> <a id="17424" class="Symbol">(</a><a id="17425" href="cubical-prelude.html#12332" data-type="ℕ → Pos" class="Function">ℕ→Pos</a> <a id="17431" class="Symbol">(</a><a id="17432" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17436" href="Lecture9-notes.html#17380" class="Bound">x</a><a id="17437" class="Symbol">))</a> <a id="17440" class="Symbol">(</a><a id="17441" href="cubical-prelude.html#12332" data-type="ℕ → Pos" class="Function">ℕ→Pos</a> <a id="17447" class="Symbol">(</a><a id="17448" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17452" href="Lecture9-notes.html#17383" class="Bound">y</a><a id="17453" class="Symbol">))</a>

<a id="ℕ→Bin-+B"></a><a id="17457" href="Lecture9-notes.html#17457" data-type="(x y : ℕ) → ℕ→Bin (x + y) ≡ (ℕ→Bin x +B ℕ→Bin y)" class="Function">ℕ→Bin-+B</a> <a id="17466" class="Symbol">:</a> <a id="17468" class="Symbol">(</a><a id="17469" href="Lecture9-notes.html#17469" class="Bound">x</a> <a id="17471" href="Lecture9-notes.html#17471" class="Bound">y</a> <a id="17473" class="Symbol">:</a> <a id="17475" href="introduction.html#1034" data-type="Set" class="Datatype">ℕ</a><a id="17476" class="Symbol">)</a> <a id="17478" class="Symbol">→</a> <a id="17480" href="cubical-prelude.html#13299" data-type="ℕ → Bin" class="Function">ℕ→Bin</a> <a id="17486" class="Symbol">(</a><a id="17487" href="Lecture9-notes.html#17469" class="Bound">x</a> <a id="17489" href="introduction.html#1782" data-type="ℕ → ℕ → ℕ" class="Function Operator">+</a> <a id="17491" href="Lecture9-notes.html#17471" class="Bound">y</a><a id="17492" class="Symbol">)</a> <a id="17494" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="17496" href="cubical-prelude.html#13299" data-type="ℕ → Bin" class="Function">ℕ→Bin</a> <a id="17502" href="Lecture9-notes.html#17469" class="Bound">x</a> <a id="17504" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="17507" href="cubical-prelude.html#13299" data-type="ℕ → Bin" class="Function">ℕ→Bin</a> <a id="17513" href="Lecture9-notes.html#17471" class="Bound">y</a>
<a id="17515" href="Lecture9-notes.html#17457" data-type="(x y : ℕ) → ℕ→Bin (x + y) ≡ (ℕ→Bin x +B ℕ→Bin y)" class="Function">ℕ→Bin-+B</a> <a id="17524" href="introduction.html#1050" data-type="ℕ" class="InductiveConstructor">zero</a> <a id="17529" href="Lecture9-notes.html#17529" class="Bound">y</a>          <a id="17540" class="Symbol">=</a> <a id="17542" href="Lecture7-notes.html#3585" data-type="x ≡ x" class="Function">refl</a>
<a id="17547" href="Lecture9-notes.html#17457" data-type="(x y : ℕ) → ℕ→Bin (x + y) ≡ (ℕ→Bin x +B ℕ→Bin y)" class="Function">ℕ→Bin-+B</a> <a id="17556" class="Symbol">(</a><a id="17557" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17561" href="Lecture9-notes.html#17561" class="Bound">x</a><a id="17562" class="Symbol">)</a> <a id="17564" href="introduction.html#1050" data-type="ℕ" class="InductiveConstructor">zero</a>    <a id="17572" class="Symbol">=</a> <a id="17574" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="17577" class="Symbol">(λ</a> <a id="17580" href="Lecture9-notes.html#17580" class="Bound">x</a> <a id="17582" class="Symbol">→</a> <a id="17584" href="cubical-prelude.html#13278" data-type="Pos → Bin" class="InductiveConstructor">binPos</a> <a id="17591" class="Symbol">(</a><a id="17592" href="cubical-prelude.html#12332" data-type="ℕ → Pos" class="Function">ℕ→Pos</a> <a id="17598" class="Symbol">(</a><a id="17599" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17603" href="Lecture9-notes.html#17580" class="Bound">x</a><a id="17604" class="Symbol">)))</a> <a id="17608" class="Symbol">(</a><a id="17609" href="cubical-prelude.html#10405" data-type="(m : ℕ) → (m + 0) ≡ m" class="Function">+-zero</a> <a id="17616" href="Lecture9-notes.html#17561" class="Bound">x</a><a id="17617" class="Symbol">)</a>
<a id="17619" href="Lecture9-notes.html#17457" data-type="(x y : ℕ) → ℕ→Bin (x + y) ≡ (ℕ→Bin x +B ℕ→Bin y)" class="Function">ℕ→Bin-+B</a> <a id="17628" class="Symbol">(</a><a id="17629" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17633" href="Lecture9-notes.html#17633" class="Bound">x</a><a id="17634" class="Symbol">)</a> <a id="17636" class="Symbol">(</a><a id="17637" href="introduction.html#1060" data-type="ℕ → ℕ" class="InductiveConstructor">suc</a> <a id="17641" href="Lecture9-notes.html#17641" class="Bound">y</a><a id="17642" class="Symbol">)</a> <a id="17644" class="Symbol">=</a> <a id="17646" href="Lecture7-notes.html#4610" data-type="(f : A → B) → x ≡ y → f x ≡ f y" class="Function">ap</a> <a id="17649" href="cubical-prelude.html#13278" data-type="Pos → Bin" class="InductiveConstructor">binPos</a> <a id="17656" class="Symbol">(</a><a id="17657" href="Lecture9-notes.html#17262" data-type="(x y : ℕ) →
ℕ→Pos (suc x + suc y) ≡ (ℕ→Pos (suc x) +P ℕ→Pos (suc y))" class="Function">ℕ→Pos-+P</a> <a id="17666" href="Lecture9-notes.html#17633" class="Bound">x</a> <a id="17668" href="Lecture9-notes.html#17641" class="Bound">y</a><a id="17669" class="Symbol">)</a>
</pre>
<p>Having done this it’s now straightforward to prove that
<code>_+B_</code> is associative using the fact that <code>_+Bin_</code>
is:</p>
<pre class="Agda"><a id="+B≡+Bin"></a><a id="17796" href="Lecture9-notes.html#17796" data-type="_+B_ ≡ _+Bin_" class="Function">+B≡+Bin</a> <a id="17804" class="Symbol">:</a> <a id="17806" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">_+B_</a> <a id="17811" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="17813" href="Lecture9-notes.html#14975" data-type="Bin → Bin → Bin" class="Function Operator">_+Bin_</a>
<a id="17820" href="Lecture9-notes.html#17796" data-type="_+B_ ≡ _+Bin_" class="Function">+B≡+Bin</a> <a id="17828" href="Lecture9-notes.html#17828" class="Bound">i</a> <a id="17830" href="Lecture9-notes.html#17830" class="Bound">x</a> <a id="17832" href="Lecture9-notes.html#17832" class="Bound">y</a> <a id="17834" class="Symbol">=</a> <a id="17836" href="Lecture9-notes.html#17857" data-type="I → Bin → Bin → (x y : Bin) → (x +B y) ≡ ℕ→Bin (Bin→ℕ x + Bin→ℕ y)" class="Function">goal</a> <a id="17841" href="Lecture9-notes.html#17830" class="Bound">x</a> <a id="17843" href="Lecture9-notes.html#17832" class="Bound">y</a> <a id="17845" href="Lecture9-notes.html#17828" class="Bound">i</a>
  <a id="17849" class="Keyword">where</a>
  <a id="17857" href="Lecture9-notes.html#17857" data-type="I → Bin → Bin → (x y : Bin) → (x +B y) ≡ ℕ→Bin (Bin→ℕ x + Bin→ℕ y)" class="Function">goal</a> <a id="17862" class="Symbol">:</a> <a id="17864" class="Symbol">(</a><a id="17865" href="Lecture9-notes.html#17865" class="Bound">x</a> <a id="17867" href="Lecture9-notes.html#17867" class="Bound">y</a> <a id="17869" class="Symbol">:</a> <a id="17871" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a><a id="17874" class="Symbol">)</a> <a id="17876" class="Symbol">→</a> <a id="17878" href="Lecture9-notes.html#17865" class="Bound">x</a> <a id="17880" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="17883" href="Lecture9-notes.html#17867" class="Bound">y</a> <a id="17885" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="17887" href="cubical-prelude.html#13299" data-type="ℕ → Bin" class="Function">ℕ→Bin</a> <a id="17893" class="Symbol">(</a><a id="17894" href="cubical-prelude.html#13378" data-type="Bin → ℕ" class="Function">Bin→ℕ</a> <a id="17900" href="Lecture9-notes.html#17865" class="Bound">x</a> <a id="17902" href="introduction.html#1782" data-type="ℕ → ℕ → ℕ" class="Function Operator">+</a> <a id="17904" href="cubical-prelude.html#13378" data-type="Bin → ℕ" class="Function">Bin→ℕ</a> <a id="17910" href="Lecture9-notes.html#17867" class="Bound">y</a><a id="17911" class="Symbol">)</a>
  <a id="17915" href="Lecture9-notes.html#17857" data-type="I → Bin → Bin → (x y : Bin) → (x +B y) ≡ ℕ→Bin (Bin→ℕ x + Bin→ℕ y)" class="Function">goal</a> <a id="17920" href="Lecture9-notes.html#17920" class="Bound">x</a> <a id="17922" href="Lecture9-notes.html#17922" class="Bound">y</a> <a id="17924" class="Symbol">=</a>  <a id="17927" class="Symbol">(λ</a> <a id="17930" href="Lecture9-notes.html#17930" class="Bound">i</a> <a id="17932" class="Symbol">→</a> <a id="17934" href="cubical-prelude.html#13740" data-type="(n : Bin) → ℕ→Bin (Bin→ℕ n) ≡ n" class="Function">Bin→ℕ→Bin</a> <a id="17944" href="Lecture9-notes.html#17920" class="Bound">x</a> <a id="17946" class="Symbol">(</a><a id="17947" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="17949" href="Lecture9-notes.html#17930" class="Bound">i</a><a id="17950" class="Symbol">)</a> <a id="17952" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="17955" href="cubical-prelude.html#13740" data-type="(n : Bin) → ℕ→Bin (Bin→ℕ n) ≡ n" class="Function">Bin→ℕ→Bin</a> <a id="17965" href="Lecture9-notes.html#17922" class="Bound">y</a> <a id="17967" class="Symbol">(</a><a id="17968" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="17970" href="Lecture9-notes.html#17930" class="Bound">i</a><a id="17971" class="Symbol">))</a>
           <a id="17985" href="cubical-prelude.html#2538" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a>  <a id="17988" href="Lecture7-notes.html#6920" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="17992" class="Symbol">(</a><a id="17993" href="Lecture9-notes.html#17457" data-type="(x y : ℕ) → ℕ→Bin (x + y) ≡ (ℕ→Bin x +B ℕ→Bin y)" class="Function">ℕ→Bin-+B</a> <a id="18002" class="Symbol">(</a><a id="18003" href="cubical-prelude.html#13378" data-type="Bin → ℕ" class="Function">Bin→ℕ</a> <a id="18009" href="Lecture9-notes.html#17920" class="Bound">x</a><a id="18010" class="Symbol">)</a> <a id="18012" class="Symbol">(</a><a id="18013" href="cubical-prelude.html#13378" data-type="Bin → ℕ" class="Function">Bin→ℕ</a> <a id="18019" href="Lecture9-notes.html#17922" class="Bound">y</a><a id="18020" class="Symbol">))</a>

<a id="+B-assoc"></a><a id="18024" href="Lecture9-notes.html#18024" data-type="(m n o : Bin) → (m +B (n +B o)) ≡ ((m +B n) +B o)" class="Function">+B-assoc</a> <a id="18033" class="Symbol">:</a> <a id="18035" class="Symbol">(</a><a id="18036" href="Lecture9-notes.html#18036" class="Bound">m</a> <a id="18038" href="Lecture9-notes.html#18038" class="Bound">n</a> <a id="18040" href="Lecture9-notes.html#18040" class="Bound">o</a> <a id="18042" class="Symbol">:</a> <a id="18044" href="cubical-prelude.html#13243" data-type="Set" class="Datatype">Bin</a><a id="18047" class="Symbol">)</a> <a id="18049" class="Symbol">→</a> <a id="18051" href="Lecture9-notes.html#18036" class="Bound">m</a> <a id="18053" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="18056" class="Symbol">(</a><a id="18057" href="Lecture9-notes.html#18038" class="Bound">n</a> <a id="18059" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="18062" href="Lecture9-notes.html#18040" class="Bound">o</a><a id="18063" class="Symbol">)</a> <a id="18065" href="Agda.Builtin.Cubical.Path.html#388" data-type="A → A → Set ℓ" class="Function Operator">≡</a> <a id="18067" class="Symbol">(</a><a id="18068" href="Lecture9-notes.html#18036" class="Bound">m</a> <a id="18070" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="18073" href="Lecture9-notes.html#18038" class="Bound">n</a><a id="18074" class="Symbol">)</a> <a id="18076" href="Lecture9-notes.html#16029" data-type="Bin → Bin → Bin" class="Function Operator">+B</a> <a id="18079" href="Lecture9-notes.html#18040" class="Bound">o</a>
<a id="18081" href="Lecture9-notes.html#18024" data-type="(m n o : Bin) → (m +B (n +B o)) ≡ ((m +B n) +B o)" class="Function">+B-assoc</a> <a id="18090" href="Lecture9-notes.html#18090" class="Bound">m</a> <a id="18092" href="Lecture9-notes.html#18092" class="Bound">n</a> <a id="18094" href="Lecture9-notes.html#18094" class="Bound">o</a> <a id="18096" class="Symbol">=</a>
           <a id="18109" class="Symbol">(λ</a> <a id="18112" href="Lecture9-notes.html#18112" class="Bound">i</a> <a id="18114" class="Symbol">→</a> <a id="18116" href="Lecture9-notes.html#17796" data-type="_+B_ ≡ _+Bin_" class="Function">+B≡+Bin</a> <a id="18124" href="Lecture9-notes.html#18112" class="Bound">i</a> <a id="18126" href="Lecture9-notes.html#18090" class="Bound">m</a> <a id="18128" class="Symbol">(</a><a id="18129" href="Lecture9-notes.html#17796" data-type="_+B_ ≡ _+Bin_" class="Function">+B≡+Bin</a> <a id="18137" href="Lecture9-notes.html#18112" class="Bound">i</a> <a id="18139" href="Lecture9-notes.html#18092" class="Bound">n</a> <a id="18141" href="Lecture9-notes.html#18094" class="Bound">o</a><a id="18142" class="Symbol">))</a>
               <a id="18160" href="Lecture9-notes.html#1907" data-type="x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function Operator">∙∙</a> <a id="18163" href="Lecture9-notes.html#15028" data-type="(m n o : Bin) → (m +Bin (n +Bin o)) ≡ ((m +Bin n) +Bin o)" class="Function">+Bin-assoc</a> <a id="18174" href="Lecture9-notes.html#18090" class="Bound">m</a> <a id="18176" href="Lecture9-notes.html#18092" class="Bound">n</a> <a id="18178" href="Lecture9-notes.html#18094" class="Bound">o</a>
               <a id="18195" href="Lecture9-notes.html#1907" data-type="x ≡ y → y ≡ z → z ≡ w → x ≡ w" class="Function Operator">∙∙</a> <a id="18198" class="Symbol">(λ</a> <a id="18201" href="Lecture9-notes.html#18201" class="Bound">i</a> <a id="18203" class="Symbol">→</a> <a id="18205" href="Lecture9-notes.html#17796" data-type="_+B_ ≡ _+Bin_" class="Function">+B≡+Bin</a> <a id="18213" class="Symbol">(</a><a id="18214" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="18216" href="Lecture9-notes.html#18201" class="Bound">i</a><a id="18217" class="Symbol">)</a> <a id="18219" class="Symbol">(</a><a id="18220" href="Lecture9-notes.html#17796" data-type="_+B_ ≡ _+Bin_" class="Function">+B≡+Bin</a> <a id="18228" class="Symbol">(</a><a id="18229" href="cubical-prelude.html#547" class="Primitive Operator">~</a> <a id="18231" href="Lecture9-notes.html#18201" class="Bound">i</a><a id="18232" class="Symbol">)</a> <a id="18234" href="Lecture9-notes.html#18090" class="Bound">m</a> <a id="18236" href="Lecture9-notes.html#18092" class="Bound">n</a><a id="18237" class="Symbol">)</a> <a id="18239" href="Lecture9-notes.html#18094" class="Bound">o</a><a id="18240" class="Symbol">)</a>
</pre>
<p>This kind of proofs quickly get tedious and it turns out we can
streamline them using a more high prowered version of the SIP. Indeed,
what we really want to do is to characterize the equality of
T-structured types, i.e. we want a proof that two types equipped with
T-structures are equal if there is a T-structure preserving equivalence
between them. In the semigroup example above <code>T</code> would just
be the structure of a magma (i.e. a type with a binary operation)
together with magma preserving equivalence so that we can transport for
example the fact that the magma is a semigroup over to the other
magma.</p>
<p>We formalize this and make it more convenient to use using a lot of
automation in the agda/cubical library. This is documented with various
more examples in:</p>
<p>Internalizing Representation Independence with Univalence Carlo
Angiuli, Evan Cavallo, Anders Mörtberg, Max Zeuner
https://dl.acm.org/doi/10.1145/3434293</p>
<p>The binary numbers example with efficient addition is spelled out in
detail in Section 2.1.1 of:</p>
<p>https://www.doi.org/10.1017/S0956796821000034 (Can be downloaded
from:
https://staff.math.su.se/anders.mortberg/papers/cubicalagda2.pdf)</p>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em;
    border: 1px solid black; }
  table th {
    border-bottom: 2px solid black; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
