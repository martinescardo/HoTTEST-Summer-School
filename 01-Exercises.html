<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <article>

<h1 id="week-01---agda-exercises">Week 01 - Agda Exercises</h1>
<h2 id="please-read-before-starting-the-exercises">Please read before
starting the exercises</h2>
<p><strong>The exercises are designed to increase in difficulty so that
we can cater to our large and diverse audience. This also means that it
is <em>perfectly fine</em> if you don’t manage to do all exercises: some
of them are definitely a bit hard for beginners and there are likely too
many exercises! You <em>may</em> wish to come back to them later when
you have learned more.</strong></p>
<p>Having said that, here we go!</p>
<p>This is a markdown file with Agda code, which means that it displays
nicely on GitHub, but at the same time you can load this file in Agda
and fill the holes to solve exercises.</p>
<p><strong>Please make a copy of this file to work in, so that it
doesn’t get overwritten (in case we update the exercises through
<code>git</code>)!</strong></p>
<pre class="Agda"><a id="791" class="Symbol">{-#</a> <a id="795" class="Keyword">OPTIONS</a> <a id="803" class="Pragma">--without-K</a> <a id="815" class="Pragma">--allow-unsolved-metas</a> <a id="838" class="Symbol">#-}</a>

<a id="843" class="Keyword">module</a> <a id="850" href="01-Exercises.html" class="Module">01-Exercises</a> <a id="863" class="Keyword">where</a>

<a id="870" class="Keyword">open</a> <a id="875" class="Keyword">import</a> <a id="882" href="prelude.html" class="Module">prelude</a> <a id="890" class="Keyword">hiding</a> <a id="897" class="Symbol">(</a><a id="898" href="Bool.html#5962" data-type="Bool.is-involution Bool.not" class="Function">not-is-involution</a><a id="915" class="Symbol">)</a>
</pre>
<h2
id="part-i-writing-functions-on-booleans-natural-numbers-and-lists">Part
I: Writing functions on Booleans, natural numbers and lists (★/★★)</h2>
<h3 id="exercise-1">Exercise 1 (★)</h3>
<p>In the lectures we defined <code>&amp;&amp;</code> (logical and) on
<code>Bool</code> by pattern matching on the leftmost argument only.</p>
<p><em>NB</em>: We didn’t get round to doing this in the lecture, but
see <code>_&amp;&amp;_</code> in <a
href="introduction.html">introduction.lagda.md</a>.</p>
<p><strong>Define</strong> the same operation but this time by pattern
matching (case splitting) on both arguments.</p>
<pre class="Agda"><a id="_&amp;&amp;&#39;_"></a><a id="1389" href="01-Exercises.html#1389" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">_&amp;&amp;&#39;_</a> <a id="1395" class="Symbol">:</a> <a id="1397" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a> <a id="1402" class="Symbol">→</a> <a id="1404" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a> <a id="1409" class="Symbol">→</a> <a id="1411" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a>
<a id="1416" href="01-Exercises.html#1416" class="Bound">a</a> <a id="1418" href="01-Exercises.html#1389" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;&#39;</a> <a id="1422" href="01-Exercises.html#1422" class="Bound">b</a> <a id="1424" class="Symbol">=</a> <a id="1426" class="Hole">{!!}</a>
</pre>
<p>One advantage of this definition is that it reads just like a Boolean
truth table. Later on in this exercise sheet, we will see a
disadvantange of this more verbose definition.</p>
<h3 id="exercise-2">Exercise 2 (★)</h3>
<p><strong>Define</strong> <code>xor</code> (excluse or) on
<code>Bool</code>. Exclusive or is true if and only if <em>exactly
one</em> of its arguments is true.</p>
<pre class="Agda"><a id="_xor_"></a><a id="1760" href="01-Exercises.html#1760" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">_xor_</a> <a id="1766" class="Symbol">:</a> <a id="1768" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a> <a id="1773" class="Symbol">→</a> <a id="1775" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a> <a id="1780" class="Symbol">→</a> <a id="1782" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a>
<a id="1787" href="01-Exercises.html#1787" class="Bound">a</a> <a id="1789" href="01-Exercises.html#1760" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">xor</a> <a id="1793" href="01-Exercises.html#1793" class="Bound">b</a> <a id="1795" class="Symbol">=</a> <a id="1797" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-3">Exercise 3 (★)</h3>
<p><strong>Define</strong> the exponential and factorial functions on
natural numbers.</p>
<p>If you do things correctly, then the examples should compute
correctly, i.e. the proof that 3 ^ 4 ≡ 81 should simply be given by
<code>refl _</code> which says that the left hand side and the right
hand side compute to the same value.</p>
<pre class="Agda"><a id="_^_"></a><a id="2132" href="01-Exercises.html#2132" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function Operator">_^_</a> <a id="2136" class="Symbol">:</a> <a id="2138" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="2140" class="Symbol">→</a> <a id="2142" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="2144" class="Symbol">→</a> <a id="2146" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a>
<a id="2148" href="01-Exercises.html#2148" class="Bound">n</a> <a id="2150" href="01-Exercises.html#2132" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function Operator">^</a> <a id="2152" href="01-Exercises.html#2152" class="Bound">m</a> <a id="2154" class="Symbol">=</a> <a id="2156" class="Hole">{!!}</a>

<a id="^-example"></a><a id="2162" href="01-Exercises.html#2162" data-type="(3 01-Exercises.^ 4) identity-type.≡ 81" class="Function">^-example</a> <a id="2172" class="Symbol">:</a> <a id="2174" class="Number">3</a> <a id="2176" href="01-Exercises.html#2132" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function Operator">^</a> <a id="2178" class="Number">4</a> <a id="2180" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="2182" class="Number">81</a>
<a id="2185" href="01-Exercises.html#2162" data-type="(3 01-Exercises.^ 4) identity-type.≡ 81" class="Function">^-example</a> <a id="2195" class="Symbol">=</a> <a id="2197" class="Hole">{!!}</a> <a id="2202" class="Comment">-- refl 81 should fill the hole here</a>

<a id="_!"></a><a id="2240" href="01-Exercises.html#2240" data-type="Fin.ℕ → Fin.ℕ" class="Function Operator">_!</a> <a id="2243" class="Symbol">:</a> <a id="2245" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="2247" class="Symbol">→</a> <a id="2249" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a>
<a id="2251" href="01-Exercises.html#2251" class="Bound">n</a> <a id="2253" href="01-Exercises.html#2240" data-type="Fin.ℕ → Fin.ℕ" class="Function Operator">!</a> <a id="2255" class="Symbol">=</a> <a id="2257" class="Hole">{!!}</a>

<a id="!-example"></a><a id="2263" href="01-Exercises.html#2263" data-type="(4 01-Exercises.!) identity-type.≡ 24" class="Function">!-example</a> <a id="2273" class="Symbol">:</a> <a id="2275" class="Number">4</a> <a id="2277" href="01-Exercises.html#2240" data-type="Fin.ℕ → Fin.ℕ" class="Function Operator">!</a> <a id="2279" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="2281" class="Number">24</a>
<a id="2284" href="01-Exercises.html#2263" data-type="(4 01-Exercises.!) identity-type.≡ 24" class="Function">!-example</a> <a id="2294" class="Symbol">=</a> <a id="2296" class="Hole">{!!}</a> <a id="2301" class="Comment">-- refl 24 should fill the hole here</a>
</pre>
<h3 id="exercise-4">Exercise 4 (★)</h3>
We can recursively compute the maximum of two natural numbers as
follows.
<pre class="Agda"><a id="max"></a><a id="2445" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="2449" class="Symbol">:</a> <a id="2451" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="2453" class="Symbol">→</a> <a id="2455" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="2457" class="Symbol">→</a> <a id="2459" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a>
<a id="2461" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="2465" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a>    <a id="2473" href="01-Exercises.html#2473" class="Bound">m</a>       <a id="2481" class="Symbol">=</a> <a id="2483" href="01-Exercises.html#2473" class="Bound">m</a>
<a id="2485" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="2489" class="Symbol">(</a><a id="2490" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="2494" href="01-Exercises.html#2494" class="Bound">n</a><a id="2495" class="Symbol">)</a> <a id="2497" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a>    <a id="2505" class="Symbol">=</a> <a id="2507" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="2511" href="01-Exercises.html#2494" class="Bound">n</a>
<a id="2513" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="2517" class="Symbol">(</a><a id="2518" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="2522" href="01-Exercises.html#2522" class="Bound">n</a><a id="2523" class="Symbol">)</a> <a id="2525" class="Symbol">(</a><a id="2526" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="2530" href="01-Exercises.html#2530" class="Bound">m</a><a id="2531" class="Symbol">)</a> <a id="2533" class="Symbol">=</a> <a id="2535" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="2539" class="Symbol">(</a><a id="2540" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="2544" href="01-Exercises.html#2522" class="Bound">n</a> <a id="2546" href="01-Exercises.html#2530" class="Bound">m</a><a id="2547" class="Symbol">)</a>
</pre>
<p><strong>Define</strong> the minimum of two natural numbers
analogously.</p>
<pre class="Agda"><a id="min"></a><a id="2622" href="01-Exercises.html#2622" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">min</a> <a id="2626" class="Symbol">:</a> <a id="2628" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="2630" class="Symbol">→</a> <a id="2632" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="2634" class="Symbol">→</a> <a id="2636" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a>
<a id="2638" href="01-Exercises.html#2622" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">min</a> <a id="2642" class="Symbol">=</a> <a id="2644" class="Hole">{!!}</a>

<a id="min-example"></a><a id="2650" href="01-Exercises.html#2650" data-type="01-Exercises.min 5 3 identity-type.≡ 3" class="Function">min-example</a> <a id="2662" class="Symbol">:</a> <a id="2664" href="01-Exercises.html#2622" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">min</a> <a id="2668" class="Number">5</a> <a id="2670" class="Number">3</a> <a id="2672" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="2674" class="Number">3</a>
<a id="2676" href="01-Exercises.html#2650" data-type="01-Exercises.min 5 3 identity-type.≡ 3" class="Function">min-example</a> <a id="2688" class="Symbol">=</a> <a id="2690" class="Hole">{!!}</a> <a id="2695" class="Comment">-- refl 3 should fill the hole here</a>
</pre>
<h3 id="exercise-5">Exercise 5 (★)</h3>
<p>Use pattern matching on lists to <strong>define</strong>
<code>map</code>.</p>
<p>This function should behave as follows:
<code>map f [x₁ , x₂ , ... , xₙ] = [f x₁ , f x₂ , ... , f xₙ]</code>.
That is, <code>map f xs</code> applies the given function <code>f</code>
to every element of the list <code>xs</code> and returns the resulting
list.</p>
<pre class="Agda"><a id="map"></a><a id="3033" href="01-Exercises.html#3033" data-type="(X → Y) → List.List X → List.List Y" class="Function">map</a> <a id="3037" class="Symbol">:</a> <a id="3039" class="Symbol">{</a><a id="3040" href="01-Exercises.html#3040" class="Bound">X</a> <a id="3042" href="01-Exercises.html#3042" class="Bound">Y</a> <a id="3044" class="Symbol">:</a> <a id="3046" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="3050" class="Symbol">}</a> <a id="3052" class="Symbol">→</a> <a id="3054" class="Symbol">(</a><a id="3055" href="01-Exercises.html#3040" class="Bound">X</a> <a id="3057" class="Symbol">→</a> <a id="3059" href="01-Exercises.html#3042" class="Bound">Y</a><a id="3060" class="Symbol">)</a> <a id="3062" class="Symbol">→</a> <a id="3064" href="List.html#402" data-type="general-notation.Type → Set" class="Datatype">List</a> <a id="3069" href="01-Exercises.html#3040" class="Bound">X</a> <a id="3071" class="Symbol">→</a> <a id="3073" href="List.html#402" data-type="general-notation.Type → Set" class="Datatype">List</a> <a id="3078" href="01-Exercises.html#3042" class="Bound">Y</a>
<a id="3080" href="01-Exercises.html#3033" data-type="(X → Y) → List.List X → List.List Y" class="Function">map</a> <a id="3084" href="01-Exercises.html#3084" class="Bound">f</a> <a id="3086" href="01-Exercises.html#3086" class="Bound">xs</a> <a id="3089" class="Symbol">=</a> <a id="3091" class="Hole">{!!}</a>

<a id="map-example"></a><a id="3097" href="01-Exercises.html#3097" data-type="01-Exercises.map (Fin._+ 3) (1 List.:: 2 List.:: 3 List.:: List.[])
identity-type.≡ 4 List.:: 5 List.:: 6 List.:: List.[]" class="Function">map-example</a> <a id="3109" class="Symbol">:</a> <a id="3111" href="01-Exercises.html#3033" data-type="(X → Y) → List.List X → List.List Y" class="Function">map</a> <a id="3115" class="Symbol">(</a><a id="3116" href="natural-numbers-type.html#2879" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function Operator">_+</a> <a id="3119" class="Number">3</a><a id="3120" class="Symbol">)</a> <a id="3122" class="Symbol">(</a><a id="3123" class="Number">1</a> <a id="3125" class="InductiveConstructor Operator">::</a> <a id="3128" class="Number">2</a> <a id="3130" class="InductiveConstructor Operator">::</a> <a id="3133" class="Number">3</a> <a id="3135" class="InductiveConstructor Operator">::</a> <a id="3138" class="InductiveConstructor">[]</a><a id="3140" class="Symbol">)</a> <a id="3142" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3144" class="Number">4</a> <a id="3146" class="InductiveConstructor Operator">::</a> <a id="3149" class="Number">5</a> <a id="3151" class="InductiveConstructor Operator">::</a> <a id="3154" class="Number">6</a> <a id="3156" class="InductiveConstructor Operator">::</a> <a id="3159" class="InductiveConstructor">[]</a>
<a id="3162" href="01-Exercises.html#3097" data-type="01-Exercises.map (Fin._+ 3) (1 List.:: 2 List.:: 3 List.:: List.[])
identity-type.≡ 4 List.:: 5 List.:: 6 List.:: List.[]" class="Function">map-example</a> <a id="3174" class="Symbol">=</a> <a id="3176" class="Hole">{!!}</a> <a id="3181" class="Comment">-- refl _ should fill the hole here</a>

                   <a id="3237" class="Comment">-- We write the underscore, because we don&#39;t wish to repeat</a>
                   <a id="3316" class="Comment">-- the relatively long &quot;4 :: 5 :: 6 :: []&quot; and Agda can</a>
                   <a id="3391" class="Comment">-- figure out what is supposed to go there.</a>
</pre>
<h3 id="exercise-6">Exercise 6 (★★)</h3>
<p><strong>Define</strong> a function <code>filter</code> that takes
predicate <code>p : X → Bool</code> and a list <code>xs</code> that
returns the list of elements of <code>xs</code> for which <code>p</code>
is true.</p>
<p>For example, filtering the non-zero elements of the list [4 , 3 , 0 ,
1 , 0] should return [4 , 3 , 1], see the code below.</p>
<pre class="Agda"><a id="filter"></a><a id="3745" href="01-Exercises.html#3745" data-type="(X → Bool.Bool) → List.List X → List.List X" class="Function">filter</a> <a id="3752" class="Symbol">:</a> <a id="3754" class="Symbol">{</a><a id="3755" href="01-Exercises.html#3755" class="Bound">X</a> <a id="3757" class="Symbol">:</a> <a id="3759" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="3763" class="Symbol">}</a> <a id="3765" class="Symbol">(</a><a id="3766" href="01-Exercises.html#3766" class="Bound">p</a> <a id="3768" class="Symbol">:</a> <a id="3770" href="01-Exercises.html#3755" class="Bound">X</a> <a id="3772" class="Symbol">→</a> <a id="3774" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a><a id="3778" class="Symbol">)</a> <a id="3780" class="Symbol">→</a> <a id="3782" href="List.html#402" data-type="general-notation.Type → Set" class="Datatype">List</a> <a id="3787" href="01-Exercises.html#3755" class="Bound">X</a> <a id="3789" class="Symbol">→</a> <a id="3791" href="List.html#402" data-type="general-notation.Type → Set" class="Datatype">List</a> <a id="3796" href="01-Exercises.html#3755" class="Bound">X</a>
<a id="3798" href="01-Exercises.html#3745" data-type="(X → Bool.Bool) → List.List X → List.List X" class="Function">filter</a> <a id="3805" class="Symbol">=</a> <a id="3807" class="Hole">{!!}</a>

<a id="is-non-zero"></a><a id="3813" href="01-Exercises.html#3813" data-type="Fin.ℕ → Bool.Bool" class="Function">is-non-zero</a> <a id="3825" class="Symbol">:</a> <a id="3827" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a> <a id="3829" class="Symbol">→</a> <a id="3831" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a>
<a id="3836" href="01-Exercises.html#3813" data-type="Fin.ℕ → Bool.Bool" class="Function">is-non-zero</a> <a id="3848" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a>    <a id="3856" class="Symbol">=</a> <a id="3858" href="Bool.html#516" data-type="Bool.Bool" class="InductiveConstructor">false</a>
<a id="3864" href="01-Exercises.html#3813" data-type="Fin.ℕ → Bool.Bool" class="Function">is-non-zero</a> <a id="3876" class="Symbol">(</a><a id="3877" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="3881" class="Symbol">_)</a> <a id="3884" class="Symbol">=</a> <a id="3886" href="Bool.html#511" data-type="Bool.Bool" class="InductiveConstructor">true</a>

<a id="filter-example"></a><a id="3892" href="01-Exercises.html#3892" data-type="01-Exercises.filter 01-Exercises.is-non-zero
(4 List.:: 3 List.:: 0 List.:: 1 List.:: 0 List.:: List.[])
identity-type.≡ 4 List.:: 3 List.:: 1 List.:: List.[]" class="Function">filter-example</a> <a id="3907" class="Symbol">:</a> <a id="3909" href="01-Exercises.html#3745" data-type="(X → Bool.Bool) → List.List X → List.List X" class="Function">filter</a> <a id="3916" href="01-Exercises.html#3813" data-type="Fin.ℕ → Bool.Bool" class="Function">is-non-zero</a> <a id="3928" class="Symbol">(</a><a id="3929" class="Number">4</a> <a id="3931" class="InductiveConstructor Operator">::</a> <a id="3934" class="Number">3</a> <a id="3936" class="InductiveConstructor Operator">::</a> <a id="3939" class="Number">0</a> <a id="3941" class="InductiveConstructor Operator">::</a> <a id="3944" class="Number">1</a> <a id="3946" class="InductiveConstructor Operator">::</a> <a id="3949" class="Number">0</a> <a id="3951" class="InductiveConstructor Operator">::</a> <a id="3954" class="InductiveConstructor">[]</a><a id="3956" class="Symbol">)</a> <a id="3958" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="3960" class="Number">4</a> <a id="3962" class="InductiveConstructor Operator">::</a> <a id="3965" class="Number">3</a> <a id="3967" class="InductiveConstructor Operator">::</a> <a id="3970" class="Number">1</a> <a id="3972" class="InductiveConstructor Operator">::</a> <a id="3975" class="InductiveConstructor">[]</a>
<a id="3978" href="01-Exercises.html#3892" data-type="01-Exercises.filter 01-Exercises.is-non-zero
(4 List.:: 3 List.:: 0 List.:: 1 List.:: 0 List.:: List.[])
identity-type.≡ 4 List.:: 3 List.:: 1 List.:: List.[]" class="Function">filter-example</a> <a id="3993" class="Symbol">=</a> <a id="3995" class="Hole">{!!}</a> <a id="4000" class="Comment">-- refl _ should fill the hole here</a>
</pre>
<h2 id="part-ii-the-identity-type-of-the-booleans">Part II: The identity
type of the Booleans (★/★★)</h2>
<p>In the lectures we saw a definition of <code>≣</code> on natural
numbers where the idea was that <code>x ≣ y</code> is a type which
either has precisely one element, if <code>x</code> and <code>y</code>
are the same natural number, or else is empty, if <code>x</code> and
<code>y</code> are different.</p>
<h3 id="exercise-1-1">Exercise 1 (★)</h3>
<p><strong>Define</strong> <code>≣</code> for Booleans this time.</p>
<pre class="Agda"><a id="_≣_"></a><a id="4400" href="01-Exercises.html#4400" data-type="Bool.Bool → Bool.Bool → general-notation.Type" class="Function Operator">_≣_</a> <a id="4404" class="Symbol">:</a> <a id="4406" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a> <a id="4411" class="Symbol">→</a> <a id="4413" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a> <a id="4418" class="Symbol">→</a> <a id="4420" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a>
<a id="4425" href="01-Exercises.html#4425" class="Bound">a</a> <a id="4427" href="01-Exercises.html#4400" data-type="Bool.Bool → Bool.Bool → general-notation.Type" class="Function Operator">≣</a> <a id="4429" href="01-Exercises.html#4429" class="Bound">b</a> <a id="4431" class="Symbol">=</a> <a id="4433" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-2-1">Exercise 2 (★)</h3>
<p><strong>Show</strong> that for every Boolean <code>b</code> we can
find an element of the type <code>b ≣ b</code>.</p>
<pre class="Agda"><a id="Bool-refl"></a><a id="4552" href="01-Exercises.html#4552" data-type="(b : Bool.Bool) → b 01-Exercises.≣ b" class="Function">Bool-refl</a> <a id="4562" class="Symbol">:</a> <a id="4564" class="Symbol">(</a><a id="4565" href="01-Exercises.html#4565" class="Bound">b</a> <a id="4567" class="Symbol">:</a> <a id="4569" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a><a id="4573" class="Symbol">)</a> <a id="4575" class="Symbol">→</a> <a id="4577" href="01-Exercises.html#4565" class="Bound">b</a> <a id="4579" href="01-Exercises.html#4400" data-type="Bool.Bool → Bool.Bool → general-notation.Type" class="Function Operator">≣</a> <a id="4581" href="01-Exercises.html#4565" class="Bound">b</a>
<a id="4583" href="01-Exercises.html#4552" data-type="(b : Bool.Bool) → b 01-Exercises.≣ b" class="Function">Bool-refl</a> <a id="4593" class="Symbol">=</a> <a id="4595" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-3-1">Exercise 3 (★★)</h3>
<p>Just like we did in the lectures for natural numbers,
<strong>show</strong> that we can go back and forth between
<code>a ≣ b</code> and <code>a ≡ b</code>.</p>
<p><em>NB</em>: Again, we didn’t have time to do this in the lectures,
but see <a href="introduction.html">introduction.lagda.md</a>,
specifically the functions <code>back</code> and <code>forth</code>
there.</p>
<pre class="Agda"><a id="≡-to-≣"></a><a id="4963" href="01-Exercises.html#4963" data-type="(a b : Bool.Bool) → a identity-type.≡ b → a 01-Exercises.≣ b" class="Function">≡-to-≣</a> <a id="4970" class="Symbol">:</a> <a id="4972" class="Symbol">(</a><a id="4973" href="01-Exercises.html#4973" class="Bound">a</a> <a id="4975" href="01-Exercises.html#4975" class="Bound">b</a> <a id="4977" class="Symbol">:</a> <a id="4979" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a><a id="4983" class="Symbol">)</a> <a id="4985" class="Symbol">→</a> <a id="4987" href="01-Exercises.html#4973" class="Bound">a</a> <a id="4989" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="4991" href="01-Exercises.html#4975" class="Bound">b</a> <a id="4993" class="Symbol">→</a> <a id="4995" href="01-Exercises.html#4973" class="Bound">a</a> <a id="4997" href="01-Exercises.html#4400" data-type="Bool.Bool → Bool.Bool → general-notation.Type" class="Function Operator">≣</a> <a id="4999" href="01-Exercises.html#4975" class="Bound">b</a>
<a id="5001" href="01-Exercises.html#4963" data-type="(a b : Bool.Bool) → a identity-type.≡ b → a 01-Exercises.≣ b" class="Function">≡-to-≣</a> <a id="5008" class="Symbol">=</a> <a id="5010" class="Hole">{!!}</a>

<a id="≣-to-≡"></a><a id="5016" href="01-Exercises.html#5016" data-type="(a b : Bool.Bool) → a 01-Exercises.≣ b → a identity-type.≡ b" class="Function">≣-to-≡</a> <a id="5023" class="Symbol">:</a> <a id="5025" class="Symbol">(</a><a id="5026" href="01-Exercises.html#5026" class="Bound">a</a> <a id="5028" href="01-Exercises.html#5028" class="Bound">b</a> <a id="5030" class="Symbol">:</a> <a id="5032" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a><a id="5036" class="Symbol">)</a> <a id="5038" class="Symbol">→</a> <a id="5040" href="01-Exercises.html#5026" class="Bound">a</a> <a id="5042" href="01-Exercises.html#4400" data-type="Bool.Bool → Bool.Bool → general-notation.Type" class="Function Operator">≣</a> <a id="5044" href="01-Exercises.html#5028" class="Bound">b</a> <a id="5046" class="Symbol">→</a> <a id="5048" href="01-Exercises.html#5026" class="Bound">a</a> <a id="5050" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="5052" href="01-Exercises.html#5028" class="Bound">b</a>
<a id="5054" href="01-Exercises.html#5016" data-type="(a b : Bool.Bool) → a 01-Exercises.≣ b → a identity-type.≡ b" class="Function">≣-to-≡</a> <a id="5061" class="Symbol">=</a> <a id="5063" class="Hole">{!!}</a>
</pre>
<h2 id="part-iii-proving-in-agda">Part III: Proving in Agda
(★★/★★★)</h2>
<p>We now turn to <em>proving</em> things in Agda: one of its key
features.</p>
<p>For example, here is a proof that <code>not (not b) ≡ b</code> for
every Boolean <code>b</code>.</p>
<pre class="Agda"><a id="not-is-involution"></a><a id="5263" href="01-Exercises.html#5263" data-type="(b : Bool.Bool) → Bool.not (Bool.not b) identity-type.≡ b" class="Function">not-is-involution</a> <a id="5281" class="Symbol">:</a> <a id="5283" class="Symbol">(</a><a id="5284" href="01-Exercises.html#5284" class="Bound">b</a> <a id="5286" class="Symbol">:</a> <a id="5288" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a><a id="5292" class="Symbol">)</a> <a id="5294" class="Symbol">→</a> <a id="5296" href="Bool.html#4051" data-type="Bool.Bool → Bool.Bool" class="Function">not</a> <a id="5300" class="Symbol">(</a><a id="5301" href="Bool.html#4051" data-type="Bool.Bool → Bool.Bool" class="Function">not</a> <a id="5305" href="01-Exercises.html#5284" class="Bound">b</a><a id="5306" class="Symbol">)</a> <a id="5308" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="5310" href="01-Exercises.html#5284" class="Bound">b</a>
<a id="5312" href="01-Exercises.html#5263" data-type="(b : Bool.Bool) → Bool.not (Bool.not b) identity-type.≡ b" class="Function">not-is-involution</a> <a id="5330" href="Bool.html#511" data-type="Bool.Bool" class="InductiveConstructor">true</a>  <a id="5336" class="Symbol">=</a> <a id="5338" href="identity-type.html#664" data-type="(x : A) → x identity-type.≡ x" class="InductiveConstructor">refl</a> <a id="5343" href="Bool.html#511" data-type="Bool.Bool" class="InductiveConstructor">true</a>
<a id="5348" href="01-Exercises.html#5263" data-type="(b : Bool.Bool) → Bool.not (Bool.not b) identity-type.≡ b" class="Function">not-is-involution</a> <a id="5366" href="Bool.html#516" data-type="Bool.Bool" class="InductiveConstructor">false</a> <a id="5372" class="Symbol">=</a> <a id="5374" href="identity-type.html#664" data-type="(x : A) → x identity-type.≡ x" class="InductiveConstructor">refl</a> <a id="5379" href="Bool.html#516" data-type="Bool.Bool" class="InductiveConstructor">false</a>
</pre>
<h3 id="exercise-1-2">Exercise 1 (★★)</h3>
<p>Use pattern matching to <strong>prove</strong> that <code>||</code>
is commutative.</p>
<pre class="Agda"><a id="||-is-commutative"></a><a id="5480" href="01-Exercises.html#5480" data-type="(a b : Bool.Bool) → a Bool.|| b identity-type.≡ b Bool.|| a" class="Function">||-is-commutative</a> <a id="5498" class="Symbol">:</a> <a id="5500" class="Symbol">(</a><a id="5501" href="01-Exercises.html#5501" class="Bound">a</a> <a id="5503" href="01-Exercises.html#5503" class="Bound">b</a> <a id="5505" class="Symbol">:</a> <a id="5507" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a><a id="5511" class="Symbol">)</a> <a id="5513" class="Symbol">→</a> <a id="5515" href="01-Exercises.html#5501" class="Bound">a</a> <a id="5517" href="Bool.html#7417" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">||</a> <a id="5520" href="01-Exercises.html#5503" class="Bound">b</a> <a id="5522" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="5524" href="01-Exercises.html#5503" class="Bound">b</a> <a id="5526" href="Bool.html#7417" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">||</a> <a id="5529" href="01-Exercises.html#5501" class="Bound">a</a>
<a id="5531" href="01-Exercises.html#5480" data-type="(a b : Bool.Bool) → a Bool.|| b identity-type.≡ b Bool.|| a" class="Function">||-is-commutative</a> <a id="5549" href="01-Exercises.html#5549" class="Bound">a</a> <a id="5551" href="01-Exercises.html#5551" class="Bound">b</a> <a id="5553" class="Symbol">=</a> <a id="5555" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-2-2">Exercise 2 (★★)</h3>
<p>Taking inspiration from the above, try to <strong>state</strong> and
<strong>prove</strong> that <code>&amp;&amp;</code> is commutative.</p>
<pre class="Agda"><a id="&amp;&amp;-is-commutative"></a><a id="5687" href="01-Exercises.html#5687" data-type="unsolved#meta.79" class="Function">&amp;&amp;-is-commutative</a> <a id="5705" class="Symbol">:</a> <a id="5707" class="UnsolvedMeta Hole">{!!}</a>
<a id="5712" href="01-Exercises.html#5687" data-type="unsolved#meta.79" class="Function">&amp;&amp;-is-commutative</a> <a id="5730" class="Symbol">=</a> <a id="5732" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-3-2">Exercise 3 (★★)</h3>
<p><strong>Prove</strong> that <code>&amp;&amp;</code> and
<code>&amp;&amp;'</code> are both associative.</p>
<pre class="Agda"><a id="&amp;&amp;-is-associative"></a><a id="5824" href="01-Exercises.html#5824" data-type="(a b c : Bool.Bool) →
a Bool.&amp;&amp; b Bool.&amp;&amp; c identity-type.≡ (a Bool.&amp;&amp; b) Bool.&amp;&amp; c" class="Function">&amp;&amp;-is-associative</a> <a id="5842" class="Symbol">:</a> <a id="5844" class="Symbol">(</a><a id="5845" href="01-Exercises.html#5845" class="Bound">a</a> <a id="5847" href="01-Exercises.html#5847" class="Bound">b</a> <a id="5849" href="01-Exercises.html#5849" class="Bound">c</a> <a id="5851" class="Symbol">:</a> <a id="5853" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a><a id="5857" class="Symbol">)</a> <a id="5859" class="Symbol">→</a> <a id="5861" href="01-Exercises.html#5845" class="Bound">a</a> <a id="5863" href="Bool.html#7356" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;</a> <a id="5866" class="Symbol">(</a><a id="5867" href="01-Exercises.html#5847" class="Bound">b</a> <a id="5869" href="Bool.html#7356" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;</a> <a id="5872" href="01-Exercises.html#5849" class="Bound">c</a><a id="5873" class="Symbol">)</a> <a id="5875" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="5877" class="Symbol">(</a><a id="5878" href="01-Exercises.html#5845" class="Bound">a</a> <a id="5880" href="Bool.html#7356" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;</a> <a id="5883" href="01-Exercises.html#5847" class="Bound">b</a><a id="5884" class="Symbol">)</a> <a id="5886" href="Bool.html#7356" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;</a> <a id="5889" href="01-Exercises.html#5849" class="Bound">c</a>
<a id="5891" href="01-Exercises.html#5824" data-type="(a b c : Bool.Bool) →
a Bool.&amp;&amp; b Bool.&amp;&amp; c identity-type.≡ (a Bool.&amp;&amp; b) Bool.&amp;&amp; c" class="Function">&amp;&amp;-is-associative</a> <a id="5909" class="Symbol">=</a> <a id="5911" class="Hole">{!!}</a>

<a id="&amp;&amp;&#39;-is-associative"></a><a id="5917" href="01-Exercises.html#5917" data-type="(a b c : Bool.Bool) →
(a 01-Exercises.&amp;&amp;&#39; (b 01-Exercises.&amp;&amp;&#39; c)) identity-type.≡
((a 01-Exercises.&amp;&amp;&#39; b) 01-Exercises.&amp;&amp;&#39; c)" class="Function">&amp;&amp;&#39;-is-associative</a> <a id="5936" class="Symbol">:</a> <a id="5938" class="Symbol">(</a><a id="5939" href="01-Exercises.html#5939" class="Bound">a</a> <a id="5941" href="01-Exercises.html#5941" class="Bound">b</a> <a id="5943" href="01-Exercises.html#5943" class="Bound">c</a> <a id="5945" class="Symbol">:</a> <a id="5947" href="Bool.html#492" data-type="Set" class="Datatype">Bool</a><a id="5951" class="Symbol">)</a> <a id="5953" class="Symbol">→</a> <a id="5955" href="01-Exercises.html#5939" class="Bound">a</a> <a id="5957" href="01-Exercises.html#1389" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;&#39;</a> <a id="5961" class="Symbol">(</a><a id="5962" href="01-Exercises.html#5941" class="Bound">b</a> <a id="5964" href="01-Exercises.html#1389" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;&#39;</a> <a id="5968" href="01-Exercises.html#5943" class="Bound">c</a><a id="5969" class="Symbol">)</a> <a id="5971" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="5973" class="Symbol">(</a><a id="5974" href="01-Exercises.html#5939" class="Bound">a</a> <a id="5976" href="01-Exercises.html#1389" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;&#39;</a> <a id="5980" href="01-Exercises.html#5941" class="Bound">b</a><a id="5981" class="Symbol">)</a> <a id="5983" href="01-Exercises.html#1389" data-type="Bool.Bool → Bool.Bool → Bool.Bool" class="Function Operator">&amp;&amp;&#39;</a> <a id="5987" href="01-Exercises.html#5943" class="Bound">c</a>
<a id="5989" href="01-Exercises.html#5917" data-type="(a b c : Bool.Bool) →
(a 01-Exercises.&amp;&amp;&#39; (b 01-Exercises.&amp;&amp;&#39; c)) identity-type.≡
((a 01-Exercises.&amp;&amp;&#39; b) 01-Exercises.&amp;&amp;&#39; c)" class="Function">&amp;&amp;&#39;-is-associative</a> <a id="6008" class="Symbol">=</a> <a id="6010" class="Hole">{!!}</a>
</pre>
<p><strong>Question</strong>: Can you spot a downside of the more
verbose definition of <code>&amp;&amp;'</code> now?</p>
<h3 id="exercise-4-1">Exercise 4 (★★★)</h3>
<p>Another key feature of Agda is its ability to carry out inductive
proofs. For example, here is a commented inductive proof that
<code>max</code> is commutative.</p>
<pre class="Agda"><a id="max-is-commutative"></a><a id="6287" href="01-Exercises.html#6287" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">max-is-commutative</a> <a id="6306" class="Symbol">:</a> <a id="6308" class="Symbol">(</a><a id="6309" href="01-Exercises.html#6309" class="Bound">n</a> <a id="6311" href="01-Exercises.html#6311" class="Bound">m</a> <a id="6313" class="Symbol">:</a> <a id="6315" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="6316" class="Symbol">)</a> <a id="6318" class="Symbol">→</a> <a id="6320" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="6324" href="01-Exercises.html#6309" class="Bound">n</a> <a id="6326" href="01-Exercises.html#6311" class="Bound">m</a> <a id="6328" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6330" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="6334" href="01-Exercises.html#6311" class="Bound">m</a> <a id="6336" href="01-Exercises.html#6309" class="Bound">n</a>
<a id="6338" href="01-Exercises.html#6287" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">max-is-commutative</a> <a id="6357" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a>    <a id="6365" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a>    <a id="6373" class="Symbol">=</a> <a id="6375" href="identity-type.html#664" data-type="(x : A) → x identity-type.≡ x" class="InductiveConstructor">refl</a> <a id="6380" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a>
<a id="6385" href="01-Exercises.html#6287" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">max-is-commutative</a> <a id="6404" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a>    <a id="6412" class="Symbol">(</a><a id="6413" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6417" href="01-Exercises.html#6417" class="Bound">m</a><a id="6418" class="Symbol">)</a> <a id="6420" class="Symbol">=</a> <a id="6422" href="identity-type.html#664" data-type="(x : A) → x identity-type.≡ x" class="InductiveConstructor">refl</a> <a id="6427" class="Symbol">(</a><a id="6428" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6432" href="01-Exercises.html#6417" class="Bound">m</a><a id="6433" class="Symbol">)</a>
<a id="6435" href="01-Exercises.html#6287" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">max-is-commutative</a> <a id="6454" class="Symbol">(</a><a id="6455" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6459" href="01-Exercises.html#6459" class="Bound">n</a><a id="6460" class="Symbol">)</a> <a id="6462" href="introduction.html#1059" data-type="Fin.ℕ" class="InductiveConstructor">zero</a>    <a id="6470" class="Symbol">=</a> <a id="6472" href="identity-type.html#664" data-type="(x : A) → x identity-type.≡ x" class="InductiveConstructor">refl</a> <a id="6477" class="Symbol">(</a><a id="6478" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6482" href="01-Exercises.html#6459" class="Bound">n</a><a id="6483" class="Symbol">)</a>
<a id="6485" href="01-Exercises.html#6287" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">max-is-commutative</a> <a id="6504" class="Symbol">(</a><a id="6505" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6509" href="01-Exercises.html#6509" class="Bound">n</a><a id="6510" class="Symbol">)</a> <a id="6512" class="Symbol">(</a><a id="6513" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6517" href="01-Exercises.html#6517" class="Bound">m</a><a id="6518" class="Symbol">)</a> <a id="6520" class="Symbol">=</a> <a id="6522" href="01-Exercises.html#6662" data-type="(n m : Fin.ℕ) →
Fin.suc (01-Exercises.max n m) identity-type.≡
Fin.suc (01-Exercises.max m n)" class="Function">to-show</a>
 <a id="6531" class="Keyword">where</a>
  <a id="6539" href="01-Exercises.html#6539" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">IH</a> <a id="6542" class="Symbol">:</a> <a id="6544" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="6548" href="01-Exercises.html#6509" class="Bound">n</a> <a id="6550" href="01-Exercises.html#6517" class="Bound">m</a> <a id="6552" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6554" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="6558" href="01-Exercises.html#6517" class="Bound">m</a> <a id="6560" href="01-Exercises.html#6509" class="Bound">n</a>      <a id="6567" class="Comment">-- induction hypothesis</a>
  <a id="6593" href="01-Exercises.html#6539" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">IH</a> <a id="6596" class="Symbol">=</a> <a id="6598" href="01-Exercises.html#6287" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">max-is-commutative</a> <a id="6617" href="01-Exercises.html#6509" class="Bound">n</a> <a id="6619" href="01-Exercises.html#6517" class="Bound">m</a> <a id="6621" class="Comment">-- recursive call on smaller arguments</a>
  <a id="6662" href="01-Exercises.html#6662" data-type="(n m : Fin.ℕ) →
Fin.suc (01-Exercises.max n m) identity-type.≡
Fin.suc (01-Exercises.max m n)" class="Function">to-show</a> <a id="6670" class="Symbol">:</a> <a id="6672" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6676" class="Symbol">(</a><a id="6677" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="6681" href="01-Exercises.html#6509" class="Bound">n</a> <a id="6683" href="01-Exercises.html#6517" class="Bound">m</a><a id="6684" class="Symbol">)</a> <a id="6686" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6688" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6692" class="Symbol">(</a><a id="6693" href="01-Exercises.html#2445" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">max</a> <a id="6697" href="01-Exercises.html#6517" class="Bound">m</a> <a id="6699" href="01-Exercises.html#6509" class="Bound">n</a><a id="6700" class="Symbol">)</a>
  <a id="6704" href="01-Exercises.html#6662" data-type="(n m : Fin.ℕ) →
Fin.suc (01-Exercises.max n m) identity-type.≡
Fin.suc (01-Exercises.max m n)" class="Function">to-show</a> <a id="6712" class="Symbol">=</a> <a id="6714" href="identity-type.html#2307" data-type="(f : A → B) → x identity-type.≡ y → f x identity-type.≡ f y" class="Function">ap</a> <a id="6717" href="introduction.html#1069" data-type="Fin.ℕ → Fin.ℕ" class="InductiveConstructor">suc</a> <a id="6721" href="01-Exercises.html#6539" data-type="(n m : Fin.ℕ) →
01-Exercises.max n m identity-type.≡ 01-Exercises.max m n" class="Function">IH</a>         <a id="6732" class="Comment">-- ap(ply) suc on both sides of the equation</a>
</pre>
<p><strong>Prove</strong> analogously that <code>min</code> is
commutative.</p>
<pre class="Agda"><a id="min-is-commutative"></a><a id="6840" href="01-Exercises.html#6840" data-type="(n m : Fin.ℕ) →
01-Exercises.min n m identity-type.≡ 01-Exercises.min m n" class="Function">min-is-commutative</a> <a id="6859" class="Symbol">:</a> <a id="6861" class="Symbol">(</a><a id="6862" href="01-Exercises.html#6862" class="Bound">n</a> <a id="6864" href="01-Exercises.html#6864" class="Bound">m</a> <a id="6866" class="Symbol">:</a> <a id="6868" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="6869" class="Symbol">)</a> <a id="6871" class="Symbol">→</a> <a id="6873" href="01-Exercises.html#2622" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">min</a> <a id="6877" href="01-Exercises.html#6862" class="Bound">n</a> <a id="6879" href="01-Exercises.html#6864" class="Bound">m</a> <a id="6881" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="6883" href="01-Exercises.html#2622" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function">min</a> <a id="6887" href="01-Exercises.html#6864" class="Bound">m</a> <a id="6889" href="01-Exercises.html#6862" class="Bound">n</a>
<a id="6891" href="01-Exercises.html#6840" data-type="(n m : Fin.ℕ) →
01-Exercises.min n m identity-type.≡ 01-Exercises.min m n" class="Function">min-is-commutative</a> <a id="6910" class="Symbol">=</a> <a id="6912" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-5-1">Exercise 5 (★★★)</h3>
<p>Using another inductive proof, <strong>show</strong> that
<code>n ≡ n + 0</code> for every natural number <code>n</code>.</p>
<pre class="Agda"><a id="0-right-neutral"></a><a id="7040" href="01-Exercises.html#7040" data-type="(n : Fin.ℕ) → n identity-type.≡ n Fin.+ 0" class="Function">0-right-neutral</a> <a id="7056" class="Symbol">:</a> <a id="7058" class="Symbol">(</a><a id="7059" href="01-Exercises.html#7059" class="Bound">n</a> <a id="7061" class="Symbol">:</a> <a id="7063" href="introduction.html#1043" data-type="Set" class="Datatype">ℕ</a><a id="7064" class="Symbol">)</a> <a id="7066" class="Symbol">→</a> <a id="7068" href="01-Exercises.html#7059" class="Bound">n</a> <a id="7070" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7072" href="01-Exercises.html#7059" class="Bound">n</a> <a id="7074" href="natural-numbers-type.html#2879" data-type="Fin.ℕ → Fin.ℕ → Fin.ℕ" class="Function Operator">+</a> <a id="7076" class="Number">0</a>
<a id="7078" href="01-Exercises.html#7040" data-type="(n : Fin.ℕ) → n identity-type.≡ n Fin.+ 0" class="Function">0-right-neutral</a> <a id="7094" class="Symbol">=</a> <a id="7096" class="Hole">{!!}</a>
</pre>
<h3 id="exercise-6-1">Exercise 6 (★★★)</h3>
<p>The function <code>map</code> on lists is a so-called
<em>functor</em>, which means that it respects the identity and
composition, as formally expressed below.</p>
<p>Try to <strong>prove</strong> these equations using pattern matching
and inductive proofs.</p>
<pre class="Agda"><a id="map-id"></a><a id="7358" href="01-Exercises.html#7358" data-type="(xs : List.List X) →
01-Exercises.map products.id xs identity-type.≡ xs" class="Function">map-id</a> <a id="7365" class="Symbol">:</a> <a id="7367" class="Symbol">{</a><a id="7368" href="01-Exercises.html#7368" class="Bound">X</a> <a id="7370" class="Symbol">:</a> <a id="7372" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="7376" class="Symbol">}</a> <a id="7378" class="Symbol">(</a><a id="7379" href="01-Exercises.html#7379" class="Bound">xs</a> <a id="7382" class="Symbol">:</a> <a id="7384" href="List.html#402" data-type="general-notation.Type → Set" class="Datatype">List</a> <a id="7389" href="01-Exercises.html#7368" class="Bound">X</a><a id="7390" class="Symbol">)</a> <a id="7392" class="Symbol">→</a> <a id="7394" href="01-Exercises.html#3033" data-type="(X → Y) → List.List X → List.List Y" class="Function">map</a> <a id="7398" href="products.html#1041" data-type="A → A" class="Function">id</a> <a id="7401" href="01-Exercises.html#7379" class="Bound">xs</a> <a id="7404" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7406" href="01-Exercises.html#7379" class="Bound">xs</a>
<a id="7409" href="01-Exercises.html#7358" data-type="(xs : List.List X) →
01-Exercises.map products.id xs identity-type.≡ xs" class="Function">map-id</a> <a id="7416" href="01-Exercises.html#7416" class="Bound">xs</a> <a id="7419" class="Symbol">=</a> <a id="7421" class="Hole">{!!}</a>

<a id="map-comp"></a><a id="7427" href="01-Exercises.html#7427" data-type="(f : X → Y) (g : Y → Z) (xs : List.List X) →
01-Exercises.map (g products.∘ f) xs identity-type.≡
01-Exercises.map g (01-Exercises.map f xs)" class="Function">map-comp</a> <a id="7436" class="Symbol">:</a> <a id="7438" class="Symbol">{</a><a id="7439" href="01-Exercises.html#7439" class="Bound">X</a> <a id="7441" href="01-Exercises.html#7441" class="Bound">Y</a> <a id="7443" href="01-Exercises.html#7443" class="Bound">Z</a> <a id="7445" class="Symbol">:</a> <a id="7447" href="general-notation.html#715" data-type="Set₁" class="Function">Type</a><a id="7451" class="Symbol">}</a> <a id="7453" class="Symbol">(</a><a id="7454" href="01-Exercises.html#7454" class="Bound">f</a> <a id="7456" class="Symbol">:</a> <a id="7458" href="01-Exercises.html#7439" class="Bound">X</a> <a id="7460" class="Symbol">→</a> <a id="7462" href="01-Exercises.html#7441" class="Bound">Y</a><a id="7463" class="Symbol">)</a> <a id="7465" class="Symbol">(</a><a id="7466" href="01-Exercises.html#7466" class="Bound">g</a> <a id="7468" class="Symbol">:</a> <a id="7470" href="01-Exercises.html#7441" class="Bound">Y</a> <a id="7472" class="Symbol">→</a> <a id="7474" href="01-Exercises.html#7443" class="Bound">Z</a><a id="7475" class="Symbol">)</a>
           <a id="7488" class="Symbol">(</a><a id="7489" href="01-Exercises.html#7489" class="Bound">xs</a> <a id="7492" class="Symbol">:</a> <a id="7494" href="List.html#402" data-type="general-notation.Type → Set" class="Datatype">List</a> <a id="7499" href="01-Exercises.html#7439" class="Bound">X</a><a id="7500" class="Symbol">)</a> <a id="7502" class="Symbol">→</a> <a id="7504" href="01-Exercises.html#3033" data-type="(X → Y) → List.List X → List.List Y" class="Function">map</a> <a id="7508" class="Symbol">(</a><a id="7509" href="01-Exercises.html#7466" class="Bound">g</a> <a id="7511" href="products.html#3388" data-type="((y : B) → C y) → (f : A → B) (x : A) → C (f x)" class="Function Operator">∘</a> <a id="7513" href="01-Exercises.html#7454" class="Bound">f</a><a id="7514" class="Symbol">)</a> <a id="7516" href="01-Exercises.html#7489" class="Bound">xs</a> <a id="7519" href="identity-type.html#627" data-type="A → A → Set" class="Datatype Operator">≡</a> <a id="7521" href="01-Exercises.html#3033" data-type="(X → Y) → List.List X → List.List Y" class="Function">map</a> <a id="7525" href="01-Exercises.html#7466" class="Bound">g</a> <a id="7527" class="Symbol">(</a><a id="7528" href="01-Exercises.html#3033" data-type="(X → Y) → List.List X → List.List Y" class="Function">map</a> <a id="7532" href="01-Exercises.html#7454" class="Bound">f</a> <a id="7534" href="01-Exercises.html#7489" class="Bound">xs</a><a id="7536" class="Symbol">)</a>
<a id="7538" href="01-Exercises.html#7427" data-type="(f : X → Y) (g : Y → Z) (xs : List.List X) →
01-Exercises.map (g products.∘ f) xs identity-type.≡
01-Exercises.map g (01-Exercises.map f xs)" class="Function">map-comp</a> <a id="7547" href="01-Exercises.html#7547" class="Bound">f</a> <a id="7549" href="01-Exercises.html#7549" class="Bound">g</a> <a id="7551" href="01-Exercises.html#7551" class="Bound">xs</a> <a id="7554" class="Symbol">=</a> <a id="7556" class="Hole">{!!}</a>
</pre>

  </article>
</div>
</main>
</body>
<style>

:root {
  --text-bg: #fff;
  --text-fg: #222;
  --shadow: #000;
  --primary: #0054F4;
  --secondary: #9C1BD6;
  --modal-bg: #ccccccaa;
  --warning-bg: #fef08a;
  --code-bg: var(--text-bg);
  --code-fg: var(--text-fg);
  --code-keyword: #BB3B13;
  --code-string:  #d52753;
  --code-number:  #8A1060;
  --code-module:  #8A1060;
  --code-field:   #9C1BD6;
  --code-constructor: #207B1D;
  --code-highlight: #F5DEB3;
  --search-selected: #e2e8f0;
  --details-summary: #b2ebf2;
  --details-open:    #80deea;
  --depgraph-edge: #eee;
  --blockquote-bg: #d8b4fe; }

.diagram-dark {
  display: none !important; }

@media (prefers-color-scheme: dark) {
  :root {
    --text-bg: #282C34;
    --text-fg: #bfbfbf;
    --shadow: #475569;
    --primary: #61AFEF;
    --secondary: #C878DD;
    --modal-bg: #282C34aa;
    --warning-bg: #991b1b;
    --code-keyword:     #E5C07B;
    --code-string:      #E06C75;
    --code-number:      #98C379;
    --code-module:      #56B6C2;
    --code-field:       #C878DD;
    --code-constructor: #98C379;
    --code-highlight: #ef444499;
    --search-selected: #474e5e;
    --details-summary: #5b21b6;
    --details-open:    #4c1d95;
    --depgraph-edge: #474e5e;
    --blockquote-bg: #475569; }
  div.warning {
    --shadow: #7f1d1d
  ; }
  input {
    background-color: #334155;
    border: 1px solid #475569;
    color: var(--text-fg); }
  body {
    scrollbar-color: #3b4454 #2b2e33; }
  .diagram-dark {
    display: block !important; }
  .diagram-light {
    display: none !important; } }

table {
  margin: auto;
  border-collapse: collapse; }
  table td, table th {
    text-align: center;
    padding: 0px 1em 0px 1em;
    border: 1px solid black; }
  table th {
    border-bottom: 2px solid black; }
  table td {
    white-space: nowrap; }

html { max-width: 100%; }

body {
  font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  width: 100%;
  font-size: var(--font-size);
  overflow-x: clip;
  background-color: var(--text-bg);
  color: var(--text-fg);
}

div#post-toc-container { max-width: 120ch; margin: auto; }

article a[href], div#return > a[href], div#top > a[href], aside#toc > div#toc-container ul a[href] {
  color: var(--primary);
  text-decoration: none; }
  article a[href]:hover, div#return > a[href]:hover, div#top > a[href]:hover, aside#toc > div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important; }
  article a[href]:visited, div#return > a[href]:visited, div#top > a[href]:visited, aside#toc > div#toc-container ul a[href]:visited {
    color: var(--secondary); }

/* Aspects. */
.Agda {
  /* NameKinds. */
  /* OtherAspects. */
  /* Standard attributes. */
  font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
  font-weight: 400; }
  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic; }
  .Agda .Background {
    background-color: var(--code-bg); }
  .Agda .Markup {
    color: var(--code-fg); }
  .Agda .Keyword {
    color: var(--code-keyword); }
  .Agda .String {
    color: var(--code-string); }
  .Agda .Number {
    color: var(--code-number); }
  .Agda .Symbol {
    color: var(--code-fg); }
  .Agda .PrimitiveType {
    color: var(--primary); }
  .Agda .Pragma {
    color: var(--code-fg); }
  .Agda .Bound {
    color: var(--code-fg) !important; }
  .Agda .Generalizable {
    color: var(--code-fg) !important; }
  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important; }
  .Agda .Datatype {
    color: var(--primary) !important; }
  .Agda .Field {
    color: var(--code-field) !important; }
  .Agda .Function {
    color: var(--primary) !important; }
  .Agda .Module {
    color: var(--code-module) !important; }
  .Agda .Postulate {
    color: var(--primary) !important; }
  .Agda .Primitive {
    color: var(--primary) !important; }
  .Agda .Record {
    color: var(--primary) !important; }
  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow; }
  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow; }
  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A; }
  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3; }
  .Agda .Error {
    color: red;
    text-decoration: underline; }
  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6; }
  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080; }
  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold; }
  .Agda a {
    text-decoration: none; }
  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline; }
  .Agda a[href]:target {
    animation: highlight 2.5s; }
  body.text-page .Agda {
    font-size: var(--code-font-size); }

pre.Agda, div.sourceCode, pre {
  border-radius: 0;
  box-shadow: none;
  overflow-y: clip;
  margin: 0;
  padding: 1em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  background-color: var(--code-bg);
  color: var(--code-fg);
  font-size: var(--code-font-size);
  max-width: 100%;
  overflow-x: auto;
}
</style>
</html>
